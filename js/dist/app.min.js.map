{"version":3,"file":"app.min.js","sources":["libs/image-preloader.js","app/app.js","libs/log.js","libs/pixi.dev.js","app/model/GameModel.js","app/entity/Hero.js","app/controller/peripheral/KeyboardController.js","app/BattleWing.js"],"names":[],"mappings":"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","sourcesContent":["\nfunction ImagePreloader ()\n{\n\t//---------------------------------------------------------------------------------------\n\t// PRIVATE PROPERTIES\n\t//---------------------------------------------------------------------------------------\n\tvar _self\t\t\t\t\t\t= this,\n\t\t_totalImagesLoading\t\t\t= 0,\n\t\t_allImagesLoadedCallback;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// PRIVATE METHODS\n\t//---------------------------------------------------------------------------------------\n\tfunction imageLoaded (event)\n\t{\n\t\t// console.log (\"ImagePreloader:: imageLoaded... src: \" + this.src);\n\n\t\t_totalImagesLoading--;\n\n\t\tif (typeof this.cb !== \"undefined\") this.cb ();\n\n\t\t// console.log (\"ImagePreloader:: [imageLoaded] _totalImagesLoading: \" + _totalImagesLoading);\n\n\t\tif (_totalImagesLoading === 0)\n\t\t{\n\t\t\tif (typeof _allImagesLoadedCallback !== \"undefined\") _allImagesLoadedCallback ();\n\n\t\t\t_allImagesLoadedCallback = undefined;\n\t\t}\n\t}\n\n\tfunction preloadImage (imageURL, cb)\n\t{\n\t\tif (typeof (imageURL) === \"undefined\" || imageURL === \"\")\n\t\t{\n\t\t\t// console.log (\"ImagePreloader:: [preloadImage] imageURL is not defined, or is an empty string... forcing 'imageLoaded' method and returning.\");\n\t\t\t\n\t\t\timageLoaded ();\n\t\t\tif (typeof cb !== \"undefined\") cb ();\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log (\"ImagePreloader:: [preloadImage]... url:\" + imageURL);\n\n\t\tvar image = new Image ();\n\t\timage.onload = imageLoaded;\n\t\timage.cb = typeof cb !== \"undefined\" ? cb : undefined;\n\t\timage.src = imageURL;\n\t}\n\n\t//---------------------------------------------------------------------------------------\n\t// PUBLIC API\n\t//---------------------------------------------------------------------------------------\n\t_self.load = function (imageURL, cb)\n\t{\n\t\t_totalImagesLoading++;\n\t\tpreloadImage (imageURL, cb);\n\t};\n\n\t_self.loadMultiple = function (imageURLArray, cb)\n\t{\n\t\t_allImagesLoadedCallback = cb;\n\n\t\tvar i = 0,\n\t\t\tlength = imageURLArray.length;\n\n\t\t_totalImagesLoading += length;\n\n\t\tfor (i; i < length; i++)\n\t\t{\n\t\t\tpreloadImage (imageURLArray[i]);\n\t\t}\n\t};\n};\ndefine(\"ImagePreloader\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.ImagePreloader;\n    };\n}(this)));\n","\nwindow.DEBUG = true;\n\nrequire ([\"log\", \"BattleWing\"], app);\n\nfunction app (log, BattleWing)\n{\n\t// Make log global if the DEBUG flag is set to 'true', otherwise cancel all logs.\n\twindow.log = window.DEBUG ? log : function (){return false;};\n\n\tlog (\"App::\");\n\n\t// call the constructor function of the document class to start the app.\n\tBattleWing ();\n};\ndefine(\"app/app\", function(){});\n","\nwindow.log = function f() {\n    log.history = log.history || [];\n    log.history.push(arguments);\n    if (this.console) {\n        var args = arguments;\n        var newarr;\n\n        try {\n            args.callee = f.caller;\n        } catch(e) {\n\n        }\n\n        newarr = [].slice.call(args);\n\n        if (typeof console.log === 'object') {\n            log.apply.call(console.log, console, newarr);\n        } else {\n            console.log.apply(console, newarr);\n        }\n    }\n};\n\n// make it safe to use console.log always\n\n(function(a) {\n    function b() {}\n    var c = \"assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,time,timeEnd,trace,warn\";\n    var d;\n    for (c = c.split(\",\"); !!(d = c.pop());) {\n        a[d] = a[d] || b;\n    }\n})(function() {\n    try {\n        console.log();\n        return window.console;\n    } catch(a) {\n        return (window.console = {});\n    }\n}());\ndefine(\"log\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.log;\n    };\n}(this)));\n","\n/**\n * @license\n * Pixi.JS - v1.3.0\n * Copyright (c) 2012, Mat Groves\n * http://goodboydigital.com/\n *\n * Compiled: 2013-10-17\n *\n * Pixi.JS is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license.php\n */\n/**\r\n * @author Mat Groves http://matgroves.com/ @Doormat23\r\n */\r\n\r\n(function(){\r\n\r\n\tvar root = this;\r\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @module PIXI\n */\nvar PIXI = PIXI || {};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.\n *\n * @class Point\n * @constructor \n * @param x {Number} position of the point\n * @param y {Number} position of the point\n */\nPIXI.Point = function(x, y)\n{\n\t/**\n\t * @property x \n\t * @type Number\n\t * @default 0\n\t */\n\tthis.x = x || 0;\n\t\n\t/**\n\t * @property y\n\t * @type Number\n\t * @default 0\n\t */\n\tthis.y = y || 0;\n}\n\n/**\n * Creates a clone of this point\n *\n * @method clone\n * @return {Point} a copy of the point\n */\nPIXI.Point.prototype.clone = function()\n{\n\treturn new PIXI.Point(this.x, this.y);\n}\n\n// constructor\nPIXI.Point.prototype.constructor = PIXI.Point;\n\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.\n *\n * @class Rectangle\n * @constructor \n * @param x {Number} The X coord of the upper-left corner of the rectangle\n * @param y {Number} The Y coord of the upper-left corner of the rectangle\n * @param width {Number} The overall wisth of this rectangle\n * @param height {Number} The overall height of this rectangle\n */\nPIXI.Rectangle = function(x, y, width, height)\n{\n\t/**\n\t * @property x\n\t * @type Number\n\t * @default 0\n\t */\n\tthis.x = x || 0;\n\t\n\t/**\n\t * @property y\n\t * @type Number\n\t * @default 0\n\t */\n\tthis.y = y || 0;\n\t\n\t/**\n\t * @property width\n\t * @type Number\n\t * @default 0\n\t */\n\tthis.width = width || 0;\n\t\n\t/**\n\t * @property height\n\t * @type Number\n\t * @default 0\n\t */\n\tthis.height = height || 0;\n}\n\n/**\n * Creates a clone of this Rectangle\n *\n * @method clone\n * @return {Rectangle} a copy of the rectangle\n */\nPIXI.Rectangle.prototype.clone = function()\n{\n\treturn new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n}\n\n/**\n * Checks if the x, and y coords passed to this function are contained within this Rectangle\n *\n * @method contains\n * @param x {Number} The X coord of the point to test\n * @param y {Number} The Y coord of the point to test\n * @return {Boolean} if the x/y coords are within this Rectangle\n */\nPIXI.Rectangle.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n\tvar x1 = this.x;\n\tif(x >= x1 && x <= x1 + this.width)\n\t{\n\t\tvar y1 = this.y;\n\t\t\n\t\tif(y >= y1 && y <= y1 + this.height)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// constructor\nPIXI.Rectangle.prototype.constructor = PIXI.Rectangle;\n\n\n/**\n * @author Adrien Brault <adrien.brault@gmail.com>\n */\n\n/**\n * @class Polygon\n * @constructor\n * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arugments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\nPIXI.Polygon = function(points)\n{\n    //if points isn't an array, use arguments as the array\n    if(!(points instanceof Array))\n        points = Array.prototype.slice.call(arguments);\n\n    //if this is a flat array of numbers, convert it to points\n    if(typeof points[0] === 'number') {\n        var p = [];\n        for(var i = 0, il = points.length; i < il; i+=2) {\n            p.push(\n                new PIXI.Point(points[i], points[i + 1])\n            );\n        }\n\n        points = p;\n    }\n\n\tthis.points = points;\n}\n\n/**\n * Creates a clone of this polygon\n *\n * @method clone\n * @return {Polygon} a copy of the polygon\n */\nPIXI.Polygon.prototype.clone = function()\n{\n\tvar points = [];\n\tfor (var i=0; i<this.points.length; i++) {\n\t\tpoints.push(this.points[i].clone());\n\t}\n\n\treturn new PIXI.Polygon(points);\n}\n\n/**\n * Checks if the x, and y coords passed to this function are contained within this polygon\n *\n * @method contains\n * @param x {Number} The X coord of the point to test\n * @param y {Number} The Y coord of the point to test\n * @return {Boolean} if the x/y coords are within this polygon\n */\nPIXI.Polygon.prototype.contains = function(x, y)\n{\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    for(var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y,\n            xj = this.points[j].x, yj = this.points[j].y,\n            intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n        if(intersect) inside = !inside;\n    }\n\n    return inside;\n}\n\nPIXI.Polygon.prototype.constructor = PIXI.Polygon;\n\n\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Circle object can be used to specify a hit area for displayobjects\n *\n * @class Circle\n * @constructor\n * @param x {Number} The X coord of the upper-left corner of the framing rectangle of this circle\n * @param y {Number} The Y coord of the upper-left corner of the framing rectangle of this circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Circle = function(x, y, radius)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n    \n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property radius\n     * @type Number\n     * @default 0\n     */\n    this.radius = radius || 0;\n}\n\n/**\n * Creates a clone of this Circle instance\n *\n * @method clone\n * @return {Circle} a copy of the polygon\n */\nPIXI.Circle.prototype.clone = function()\n{\n    return new PIXI.Circle(this.x, this.y, this.radius);\n}\n\n/**\n * Checks if the x, and y coords passed to this function are contained within this circle\n *\n * @method contains\n * @param x {Number} The X coord of the point to test\n * @param y {Number} The Y coord of the point to test\n * @return {Boolean} if the x/y coords are within this polygon\n */\nPIXI.Circle.prototype.contains = function(x, y)\n{\n    if(this.radius <= 0)\n        return false;\n\n    var dx = (this.x - x),\n        dy = (this.y - y),\n        r2 = this.radius * this.radius;\n\n    dx *= dx;\n    dy *= dy;\n\n    return (dx + dy <= r2);\n}\n\nPIXI.Circle.prototype.constructor = PIXI.Circle;\n\n\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Ellipse object can be used to specify a hit area for displayobjects\n *\n * @class Ellipse\n * @constructor\n * @param x {Number} The X coord of the upper-left corner of the framing rectangle of this ellipse\n * @param y {Number} The Y coord of the upper-left corner of the framing rectangle of this ellipse\n * @param width {Number} The overall height of this ellipse\n * @param height {Number} The overall width of this ellipse\n */\nPIXI.Ellipse = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n    \n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n    \n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n    \n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n}\n\n/**\n * Creates a clone of this Ellipse instance\n *\n * @method clone\n * @return {Ellipse} a copy of the ellipse\n */\nPIXI.Ellipse.prototype.clone = function()\n{\n    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);\n}\n\n/**\n * Checks if the x, and y coords passed to this function are contained within this ellipse\n *\n * @method contains\n * @param x {Number} The X coord of the point to test\n * @param y {Number} The Y coord of the point to test\n * @return {Boolean} if the x/y coords are within this ellipse\n */\nPIXI.Ellipse.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    //normalize the coords to an ellipse with center 0,0\n    //and a radius of 0.5\n    var normx = ((x - this.x) / this.width) - 0.5,\n        normy = ((y - this.y) / this.height) - 0.5;\n\n    normx *= normx;\n    normy *= normy;\n\n    return (normx + normy < 0.25);\n}\n\nPIXI.Ellipse.getBounds = function()\n{\n    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n}\n\nPIXI.Ellipse.prototype.constructor = PIXI.Ellipse;\n\n\n\n\n/*\n * A lighter version of the rad gl-matrix created by Brandon Jones, Colin MacKenzie IV\n * you both rock!\n */\n\nfunction determineMatrixArrayType() {\n    PIXI.Matrix = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\n    return PIXI.Matrix;\n}\n\ndetermineMatrixArrayType();\n\nPIXI.mat3 = {};\n\nPIXI.mat3.create = function()\n{\n\tvar matrix = new PIXI.Matrix(9);\n\n\tmatrix[0] = 1;\n\tmatrix[1] = 0;\n\tmatrix[2] = 0;\n\tmatrix[3] = 0;\n\tmatrix[4] = 1;\n\tmatrix[5] = 0;\n\tmatrix[6] = 0;\n\tmatrix[7] = 0;\n\tmatrix[8] = 1;\n\t\n\treturn matrix;\n}\n\n\nPIXI.mat3.identity = function(matrix)\n{\n\tmatrix[0] = 1;\n\tmatrix[1] = 0;\n\tmatrix[2] = 0;\n\tmatrix[3] = 0;\n\tmatrix[4] = 1;\n\tmatrix[5] = 0;\n\tmatrix[6] = 0;\n\tmatrix[7] = 0;\n\tmatrix[8] = 1;\n\t\n\treturn matrix;\n}\n\n\nPIXI.mat4 = {};\n\nPIXI.mat4.create = function()\n{\n\tvar matrix = new PIXI.Matrix(16);\n\n\tmatrix[0] = 1;\n\tmatrix[1] = 0;\n\tmatrix[2] = 0;\n\tmatrix[3] = 0;\n\tmatrix[4] = 0;\n\tmatrix[5] = 1;\n\tmatrix[6] = 0;\n\tmatrix[7] = 0;\n\tmatrix[8] = 0;\n\tmatrix[9] = 0;\n\tmatrix[10] = 1;\n\tmatrix[11] = 0;\n\tmatrix[12] = 0;\n\tmatrix[13] = 0;\n\tmatrix[14] = 0;\n\tmatrix[15] = 1;\n\t\n\treturn matrix;\n}\n\nPIXI.mat3.multiply = function (mat, mat2, dest) \n{\n\tif (!dest) { dest = mat; }\n\t\n\t// Cache the matrix values (makes for huge speed increases!)\n\tvar a00 = mat[0], a01 = mat[1], a02 = mat[2],\n\t    a10 = mat[3], a11 = mat[4], a12 = mat[5],\n\t    a20 = mat[6], a21 = mat[7], a22 = mat[8],\n\t\n\t    b00 = mat2[0], b01 = mat2[1], b02 = mat2[2],\n\t    b10 = mat2[3], b11 = mat2[4], b12 = mat2[5],\n\t    b20 = mat2[6], b21 = mat2[7], b22 = mat2[8];\n\t\n\tdest[0] = b00 * a00 + b01 * a10 + b02 * a20;\n\tdest[1] = b00 * a01 + b01 * a11 + b02 * a21;\n\tdest[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\t\n\tdest[3] = b10 * a00 + b11 * a10 + b12 * a20;\n\tdest[4] = b10 * a01 + b11 * a11 + b12 * a21;\n\tdest[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\t\n\tdest[6] = b20 * a00 + b21 * a10 + b22 * a20;\n\tdest[7] = b20 * a01 + b21 * a11 + b22 * a21;\n\tdest[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\t\n\treturn dest;\n}\n\nPIXI.mat3.clone = function(mat)\n{\n\tvar matrix = new PIXI.Matrix(9);\n\n\tmatrix[0] = mat[0];\n\tmatrix[1] = mat[1];\n\tmatrix[2] = mat[2];\n\tmatrix[3] = mat[3];\n\tmatrix[4] = mat[4];\n\tmatrix[5] = mat[5];\n\tmatrix[6] = mat[6];\n\tmatrix[7] = mat[7];\n\tmatrix[8] = mat[8];\n\t\n\treturn matrix;\n}\n\nPIXI.mat3.transpose = function (mat, dest) \n{\n \t// If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (!dest || mat === dest) {\n        var a01 = mat[1], a02 = mat[2],\n            a12 = mat[5];\n\n        mat[1] = mat[3];\n        mat[2] = mat[6];\n        mat[3] = a01;\n        mat[5] = mat[7];\n        mat[6] = a02;\n        mat[7] = a12;\n        return mat;\n    }\n\n    dest[0] = mat[0];\n    dest[1] = mat[3];\n    dest[2] = mat[6];\n    dest[3] = mat[1];\n    dest[4] = mat[4];\n    dest[5] = mat[7];\n    dest[6] = mat[2];\n    dest[7] = mat[5];\n    dest[8] = mat[8];\n    return dest;\n}\n\nPIXI.mat3.toMat4 = function (mat, dest) \n{\n\tif (!dest) { dest = PIXI.mat4.create(); }\n\t\n\tdest[15] = 1;\n\tdest[14] = 0;\n\tdest[13] = 0;\n\tdest[12] = 0;\n\t\n\tdest[11] = 0;\n\tdest[10] = mat[8];\n\tdest[9] = mat[7];\n\tdest[8] = mat[6];\n\t\n\tdest[7] = 0;\n\tdest[6] = mat[5];\n\tdest[5] = mat[4];\n\tdest[4] = mat[3];\n\t\n\tdest[3] = 0;\n\tdest[2] = mat[2];\n\tdest[1] = mat[1];\n\tdest[0] = mat[0];\n\t\n\treturn dest;\n}\n\n\n/////\n\n\nPIXI.mat4.create = function()\n{\n\tvar matrix = new PIXI.Matrix(16);\n\n\tmatrix[0] = 1;\n\tmatrix[1] = 0;\n\tmatrix[2] = 0;\n\tmatrix[3] = 0;\n\tmatrix[4] = 0;\n\tmatrix[5] = 1;\n\tmatrix[6] = 0;\n\tmatrix[7] = 0;\n\tmatrix[8] = 0;\n\tmatrix[9] = 0;\n\tmatrix[10] = 1;\n\tmatrix[11] = 0;\n\tmatrix[12] = 0;\n\tmatrix[13] = 0;\n\tmatrix[14] = 0;\n\tmatrix[15] = 1;\n\t\n\treturn matrix;\n}\n\nPIXI.mat4.transpose = function (mat, dest) \n{\n\t// If we are transposing ourselves we can skip a few steps but have to cache some values\n\tif (!dest || mat === dest) \n\t{\n\t    var a01 = mat[1], a02 = mat[2], a03 = mat[3],\n\t        a12 = mat[6], a13 = mat[7],\n\t        a23 = mat[11];\n\t\n\t    mat[1] = mat[4];\n\t    mat[2] = mat[8];\n\t    mat[3] = mat[12];\n\t    mat[4] = a01;\n\t    mat[6] = mat[9];\n\t    mat[7] = mat[13];\n\t    mat[8] = a02;\n\t    mat[9] = a12;\n\t    mat[11] = mat[14];\n\t    mat[12] = a03;\n\t    mat[13] = a13;\n\t    mat[14] = a23;\n\t    return mat;\n\t}\n\t\n\tdest[0] = mat[0];\n\tdest[1] = mat[4];\n\tdest[2] = mat[8];\n\tdest[3] = mat[12];\n\tdest[4] = mat[1];\n\tdest[5] = mat[5];\n\tdest[6] = mat[9];\n\tdest[7] = mat[13];\n\tdest[8] = mat[2];\n\tdest[9] = mat[6];\n\tdest[10] = mat[10];\n\tdest[11] = mat[14];\n\tdest[12] = mat[3];\n\tdest[13] = mat[7];\n\tdest[14] = mat[11];\n\tdest[15] = mat[15];\n\treturn dest;\n}\n\nPIXI.mat4.multiply = function (mat, mat2, dest) \n{\n\tif (!dest) { dest = mat; }\n\t\n\t// Cache the matrix values (makes for huge speed increases!)\n\tvar a00 = mat[ 0], a01 = mat[ 1], a02 = mat[ 2], a03 = mat[3];\n\tvar a10 = mat[ 4], a11 = mat[ 5], a12 = mat[ 6], a13 = mat[7];\n\tvar a20 = mat[ 8], a21 = mat[ 9], a22 = mat[10], a23 = mat[11];\n\tvar a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];\n\t\n\t// Cache only the current line of the second matrix\n    var b0  = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];  \n    dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = mat2[4];\n    b1 = mat2[5];\n    b2 = mat2[6];\n    b3 = mat2[7];\n    dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = mat2[8];\n    b1 = mat2[9];\n    b2 = mat2[10];\n    b3 = mat2[11];\n    dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = mat2[12];\n    b1 = mat2[13];\n    b2 = mat2[14];\n    b3 = mat2[15];\n    dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    return dest;\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * @class DisplayObject\n * @constructor\n */\nPIXI.DisplayObject = function()\n{\n\tthis.last = this;\n\tthis.first = this;\n\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t *\n\t * @property position\n\t * @type Point\n\t */\n\tthis.position = new PIXI.Point();\n\n\t/**\n\t * The scale factor of the object.\n\t *\n\t * @property scale\n\t * @type Point\n\t */\n\tthis.scale = new PIXI.Point(1,1);//{x:1, y:1};\n\n\t/**\n\t * The pivot point of the displayObject that it rotates around\n\t *\n\t * @property pivot\n\t * @type Point\n\t */\n\tthis.pivot = new PIXI.Point(0,0);\n\n\t/**\n\t * The rotation of the object in radians.\n\t *\n\t * @property rotation\n\t * @type Number\n\t */\n\tthis.rotation = 0;\n\n\t/**\n\t * The opacity of the object.\n\t *\n\t * @property alpha\n\t * @type Number\n\t */\t\n\tthis.alpha = 1;\n\n\t/**\n\t * The visibility of the object.\n\t *\n\t * @property visible\n\t * @type Boolean\n\t */\t\n\tthis.visible = true;\n\n\t/**\n\t * This is the defined area that will pick up mouse / touch events. It is null by default.\n\t * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)\n\t *\n\t * @property hitArea\n\t * @type Rectangle|Circle|Ellipse|Polygon\n\t */\t\n\tthis.hitArea = null;\n\n\t/**\n\t * This is used to indicate if the displayObject should display a mouse hand cursor on rollover\n\t *\n\t * @property buttonMode\n\t * @type Boolean\n\t */\n\tthis.buttonMode = false;\n\n\t/**\n\t * Can this object be rendered\n\t *\n\t * @property renderable\n\t * @type Boolean\n\t */\n\tthis.renderable = false;\n\n\t/**\n\t * [read-only] The display object container that contains this display object.\n\t *\n\t * @property parent\n\t * @type DisplayObjectContainer\n\t * @readOnly\n\t */\t\n\tthis.parent = null;\n\n\t/**\n\t * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.\n\t *\n\t * @property stage\n\t * @type Stage\n\t * @readOnly\n\t */\t\n\tthis.stage = null;\n\n\t/**\n\t * [read-only] The multiplied alpha of the displayobject\n\t *\n\t * @property worldAlpha\n\t * @type Number\n\t * @readOnly\n\t */\n\tthis.worldAlpha = 1;\n\n\t/**\n\t * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property\n\t *\n\t * @property _interactive\n\t * @type Boolean\n\t * @readOnly\n\t * @private\n\t */\n\tthis._interactive = false;\n\n\t/**\n\t * [read-only] Current transform of the object based on world (parent) factors\n\t *\n\t * @property worldTransform\n\t * @type Mat3\n\t * @readOnly\n\t * @private\n\t */\n\tthis.worldTransform = PIXI.mat3.create()//mat3.identity();\n\n\t/**\n\t * [read-only] Current transform of the object locally\n\t *\n\t * @property localTransform\n\t * @type Mat3\n\t * @readOnly\n\t * @private\n\t */\n\tthis.localTransform = PIXI.mat3.create()//mat3.identity();\n\n\t/**\n\t * [NYI] Unkown\n\t *\n\t * @property color\n\t * @type Array<>\n\t * @private\n\t */\n\tthis.color = [];\n\n\t/**\n\t * [NYI] Holds whether or not this object is dynamic, for rendering optimization\n\t *\n\t * @property dynamic\n\t * @type Boolean\n\t * @private\n\t */\n\tthis.dynamic = true;\n\n\t// chach that puppy!\n\tthis._sr = 0;\n\tthis._cr = 1;\n\n\t/*\n\t * MOUSE Callbacks\n\t */\n\n\t/**\n\t * A callback that is used when the users clicks on the displayObject with their mouse\n\t * @method click\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the user clicks the mouse down over the sprite\n\t * @method mousedown\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the user releases the mouse that was over the displayObject\n\t * for this callback to be fired the mouse must have been pressed down over the displayObject\n\t * @method mouseup\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the user releases the mouse that was over the displayObject but is no longer over the displayObject\n\t * for this callback to be fired, The touch must have started over the displayObject\n\t * @method mouseupoutside\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the users mouse rolls over the displayObject\n\t * @method mouseover\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the users mouse leaves the displayObject\n\t * @method mouseout\n\t * @param interactionData {InteractionData}\n\t */\n\n\n\t/*\n\t * TOUCH Callbacks\n\t */\n\n\t/**\n\t * A callback that is used when the users taps on the sprite with their finger\n\t * basically a touch version of click\n\t * @method tap\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the user touch's over the displayObject\n\t * @method touchstart\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the user releases a touch over the displayObject\n\t * @method touchend\n\t * @param interactionData {InteractionData}\n\t */\n\n\t/**\n\t * A callback that is used when the user releases the touch that was over the displayObject\n\t * for this callback to be fired, The touch must have started over the sprite\n\t * @method touchendoutside\n\t * @param interactionData {InteractionData}\n\t */\n}\n\n// constructor\nPIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;\n\n/**\n * [Deprecated] Indicates if the sprite will have touch and mouse interactivity. It is false by default\n * Instead of using this function you can now simply set the interactive property to true or false\n *\n * @method setInteractive\n * @param interactive {Boolean}\n * @deprecated Simply set the `interactive` property directly\n */\nPIXI.DisplayObject.prototype.setInteractive = function(interactive)\n{\n\tthis.interactive = interactive;\n}\n\n/**\n * Indicates if the sprite will have touch and mouse interactivity. It is false by default\n *\n * @property interactive\n * @type Boolean\n * @default false\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {\n    get: function() {\n        return this._interactive;\n    },\n    set: function(value) {\n    \tthis._interactive = value;\n    \t\n    \t// TODO more to be done here..\n\t\t// need to sort out a re-crawl!\n\t\tif(this.stage)this.stage.dirty = true;\n    }\n});\n\n/**\n * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n * In PIXI a regular mask must be a PIXI.Ggraphics object. This allows for much faster masking in canvas as it utilises shape clipping.\n * To remove a mask, set this property to null.\n *\n * @property mask\n * @type Graphics\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'mask', {\n    get: function() {\n        return this._mask;\n    },\n    set: function(value) {\n    \t\n        this._mask = value;\n        \n        if(value)\n        {\n\t        this.addFilter(value)\n        }\n        else\n        {\n        \t this.removeFilter();\n        }\n    }\n});\n\n/*\n * Adds a filter to this displayObject\n *\n * @method addFilter\n * @param mask {Graphics} the graphics object to use as a filter\n * @private\n */\nPIXI.DisplayObject.prototype.addFilter = function(mask)\n{\n\tif(this.filter)return;\n\tthis.filter = true;\n\t\n\t// insert a filter block..\n\tvar start = new PIXI.FilterBlock();\n\tvar end = new PIXI.FilterBlock();\n\t\n\tstart.mask = mask;\n\tend.mask = mask;\n\t\n\tstart.first = start.last =  this;\n\tend.first = end.last = this;\n\t\n\tstart.open = true;\n\t\n\t/*\n\t * insert start\n\t */\n\t\n\tvar childFirst = start\n\tvar childLast = start\n\tvar nextObject;\n\tvar previousObject;\n\t\t\n\tpreviousObject = this.first._iPrev;\n\t\n\tif(previousObject)\n\t{\n\t\tnextObject = previousObject._iNext;\n\t\tchildFirst._iPrev = previousObject;\n\t\tpreviousObject._iNext = childFirst;\t\t\n\t}\n\telse\n\t{\n\t\tnextObject = this;\n\t}\t\n\t\n\tif(nextObject)\n\t{\n\t\tnextObject._iPrev = childLast;\n\t\tchildLast._iNext = nextObject;\n\t}\n\t\n\t\n\t// now insert the end filter block..\n\t\n\t/*\n\t * insert end filter\n\t */\n\tvar childFirst = end\n\tvar childLast = end\n\tvar nextObject = null;\n\tvar previousObject = null;\n\t\t\n\tpreviousObject = this.last;\n\tnextObject = previousObject._iNext;\n\t\n\tif(nextObject)\n\t{\n\t\tnextObject._iPrev = childLast;\n\t\tchildLast._iNext = nextObject;\n\t}\n\t\n\tchildFirst._iPrev = previousObject;\n\tpreviousObject._iNext = childFirst;\t\n\t\n\tvar updateLast = this;\n\t\n\tvar prevLast = this.last;\n\twhile(updateLast)\n\t{\n\t\tif(updateLast.last == prevLast)\n\t\t{\n\t\t\tupdateLast.last = end;\n\t\t}\n\t\tupdateLast = updateLast.parent;\n\t}\n\t\n\tthis.first = start;\n\t\n\t// if webGL...\n\tif(this.__renderGroup)\n\t{\n\t\tthis.__renderGroup.addFilterBlocks(start, end);\n\t}\n\t\n\tmask.renderable = false;\n\t\n}\n\n/*\n * Removes the filter to this displayObject\n *\n * @method removeFilter\n * @private\n */\nPIXI.DisplayObject.prototype.removeFilter = function()\n{\n\tif(!this.filter)return;\n\tthis.filter = false;\n\t\n\t// modify the list..\n\tvar startBlock = this.first;\n\t\n\tvar nextObject = startBlock._iNext;\n\tvar previousObject = startBlock._iPrev;\n\t\t\n\tif(nextObject)nextObject._iPrev = previousObject;\n\tif(previousObject)previousObject._iNext = nextObject;\t\t\n\t\n\tthis.first = startBlock._iNext;\n\t\n\t\n\t// remove the end filter\n\tvar lastBlock = this.last;\n\t\n\tvar nextObject = lastBlock._iNext;\n\tvar previousObject = lastBlock._iPrev;\n\t\t\n\tif(nextObject)nextObject._iPrev = previousObject;\n\tpreviousObject._iNext = nextObject;\t\t\n\t\n\t// this is always true too!\n\tvar tempLast =  lastBlock._iPrev;\t\n\t// need to make sure the parents last is updated too\n\tvar updateLast = this;\n\twhile(updateLast.last == lastBlock)\n\t{\n\t\tupdateLast.last = tempLast;\n\t\tupdateLast = updateLast.parent;\n\t\tif(!updateLast)break;\n\t}\n\t\n\tvar mask = startBlock.mask\n\tmask.renderable = true;\n\t\n\t// if webGL...\n\tif(this.__renderGroup)\n\t{\n\t\tthis.__renderGroup.removeFilterBlocks(startBlock, lastBlock);\n\t}\n}\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObject.prototype.updateTransform = function()\n{\n\t// TODO OPTIMIZE THIS!! with dirty\n\tif(this.rotation !== this.rotationCache)\n\t{\n\t\tthis.rotationCache = this.rotation;\n\t\tthis._sr =  Math.sin(this.rotation);\n\t\tthis._cr =  Math.cos(this.rotation);\n\t}\t\n\t\n\tvar localTransform = this.localTransform;\n\tvar parentTransform = this.parent.worldTransform;\n\tvar worldTransform = this.worldTransform;\n\t//console.log(localTransform)\n\tlocalTransform[0] = this._cr * this.scale.x;\n\tlocalTransform[1] = -this._sr * this.scale.y\n\tlocalTransform[3] = this._sr * this.scale.x;\n\tlocalTransform[4] = this._cr * this.scale.y;\n\t\n\t// TODO --> do we even need a local matrix???\n\t\n\tvar px = this.pivot.x;\n\tvar py = this.pivot.y;\n   \t\n    // Cache the matrix values (makes for huge speed increases!)\n    var a00 = localTransform[0], a01 = localTransform[1], a02 = this.position.x - localTransform[0] * px - py * localTransform[1],\n        a10 = localTransform[3], a11 = localTransform[4], a12 = this.position.y - localTransform[4] * py - px * localTransform[3],\n\n        b00 = parentTransform[0], b01 = parentTransform[1], b02 = parentTransform[2],\n        b10 = parentTransform[3], b11 = parentTransform[4], b12 = parentTransform[5];\n\n\tlocalTransform[2] = a02\n\tlocalTransform[5] = a12\n\t\n    worldTransform[0] = b00 * a00 + b01 * a10;\n    worldTransform[1] = b00 * a01 + b01 * a11;\n    worldTransform[2] = b00 * a02 + b01 * a12 + b02;\n\n    worldTransform[3] = b10 * a00 + b11 * a10;\n    worldTransform[4] = b10 * a01 + b11 * a11;\n    worldTransform[5] = b10 * a02 + b11 * a12 + b12;\n\n\t// because we are using affine transformation, we can optimise the matrix concatenation process.. wooo!\n\t// mat3.multiply(this.localTransform, this.parent.worldTransform, this.worldTransform);\n\tthis.worldAlpha = this.alpha * this.parent.worldAlpha;\n\t\n\tthis.vcount = PIXI.visibleCount;\n\n}\n\nPIXI.visibleCount = 0;\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A DisplayObjectContainer represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n * @class DisplayObjectContainer \n * @extends DisplayObject\n * @constructor\n */\nPIXI.DisplayObjectContainer = function()\n{\n\tPIXI.DisplayObject.call( this );\n\t\n\t/**\n\t * [read-only] The of children of this container.\n\t *\n\t * @property children\n\t * @type Array<DisplayObject>\n\t * @readOnly\n\t */\t\n\tthis.children = [];\n}\n\n// constructor\nPIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );\nPIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;\n\n//TODO make visible a getter setter\n/*\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'visible', {\n    get: function() {\n        return this._visible;\n    },\n    set: function(value) {\n        this._visible = value;\n        \n    }\n});*/\n\n/**\n * Adds a child to the container.\n *\n * @method addChild\n * @param child {DisplayObject} The DisplayObject to add to the container\n */\nPIXI.DisplayObjectContainer.prototype.addChild = function(child)\n{\n\tif(child.parent != undefined)\n\t{\n\t\t\n\t\t//// COULD BE THIS???\n\t\tchild.parent.removeChild(child);\n\t//\treturn;\n\t}\n\n\tchild.parent = this;\n\t\n\tthis.children.push(child);\t\n\t\n\t// update the stage refference..\n\t\n\tif(this.stage)\n\t{\n\t\tvar tmpChild = child;\n\t\tdo\n\t\t{\n\t\t\tif(tmpChild.interactive)this.stage.dirty = true;\n\t\t\ttmpChild.stage = this.stage;\n\t\t\ttmpChild = tmpChild._iNext;\n\t\t}\t\n\t\twhile(tmpChild)\n\t}\n\t\n\t// LINKED LIST //\n\t\n\t// modify the list..\n\tvar childFirst = child.first\n\tvar childLast = child.last;\n\tvar nextObject;\n\tvar previousObject;\n\t\n\t// this could be wrong if there is a filter??\n\tif(this.filter)\n\t{\n\t\tpreviousObject =  this.last._iPrev;\n\t}\n\telse\n\t{\n\t\tpreviousObject = this.last;\n\t}\n\n\tnextObject = previousObject._iNext;\n\t\n\t// always true in this case\n\t// need to make sure the parents last is updated too\n\tvar updateLast = this;\n\tvar prevLast = previousObject;\n\t\n\twhile(updateLast)\n\t{\n\t\tif(updateLast.last == prevLast)\n\t\t{\n\t\t\tupdateLast.last = child.last;\n\t\t}\n\t\tupdateLast = updateLast.parent;\n\t}\n\t\n\tif(nextObject)\n\t{\n\t\tnextObject._iPrev = childLast;\n\t\tchildLast._iNext = nextObject;\n\t}\n\t\n\tchildFirst._iPrev = previousObject;\n\tpreviousObject._iNext = childFirst;\t\t\n\n\t// need to remove any render groups..\n\tif(this.__renderGroup)\n\t{\n\t\t// being used by a renderTexture.. if it exists then it must be from a render texture;\n\t\tif(child.__renderGroup)child.__renderGroup.removeDisplayObjectAndChildren(child);\n\t\t// add them to the new render group..\n\t\tthis.__renderGroup.addDisplayObjectAndChildren(child);\n\t}\n\t\n}\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @method addChildAt\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n */\nPIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)\n{\n\tif(index >= 0 && index <= this.children.length)\n\t{\n\t\tif(child.parent != undefined)\n\t\t{\n\t\t\tchild.parent.removeChild(child);\n\t\t}\n\t\tchild.parent = this;\n\t\t\n\t\tif(this.stage)\n\t\t{\n\t\t\tvar tmpChild = child;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif(tmpChild.interactive)this.stage.dirty = true;\n\t\t\t\ttmpChild.stage = this.stage;\n\t\t\t\ttmpChild = tmpChild._iNext;\n\t\t\t}\n\t\t\twhile(tmpChild)\n\t\t}\n\t\t\n\t\t// modify the list..\n\t\tvar childFirst = child.first;\n\t\tvar childLast = child.last;\n\t\tvar nextObject;\n\t\tvar previousObject;\n\t\t\n\t\tif(index == this.children.length)\n\t\t{\n\t\t\tpreviousObject =  this.last;\n\t\t\tvar updateLast = this;\n\t\t\tvar prevLast = this.last;\n\t\t\twhile(updateLast)\n\t\t\t{\n\t\t\t\tif(updateLast.last == prevLast)\n\t\t\t\t{\n\t\t\t\t\tupdateLast.last = child.last;\n\t\t\t\t}\n\t\t\t\tupdateLast = updateLast.parent;\n\t\t\t}\n\t\t}\n\t\telse if(index == 0)\n\t\t{\n\t\t\tpreviousObject = this;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpreviousObject = this.children[index-1].last;\n\t\t}\n\t\t\n\t\tnextObject = previousObject._iNext;\n\t\t\n\t\t// always true in this case\n\t\tif(nextObject)\n\t\t{\n\t\t\tnextObject._iPrev = childLast;\n\t\t\tchildLast._iNext = nextObject;\n\t\t}\n\t\t\n\t\tchildFirst._iPrev = previousObject;\n\t\tpreviousObject._iNext = childFirst;\t\t\n\n\t\tthis.children.splice(index, 0, child);\n\t\t// need to remove any render groups..\n\t\tif(this.__renderGroup)\n\t\t{\n\t\t\t// being used by a renderTexture.. if it exists then it must be from a render texture;\n\t\t\tif(child.__renderGroup)child.__renderGroup.removeDisplayObjectAndChildren(child);\n\t\t\t// add them to the new render group..\n\t\t\tthis.__renderGroup.addDisplayObjectAndChildren(child);\n\t\t}\n\t\t\n\t}\n\telse\n\t{\n\t\tthrow new Error(child + \" The index \"+ index +\" supplied is out of bounds \" + this.children.length);\n\t}\n}\n\n/**\n * [NYI] Swaps the depth of 2 displayObjects\n *\n * @method swapChildren\n * @param child {DisplayObject}\n * @param child2 {DisplayObject}\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)\n{\n\t/*\n\t * this funtion needs to be recoded.. \n\t * can be done a lot faster..\n\t */\n\treturn;\n\t\n\t// need to fix this function :/\n\t/*\n\t// TODO I already know this??\n\tvar index = this.children.indexOf( child );\n\tvar index2 = this.children.indexOf( child2 );\n\t\n\tif ( index !== -1 && index2 !== -1 ) \n\t{\n\t\t// cool\n\t\t\n\t\t/*\n\t\tif(this.stage)\n\t\t{\n\t\t\t// this is to satisfy the webGL batching..\n\t\t\t// TODO sure there is a nicer way to achieve this!\n\t\t\tthis.stage.__removeChild(child);\n\t\t\tthis.stage.__removeChild(child2);\n\t\t\t\n\t\t\tthis.stage.__addChild(child);\n\t\t\tthis.stage.__addChild(child2);\n\t\t}\n\t\t\n\t\t// swap the positions..\n\t\tthis.children[index] = child2;\n\t\tthis.children[index2] = child;\n\t\t\n\t}\n\telse\n\t{\n\t\tthrow new Error(child + \" Both the supplied DisplayObjects must be a child of the caller \" + this);\n\t}*/\n}\n\n/**\n * Returns the Child at the specified index\n *\n * @method getChildAt\n * @param index {Number} The index to get the child from\n */\nPIXI.DisplayObjectContainer.prototype.getChildAt = function(index)\n{\n\tif(index >= 0 && index < this.children.length)\n\t{\n\t\treturn this.children[index];\n\t}\n\telse\n\t{\n\t\tthrow new Error(child + \" Both the supplied DisplayObjects must be a child of the caller \" + this);\n\t}\n}\n\n/**\n * Removes a child from the container.\n *\n * @method removeChild\n * @param child {DisplayObject} The DisplayObject to remove\n */\nPIXI.DisplayObjectContainer.prototype.removeChild = function(child)\n{\n\tvar index = this.children.indexOf( child );\n\tif ( index !== -1 ) \n\t{\n\t\t// unlink //\n\t\t// modify the list..\n\t\tvar childFirst = child.first;\n\t\tvar childLast = child.last;\n\t\t\n\t\tvar nextObject = childLast._iNext;\n\t\tvar previousObject = childFirst._iPrev;\n\t\t\t\n\t\tif(nextObject)nextObject._iPrev = previousObject;\n\t\tpreviousObject._iNext = nextObject;\t\t\n\t\t\n\t\tif(this.last == childLast)\n\t\t{\n\t\t\tvar tempLast =  childFirst._iPrev;\t\n\t\t\t// need to make sure the parents last is updated too\n\t\t\tvar updateLast = this;\n\t\t\twhile(updateLast.last == childLast.last)\n\t\t\t{\n\t\t\t\tupdateLast.last = tempLast;\n\t\t\t\tupdateLast = updateLast.parent;\n\t\t\t\tif(!updateLast)break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tchildLast._iNext = null;\n\t\tchildFirst._iPrev = null;\n\t\t \n\t\t// update the stage reference..\n\t\tif(this.stage)\n\t\t{\n\t\t\tvar tmpChild = child;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif(tmpChild.interactive)this.stage.dirty = true;\n\t\t\t\ttmpChild.stage = null;\n\t\t\t\ttmpChild = tmpChild._iNext;\n\t\t\t}\t\n\t\t\twhile(tmpChild)\n\t\t}\n\t\n\t\t// webGL trim\n\t\tif(child.__renderGroup)\n\t\t{\n\t\t\tchild.__renderGroup.removeDisplayObjectAndChildren(child);\n\t\t}\n\t\t\n\t\tchild.parent = undefined;\n\t\tthis.children.splice( index, 1 );\n\t}\n\telse\n\t{\n\t\tthrow new Error(child + \" The supplied DisplayObject must be a child of the caller \" + this);\n\t}\n}\n\n/*\n * Updates the container's children's transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.updateTransform = function()\n{\n\tif(!this.visible)return;\n\t\n\tPIXI.DisplayObject.prototype.updateTransform.call( this );\n\t\n\tfor(var i=0,j=this.children.length; i<j; i++)\n\t{\n\t\tthis.children[i].updateTransform();\t\n\t}\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.blendModes = {};\nPIXI.blendModes.NORMAL = 0;\nPIXI.blendModes.SCREEN = 1;\n\n\n/**\n * The SPrite object is the base for all textured objects that are rendered to the screen\n *\n * @class Sprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture for this sprite\n * @type String\n */\nPIXI.Sprite = function(texture)\n{\n\tPIXI.DisplayObjectContainer.call( this );\n\n\t/**\n\t * The anchor sets the origin point of the texture.\n\t * The default is 0,0 this means the textures origin is the top left \n\t * Setting than anchor to 0.5,0.5 means the textures origin is centered\n\t * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right\n\t *\n     * @property anchor\n     * @type Point\n     */\n\tthis.anchor = new PIXI.Point();\n\n\t/**\n\t * The texture that the sprite is using\n\t *\n\t * @property texture\n\t * @type Texture\n\t */\n\tthis.texture = texture;\n\n\t/**\n\t * The blend mode of sprite.\n\t * currently supports PIXI.blendModes.NORMAL and PIXI.blendModes.SCREEN\n\t *\n\t * @property blendMode\n\t * @type Number\n\t */\n\tthis.blendMode = PIXI.blendModes.NORMAL;\n\n\t/**\n\t * The width of the sprite (this is initially set by the texture)\n\t *\n\t * @property _width\n\t * @type Number\n\t * @private\n\t */\n\tthis._width = 0;\n\n\t/**\n\t * The height of the sprite (this is initially set by the texture)\n\t *\n\t * @property _height\n\t * @type Number\n\t * @private\n\t */\n\tthis._height = 0;\n\n\tif(texture.baseTexture.hasLoaded)\n\t{\n\t\tthis.updateFrame = true;\n\t}\n\telse\n\t{\n\t\tthis.onTextureUpdateBind = this.onTextureUpdate.bind(this);\n\t\tthis.texture.addEventListener( 'update', this.onTextureUpdateBind );\n\t}\n\n\tthis.renderable = true;\n}\n\n// constructor\nPIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Sprite.prototype.constructor = PIXI.Sprite;\n\n/**\n * The width of the sprite, setting this will actually modify the scale to acheive the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.texture.frame.width;\n    },\n    set: function(value) {\n    \tthis.scale.x = value / this.texture.frame.width\n        this._width = value;\n    }\n});\n\n/**\n * The height of the sprite, setting this will actually modify the scale to acheive the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.texture.frame.height;\n    },\n    set: function(value) {\n    \tthis.scale.y = value / this.texture.frame.height\n        this._height = value;\n    }\n});\n\n/**\n * Sets the texture of the sprite\n *\n * @method setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n */\nPIXI.Sprite.prototype.setTexture = function(texture)\n{\n\t// stop current texture;\n\tif(this.texture.baseTexture != texture.baseTexture)\n\t{\n\t\tthis.textureChange = true;\t\n\t\tthis.texture = texture;\n\t\t\n\t\tif(this.__renderGroup)\n\t\t{\n\t\t\tthis.__renderGroup.updateTexture(this);\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.texture = texture;\n\t}\n\t\n\tthis.updateFrame = true;\n}\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Sprite.prototype.onTextureUpdate = function(event)\n{\n\t//this.texture.removeEventListener( 'update', this.onTextureUpdateBind );\n\t\n\t// so if _width is 0 then width was not set..\n\tif(this._width)this.scale.x = this._width / this.texture.frame.width;\n\tif(this._height)this.scale.y = this._height / this.texture.frame.height;\n\t\n\tthis.updateFrame = true;\n}\n\n// some helper functions..\n\n/**\n * \n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @method fromFrame\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId\n */\nPIXI.Sprite.fromFrame = function(frameId)\n{\n\tvar texture = PIXI.TextureCache[frameId];\n\tif(!texture)throw new Error(\"The frameId '\"+ frameId +\"' does not exist in the texture cache\" + this);\n\treturn new PIXI.Sprite(texture);\n}\n\n/**\n * \n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @method fromImage\n * @static\n * @param imageId {String} The image url of the texture\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\nPIXI.Sprite.fromImage = function(imageId)\n{\n\tvar texture = PIXI.Texture.fromImage(imageId);\n\treturn new PIXI.Sprite(texture);\n}\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A MovieClip is a simple way to display an animation depicted by a list of textures.\n *\n * @class MovieClip\n * @extends Sprite\n * @constructor\n * @param textures {Array<Texture>} an array of {Texture} objects that make up the animation\n */\nPIXI.MovieClip = function(textures)\n{\n\tPIXI.Sprite.call(this, textures[0]);\n\t\n\t/**\n\t * The array of textures that make up the animation\n\t *\n\t * @property textures\n\t * @type Array\n\t */\n\tthis.textures = textures;\n\t\n\t/**\n\t * The speed that the MovieClip will play at. Higher is faster, lower is slower\n\t *\n\t * @property animationSpeed\n\t * @type Number\n\t * @default 1\n\t */\n\tthis.animationSpeed = 1;\n\n\t/**\n\t * Whether or not the movie clip repeats after playing.\n\t *\n\t * @property loop\n\t * @type Boolean\n\t * @default true\n\t */\n\tthis.loop = true;\n\n\t/**\n\t * Function to call when a MovieClip finishes playing\n\t *\n\t * @property onComplete\n\t * @type Function\n\t */\n\tthis.onComplete = null;\n\t\n\t/**\n\t * [read-only] The index MovieClips current frame (this may not have to be a whole number)\n\t *\n\t * @property currentFrame\n\t * @type Number\n\t * @default 0\n\t * @readOnly\n\t */\n\tthis.currentFrame = 0; \n\t\n\t/**\n\t * [read-only] Indicates if the MovieClip is currently playing\n\t *\n\t * @property playing\n\t * @type Boolean\n\t * @readOnly\n\t */\n\tthis.playing = false;\n}\n\n// constructor\nPIXI.MovieClip.prototype = Object.create( PIXI.Sprite.prototype );\nPIXI.MovieClip.prototype.constructor = PIXI.MovieClip;\n\n/**\n * Stops the MovieClip\n *\n * @method stop\n */\nPIXI.MovieClip.prototype.stop = function()\n{\n\tthis.playing = false;\n}\n\n/**\n * Plays the MovieClip\n *\n * @method play\n */\nPIXI.MovieClip.prototype.play = function()\n{\n\tthis.playing = true;\n}\n\n/**\n * Stops the MovieClip and goes to a specific frame\n *\n * @method gotoAndStop\n * @param frameNumber {Number} frame index to stop at\n */\nPIXI.MovieClip.prototype.gotoAndStop = function(frameNumber)\n{\n\tthis.playing = false;\n\tthis.currentFrame = frameNumber;\n\tvar round = (this.currentFrame + 0.5) | 0;\n\tthis.setTexture(this.textures[round % this.textures.length]);\n}\n\n/**\n * Goes to a specific frame and begins playing the MovieClip\n *\n * @method gotoAndPlay\n * @param frameNumber {Number} frame index to start at\n */\nPIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber)\n{\n\tthis.currentFrame = frameNumber;\n\tthis.playing = true;\n}\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.MovieClip.prototype.updateTransform = function()\n{\n\tPIXI.Sprite.prototype.updateTransform.call(this);\n\t\n\tif(!this.playing)return;\n\t\n\tthis.currentFrame += this.animationSpeed;\n\t\n\tvar round = (this.currentFrame + 0.5) | 0;\n\t\n\tif(this.loop || round < this.textures.length)\n\t{\n\t\tthis.setTexture(this.textures[round % this.textures.length]);\n\t}\n\telse if(round >= this.textures.length)\n\t{\n\t\tthis.gotoAndStop(this.textures.length - 1);\n\t\tif(this.onComplete)\n\t\t{\n\t\t\tthis.onComplete();\n\t\t}\n\t}\n}\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n\nPIXI.FilterBlock = function(mask)\n{\n\tthis.graphics = mask\n\tthis.visible = true;\n\tthis.renderable = true;\n}\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Text Object will create a line(s) of text to split a line you can use \"\\n\"\n *\n * @class Text\n * @extends Sprite\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param [style] {Object} The style parameters\n * @param [style.font] {String} default \"bold 20pt Arial\" The style and size of the font\n * @param [style.fill=\"black\"] {Object} A canvas fillstyle that will be used on the text eg \"red\", \"#00FF00\"\n * @param [style.align=\"left\"] {String} An alignment of the multiline text (\"left\", \"center\" or \"right\")\n * @param [style.stroke] {String} A canvas fillstyle that will be used on the text stroke eg \"blue\", \"#FCFF00\"\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap\n */\nPIXI.Text = function(text, style)\n{\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\");\n    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));\n\n    this.setText(text);\n    this.setStyle(style);\n    \n    this.updateText();\n    this.dirty = false;\n};\n\n// constructor\nPIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.Text.prototype.constructor = PIXI.Text;\n\n/**\n * Set the style of the text\n *\n * @method setStyle\n * @param [style] {Object} The style parameters\n * @param [style.font=\"bold 20pt Arial\"] {String} The style and size of the font\n * @param [style.fill=\"black\"] {Object} A canvas fillstyle that will be used on the text eg \"red\", \"#00FF00\"\n * @param [style.align=\"left\"] {String} An alignment of the multiline text (\"left\", \"center\" or \"right\")\n * @param [style.stroke=\"black\"] {String} A canvas fillstyle that will be used on the text stroke eg \"blue\", \"#FCFF00\"\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap\n */\nPIXI.Text.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.font = style.font || \"bold 20pt Arial\";\n    style.fill = style.fill || \"black\";\n    style.align = style.align || \"left\";\n    style.stroke = style.stroke || \"black\"; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n    style.strokeThickness = style.strokeThickness || 0;\n    style.wordWrap = style.wordWrap || false;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    this.style = style;\n    this.dirty = true;\n};\n\n/**\n * Set the copy for the text object. To split a line you can use \"\\n\"\n *\n * @methos setText\n * @param {String} text The copy that you would like the text to display\n */\nPIXI.Sprite.prototype.setText = function(text)\n{\n    this.text = text.toString() || \" \";\n    this.dirty = true;\n};\n\n/**\n * Renders text\n *\n * @method updateText\n * @private\n */\nPIXI.Text.prototype.updateText = function()\n{\n\tthis.context.font = this.style.font;\n\t\n\tvar outputText = this.text;\n\t\n\t// word wrap\n\t// preserve original text\n\tif(this.style.wordWrap)outputText = this.wordWrap(this.text);\n\n\t//split text into lines\n\tvar lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n\t//calculate text width\n\tvar lineWidths = [];\n\tvar maxLineWidth = 0;\n\tfor (var i = 0; i < lines.length; i++)\n\t{\n\t\tvar lineWidth = this.context.measureText(lines[i]).width;\n\t\tlineWidths[i] = lineWidth;\n\t\tmaxLineWidth = Math.max(maxLineWidth, lineWidth);\n\t}\n\tthis.canvas.width = maxLineWidth + this.style.strokeThickness;\n\t\n\t//calculate text height\n\tvar lineHeight = this.determineFontHeight(\"font: \" + this.style.font  + \";\") + this.style.strokeThickness;\n\tthis.canvas.height = lineHeight * lines.length;\n\n\t//set canvas text styles\n\tthis.context.fillStyle = this.style.fill;\n\tthis.context.font = this.style.font;\n\t\n\tthis.context.strokeStyle = this.style.stroke;\n\tthis.context.lineWidth = this.style.strokeThickness;\n\n\tthis.context.textBaseline = \"top\";\n\n\t//draw lines line by line\n\tfor (i = 0; i < lines.length; i++)\n\t{\n\t\tvar linePosition = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * lineHeight);\n\t\n\t\tif(this.style.align == \"right\")\n\t\t{\n\t\t\tlinePosition.x += maxLineWidth - lineWidths[i];\n\t\t}\n\t\telse if(this.style.align == \"center\")\n\t\t{\n\t\t\tlinePosition.x += (maxLineWidth - lineWidths[i]) / 2;\n\t\t}\n\n\t\tif(this.style.stroke && this.style.strokeThickness)\n\t\t{\n\t\t\tthis.context.strokeText(lines[i], linePosition.x, linePosition.y);\n\t\t}\n\n\t\tif(this.style.fill)\n\t\t{\n\t\t\tthis.context.fillText(lines[i], linePosition.x, linePosition.y);\n\t\t}\n\t}\n\t\n    this.updateTexture();\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @method updateTexture\n * @private\n */\nPIXI.Text.prototype.updateTexture = function()\n{\n    this.texture.baseTexture.width = this.canvas.width;\n    this.texture.baseTexture.height = this.canvas.height;\n    this.texture.frame.width = this.canvas.width;\n    this.texture.frame.height = this.canvas.height;\n    \n  \tthis._width = this.canvas.width;\n    this._height = this.canvas.height;\n\t\n    PIXI.texturesToUpdate.push(this.texture.baseTexture);\n};\n\n/**\n * Updates the transfor of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.Text.prototype.updateTransform = function()\n{\n\tif(this.dirty)\n\t{\n\t\tthis.updateText();\t\n\t\tthis.dirty = false;\n\t}\n\t\n\tPIXI.Sprite.prototype.updateTransform.call(this);\n};\n\n/*\n * http://stackoverflow.com/users/34441/ellisbben\n * great solution to the problem!\n *\n * @method determineFontHeight\n * @param fontStyle {Object}\n * @private\n */\nPIXI.Text.prototype.determineFontHeight = function(fontStyle) \n{\n\t// build a little reference dictionary so if the font style has been used return a\n\t// cached version...\n\tvar result = PIXI.Text.heightCache[fontStyle];\n\t\n\tif(!result)\n\t{\n\t\tvar body = document.getElementsByTagName(\"body\")[0];\n\t\tvar dummy = document.createElement(\"div\");\n\t\tvar dummyText = document.createTextNode(\"M\");\n\t\tdummy.appendChild(dummyText);\n\t\tdummy.setAttribute(\"style\", fontStyle + ';position:absolute;top:0;left:0');\n\t\tbody.appendChild(dummy);\n\t\t\n\t\tresult = dummy.offsetHeight;\n\t\tPIXI.Text.heightCache[fontStyle] = result;\n\t\t\n\t\tbody.removeChild(dummy);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * A Text Object will apply wordwrap\n *\n * @method wordWrap\n * @param text {String}\n * @private\n */\nPIXI.Text.prototype.wordWrap = function(text)\n{\n\t// search good wrap position\n\tvar searchWrapPos = function(ctx, text, start, end, wrapWidth)\n\t{\n\t\tvar p = Math.floor((end-start) / 2) + start;\n\t\tif(p == start) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif(ctx.measureText(text.substring(0,p)).width <= wrapWidth)\n\t\t{\n\t\t\tif(ctx.measureText(text.substring(0,p+1)).width > wrapWidth)\n\t\t\t{\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn arguments.callee(ctx, text, p, end, wrapWidth);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn arguments.callee(ctx, text, start, p, wrapWidth);\n\t\t}\n\t};\n\t \n\tvar lineWrap = function(ctx, text, wrapWidth)\n\t{\n\t\tif(ctx.measureText(text).width <= wrapWidth || text.length < 1)\n\t\t{\n\t\t\treturn text;\n\t\t}\n\t\tvar pos = searchWrapPos(ctx, text, 0, text.length, wrapWidth);\n\t\treturn text.substring(0, pos) + \"\\n\" + arguments.callee(ctx, text.substring(pos), wrapWidth);\n\t};\n\t\n\tvar result = \"\";\n\tvar lines = text.split(\"\\n\");\n\tfor (var i = 0; i < lines.length; i++)\n\t{\n\t\tresult += lineWrap(this.context, lines[i], this.style.wordWrapWidth) + \"\\n\";\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Destroys this text object\n *\n * @method destroy\n * @param destroyTexture {Boolean}\n */\nPIXI.Text.prototype.destroy = function(destroyTexture)\n{\n\tif(destroyTexture)\n\t{\n\t\tthis.texture.destroy();\n\t}\n\t\t\n};\n\nPIXI.Text.heightCache = {};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Text Object will create a line(s) of text using bitmap font. To split a line you can use \"\\n\", \"\\r\" or \"\\r\\n\"\n * You can generate the fnt files using \n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class BitmapText\n * @extends DisplayObjectContainer\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param style {Object} The style parameters\n * @param style.font {String} The size (optional) and bitmap font id (required) eq \"Arial\" or \"20px Arial\" (must have loaded previously)\n * @param [style.align=\"left\"] {String} An alignment of the multiline text (\"left\", \"center\" or \"right\")\n */\nPIXI.BitmapText = function(text, style)\n{\n    PIXI.DisplayObjectContainer.call(this);\n\n    this.setText(text);\n    this.setStyle(style);\n    this.updateText();\n    this.dirty = false\n\n};\n\n// constructor\nPIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.BitmapText.prototype.constructor = PIXI.BitmapText;\n\n/**\n * Set the copy for the text object\n *\n * @method setText\n * @param text {String} The copy that you would like the text to display\n */\nPIXI.BitmapText.prototype.setText = function(text)\n{\n    this.text = text || \" \";\n    this.dirty = true;\n};\n\n/**\n * Set the style of the text\n *\n * @method setStyle\n * @param style {Object} The style parameters\n * @param style.font {String} The size (optional) and bitmap font id (required) eq \"Arial\" or \"20px Arial\" (must have loaded previously)\n * @param [style.align=\"left\"] {String} An alignment of the multiline text (\"left\", \"center\" or \"right\")\n */\nPIXI.BitmapText.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.align = style.align || \"left\";\n    this.style = style;\n\n    var font = style.font.split(\" \");\n    this.fontName = font[font.length - 1];\n    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;\n\n    this.dirty = true;\n};\n\n/**\n * Renders text\n *\n * @method updateText\n * @private\n */\nPIXI.BitmapText.prototype.updateText = function()\n{\n    var data = PIXI.BitmapText.fonts[this.fontName];\n    var pos = new PIXI.Point();\n    var prevCharCode = null;\n    var chars = [];\n    var maxLineWidth = 0;\n    var lineWidths = [];\n    var line = 0;\n    var scale = this.fontSize / data.size;\n    for(var i = 0; i < this.text.length; i++)\n    {\n        var charCode = this.text.charCodeAt(i);\n        if(/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n        {\n            lineWidths.push(pos.x);\n            maxLineWidth = Math.max(maxLineWidth, pos.x);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n        \n        var charData = data.chars[charCode];\n        if(!charData) continue;\n\n        if(prevCharCode && charData[prevCharCode])\n        {\n           pos.x += charData.kerning[prevCharCode];\n        }\n        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});\n        pos.x += charData.xAdvance;\n\n        prevCharCode = charCode;\n    }\n\n    lineWidths.push(pos.x);\n    maxLineWidth = Math.max(maxLineWidth, pos.x);\n\n    var lineAlignOffsets = [];\n    for(i = 0; i <= line; i++)\n    {\n        var alignOffset = 0;\n        if(this.style.align == \"right\")\n        {\n            alignOffset = maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align == \"center\")\n        {\n            alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n        }\n        lineAlignOffsets.push(alignOffset);\n    }\n\n    for(i = 0; i < chars.length; i++)\n    {\n        var c = new PIXI.Sprite(chars[i].texture)//PIXI.Sprite.fromFrame(chars[i].charCode);\n        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n        c.position.y = chars[i].position.y * scale;\n        c.scale.x = c.scale.y = scale;\n        this.addChild(c);\n    }\n\n    this.width = pos.x * scale;\n    this.height = (pos.y + data.lineHeight) * scale;\n};\n\n/**\n * Updates the transfor of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.BitmapText.prototype.updateTransform = function()\n{\n\tif(this.dirty)\n\t{\n        while(this.children.length > 0)\n        {\n            this.removeChild(this.getChildAt(0));\n        }\n        this.updateText();\n\n        this.dirty = false;\n\t}\n\t\n\tPIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\nPIXI.BitmapText.fonts = {};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n\n/**\n * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive\n * This manager also supports multitouch.\n *\n * @class InteractionManager\n * @constructor\n * @param stage {Stage} The stage to handle interactions\n */\nPIXI.InteractionManager = function(stage)\n{\n\t/**\n\t * a refference to the stage\n\t *\n\t * @property stage\n\t * @type Stage\n\t */\n\tthis.stage = stage;\n\n\t/**\n\t * the mouse data\n\t *\n\t * @property mouse\n\t * @type InteractionData\n\t */\n\tthis.mouse = new PIXI.InteractionData();\n\n\t/**\n\t * an object that stores current touches (InteractionData) by id reference\n\t *\n\t * @property touchs\n\t * @type Object\n\t */\n\tthis.touchs = {};\n\n\n\t\n\t// helpers\n\tthis.tempPoint = new PIXI.Point();\n\t//this.tempMatrix =  mat3.create();\n\n\tthis.mouseoverEnabled = true;\n\n\t//tiny little interactiveData pool!\n\tthis.pool = [];\n\n\tthis.interactiveItems = [];\n\t\n\t\n\tthis.last = 0;\n}\n\n// constructor\nPIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;\n\n/**\n * Collects an interactive sprite recursively to have their interactions managed\n *\n * @method collectInteractiveSprite\n * @param displayObject {DisplayObject} the displayObject to collect\n * @param iParent {DisplayObject}\n * @private\n */\nPIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent)\n{\n\tvar children = displayObject.children;\n\tvar length = children.length;\n\t\n\t/// make an interaction tree... {item.__interactiveParent}\n\tfor (var i = length-1; i >= 0; i--)\n\t{\n\t\tvar child = children[i];\n\t\t\n//\t\tif(child.visible) {\n\t\t\t// push all interactive bits\n\t\t\tif(child.interactive)\n\t\t\t{\n\t\t\t\tiParent.interactiveChildren = true;\n\t\t\t\t//child.__iParent = iParent;\n\t\t\t\tthis.interactiveItems.push(child);\n\n\t\t\t\tif(child.children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.collectInteractiveSprite(child, child);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild.__iParent = null;\n\n\t\t\t\tif(child.children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.collectInteractiveSprite(child, iParent);\n\t\t\t\t}\n\t\t\t}\n//\t\t}\n\t}\n}\n\n/**\n * Sets the target for event delegation\n *\n * @method setTarget\n * @param target {WebGLRenderer|CanvasRenderer} the renderer to bind events to\n * @private\n */\nPIXI.InteractionManager.prototype.setTarget = function(target)\n{\n\tif (window.navigator.msPointerEnabled) \n\t{\n\t\t// time to remove some of that zoom in ja..\n\t\ttarget.view.style[\"-ms-content-zooming\"] = \"none\";\n    \ttarget.view.style[\"-ms-touch-action\"] = \"none\"\n    \n\t\t// DO some window specific touch!\n\t}\n\t\n\tthis.target = target;\n\ttarget.view.addEventListener('mousemove',  this.onMouseMove.bind(this), true);\n\ttarget.view.addEventListener('mousedown',  this.onMouseDown.bind(this), true);\n \tdocument.body.addEventListener('mouseup',  this.onMouseUp.bind(this), true);\n \ttarget.view.addEventListener('mouseout',   this.onMouseOut.bind(this), true);\n\t\n\t// aint no multi touch just yet!\n\ttarget.view.addEventListener(\"touchstart\", this.onTouchStart.bind(this), true);\n\ttarget.view.addEventListener(\"touchend\", this.onTouchEnd.bind(this), true);\n\ttarget.view.addEventListener(\"touchmove\", this.onTouchMove.bind(this), true);\n}\n\n/**\n * updates the state of interactive objects\n *\n * @method update\n * @private\n */\nPIXI.InteractionManager.prototype.update = function()\n{\n\tif(!this.target)return;\n\t\n\t// frequency of 30fps??\n\tvar now = Date.now();\n\tvar diff = now - this.last;\n\tdiff = (diff * 30) / 1000;\n\tif(diff < 1)return;\n\tthis.last = now;\n\t//\n\t\n\t// ok.. so mouse events??\n\t// yes for now :)\n\t// OPTIMSE - how often to check??\n\tif(this.dirty)\n\t{\n\t\tthis.dirty = false;\n\t\t\n\t\tvar len = this.interactiveItems.length;\n\t\t\n\t\tfor (var i=0; i < len; i++) {\n\t\t  this.interactiveItems[i].interactiveChildren = false;\n\t\t}\n\t\t\n\t\tthis.interactiveItems = [];\n\t\t\n\t\tif(this.stage.interactive)this.interactiveItems.push(this.stage);\n\t\t// go through and collect all the objects that are interactive..\n\t\tthis.collectInteractiveSprite(this.stage, this.stage);\n\t}\n\t\n\t// loop through interactive objects!\n\tvar length = this.interactiveItems.length;\n\t\n\tthis.target.view.style.cursor = \"default\";\t\n\t\t\t\t\n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar item = this.interactiveItems[i];\n\t\t\n\t\t\n\t\t//if(!item.visible)continue;\n\t\t\n\t\t// OPTIMISATION - only calculate every time if the mousemove function exists..\n\t\t// OK so.. does the object have any other interactive functions?\n\t\t// hit-test the clip!\n\t\t\n\t\t\n\t\tif(item.mouseover || item.mouseout || item.buttonMode)\n\t\t{\n\t\t\t// ok so there are some functions so lets hit test it..\n\t\t\titem.__hit = this.hitTest(item, this.mouse);\n\t\t\tthis.mouse.target = item;\n\t\t\t// ok so deal with interactions..\n\t\t\t// loks like there was a hit!\n\t\t\tif(item.__hit)\n\t\t\t{\n\t\t\t\tif(item.buttonMode)this.target.view.style.cursor = \"pointer\";\t\n\t\t\t\t\n\t\t\t\tif(!item.__isOver)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(item.mouseover)item.mouseover(this.mouse);\n\t\t\t\t\titem.__isOver = true;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(item.__isOver)\n\t\t\t\t{\n\t\t\t\t\t// roll out!\n\t\t\t\t\tif(item.mouseout)item.mouseout(this.mouse);\n\t\t\t\t\titem.__isOver = false;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// --->\n\t}\n}\n\n/**\n * Is called when the mouse moves accross the renderer element\n *\n * @method onMouseMove\n * @param event {Event} The DOM event of the mouse moving\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseMove = function(event)\n{\n\tthis.mouse.originalEvent = event || window.event; //IE uses window.event\n\t// TODO optimize by not check EVERY TIME! maybe half as often? //\n\tvar rect = this.target.view.getBoundingClientRect();\n\t\n\tthis.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width);\n\tthis.mouse.global.y = (event.clientY - rect.top) * ( this.target.height / rect.height);\n\t\n\tvar length = this.interactiveItems.length;\n\tvar global = this.mouse.global;\n\t\n\t\n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar item = this.interactiveItems[i];\n\t\t\n\t\tif(item.mousemove)\n\t\t{\n\t\t\t//call the function!\n\t\t\titem.mousemove(this.mouse);\n\t\t}\n\t}\n}\n\n/**\n * Is called when the mouse button is pressed down on the renderer element\n *\n * @method onMouseDown\n * @param event {Event} The DOM event of a mouse button being pressed down\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseDown = function(event)\n{\n\tthis.mouse.originalEvent = event || window.event; //IE uses window.event\n\t\n\t// loop through inteaction tree...\n\t// hit test each item! -> \n\t// get interactive items under point??\n\t//stage.__i\n\tvar length = this.interactiveItems.length;\n\tvar global = this.mouse.global;\n\t\n\tvar index = 0;\n\tvar parent = this.stage;\n\t\n\t// while \n\t// hit test \n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar item = this.interactiveItems[i];\n\t\t\n\t\tif(item.mousedown || item.click)\n\t\t{\n\t\t\titem.__mouseIsDown = true;\n\t\t\titem.__hit = this.hitTest(item, this.mouse);\n\t\t\t\n\t\t\tif(item.__hit)\n\t\t\t{\n\t\t\t\t//call the function!\n\t\t\t\tif(item.mousedown)item.mousedown(this.mouse);\n\t\t\t\titem.__isDown = true;\n\t\t\t\t\n\t\t\t\t// just the one!\n\t\t\t\tif(!item.interactiveChildren)break;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nPIXI.InteractionManager.prototype.onMouseOut = function(event)\n{\n\tvar length = this.interactiveItems.length;\n\t\n\tthis.target.view.style.cursor = \"default\";\t\n\t\t\t\t\n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar item = this.interactiveItems[i];\n\t\t\n\t\tif(item.__isOver)\n\t\t{\n\t\t\tthis.mouse.target = item;\n\t\t\tif(item.mouseout)item.mouseout(this.mouse);\n\t\t\titem.__isOver = false;\t\n\t\t}\n\t}\n}\n\n/**\n * Is called when the mouse button is released on the renderer element\n *\n * @method onMouseUp\n * @param event {Event} The DOM event of a mouse button being released\n * @private\n */\nPIXI.InteractionManager.prototype.onMouseUp = function(event)\n{\n\tthis.mouse.originalEvent = event || window.event; //IE uses window.event\n\t\n\tvar global = this.mouse.global;\n\t\n\t\n\tvar length = this.interactiveItems.length;\n\tvar up = false;\n\t\n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar item = this.interactiveItems[i];\n\t\t\n\t\tif(item.mouseup || item.mouseupoutside || item.click)\n\t\t{\n\t\t\titem.__hit = this.hitTest(item, this.mouse);\n\t\t\t\n\t\t\tif(item.__hit && !up)\n\t\t\t{\n\t\t\t\t//call the function!\n\t\t\t\tif(item.mouseup)\n\t\t\t\t{\n\t\t\t\t\titem.mouseup(this.mouse);\n\t\t\t\t}\n\t\t\t\tif(item.__isDown)\n\t\t\t\t{\n\t\t\t\t\tif(item.click)item.click(this.mouse);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!item.interactiveChildren)up = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(item.__isDown)\n\t\t\t\t{\n\t\t\t\t\tif(item.mouseupoutside)item.mouseupoutside(this.mouse);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\titem.__isDown = false;\t\n\t\t}\n\t}\n}\n\n/**\n * Tests if the current mouse coords hit a sprite\n *\n * @method hitTest\n * @param item {DisplayObject} The displayObject to test for a hit\n * @param interactionData {InteractionData} The interactiondata object to update in the case of a hit\n * @private\n */\nPIXI.InteractionManager.prototype.hitTest = function(item, interactionData)\n{\n\tvar global = interactionData.global;\n\t\n\tif(item.vcount !== PIXI.visibleCount)return false;\n\n\tvar isSprite = (item instanceof PIXI.Sprite),\n\t\tworldTransform = item.worldTransform,\n\t\ta00 = worldTransform[0], a01 = worldTransform[1], a02 = worldTransform[2],\n\t\ta10 = worldTransform[3], a11 = worldTransform[4], a12 = worldTransform[5],\n\t\tid = 1 / (a00 * a11 + a01 * -a10),\n\t\tx = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,\n\t\ty = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;\n\n\tinteractionData.target = item;\n\t\n\t//a sprite or display object with a hit area defined\n\tif(item.hitArea && item.hitArea.contains) {\n\t\tif(item.hitArea.contains(x, y)) {\n\t\t\t//if(isSprite)\n\t\t\tinteractionData.target = item;\n\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t// a sprite with no hitarea defined\n\telse if(isSprite)\n\t{\n\t\tvar width = item.texture.frame.width,\n\t\t\theight = item.texture.frame.height,\n\t\t\tx1 = -width * item.anchor.x,\n\t\t\ty1;\n\t\t\n\t\tif(x > x1 && x < x1 + width)\n\t\t{\n\t\t\ty1 = -height * item.anchor.y;\n\t\t\n\t\t\tif(y > y1 && y < y1 + height)\n\t\t\t{\n\t\t\t\t// set the target property if a hit is true!\n\t\t\t\tinteractionData.target = item\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar length = item.children.length;\n\t\n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar tempItem = item.children[i];\n\t\tvar hit = this.hitTest(tempItem, interactionData);\n\t\tif(hit)\n\t\t{\n\t\t\t// hmm.. TODO SET CORRECT TARGET?\n\t\t\tinteractionData.target = item\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\t\n}\n\n/**\n * Is called when a touch is moved accross the renderer element\n *\n * @method onTouchMove\n * @param event {Event} The DOM event of a touch moving accross the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchMove = function(event)\n{\n\tvar rect = this.target.view.getBoundingClientRect();\n\tvar changedTouches = event.changedTouches;\n\t\n\tfor (var i=0; i < changedTouches.length; i++) \n\t{\n\t\tvar touchEvent = changedTouches[i];\n\t\tvar touchData = this.touchs[touchEvent.identifier];\n\t\ttouchData.originalEvent =  event || window.event;\n\t\t\n\t\t// update the touch position\n\t\ttouchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);\n\t\ttouchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);\n\t}\n\t\n\tvar length = this.interactiveItems.length;\n\tfor (var i = 0; i < length; i++)\n\t{\n\t\tvar item = this.interactiveItems[i];\n\t\tif(item.touchmove)item.touchmove(touchData);\n\t}\n}\n\n/**\n * Is called when a touch is started on the renderer element\n *\n * @method onTouchStart\n * @param event {Event} The DOM event of a touch starting on the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchStart = function(event)\n{\n\tvar rect = this.target.view.getBoundingClientRect();\n\t\n\tvar changedTouches = event.changedTouches;\n\tfor (var i=0; i < changedTouches.length; i++) \n\t{\n\t\tvar touchEvent = changedTouches[i];\n\t\t\n\t\tvar touchData = this.pool.pop();\n\t\tif(!touchData)touchData = new PIXI.InteractionData();\n\t\t\n\t\ttouchData.originalEvent =  event || window.event;\n\t\t\n\t\tthis.touchs[touchEvent.identifier] = touchData;\n\t\ttouchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);\n\t\ttouchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);\n\t\t\n\t\tvar length = this.interactiveItems.length;\n\t\t\n\t\tfor (var j = 0; j < length; j++)\n\t\t{\n\t\t\tvar item = this.interactiveItems[j];\n\t\t\t\n\t\t\tif(item.touchstart || item.tap)\n\t\t\t{\n\t\t\t\titem.__hit = this.hitTest(item, touchData);\n\t\t\t\t\n\t\t\t\tif(item.__hit)\n\t\t\t\t{\n\t\t\t\t\t//call the function!\n\t\t\t\t\tif(item.touchstart)item.touchstart(touchData);\n\t\t\t\t\titem.__isDown = true;\n\t\t\t\t\titem.__touchData = touchData;\n\t\t\t\t\t\n\t\t\t\t\tif(!item.interactiveChildren)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Is called when a touch is ended on the renderer element\n *\n * @method onTouchEnd\n * @param event {Event} The DOM event of a touch ending on the renderer view\n * @private\n */\nPIXI.InteractionManager.prototype.onTouchEnd = function(event)\n{\n\t//this.mouse.originalEvent = event || window.event; //IE uses window.event\n\tvar rect = this.target.view.getBoundingClientRect();\n\tvar changedTouches = event.changedTouches;\n\t\n\tfor (var i=0; i < changedTouches.length; i++) \n\t{\n\t\tvar touchEvent = changedTouches[i];\n\t\tvar touchData = this.touchs[touchEvent.identifier];\n\t\tvar up = false;\n\t\ttouchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);\n\t\ttouchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);\n\t\t\n\t\tvar length = this.interactiveItems.length;\n\t\tfor (var j = 0; j < length; j++)\n\t\t{\n\t\t\tvar item = this.interactiveItems[j];\n\t\t\tvar itemTouchData = item.__touchData; // <-- Here!\n\t\t\titem.__hit = this.hitTest(item, touchData);\n\t\t\n\t\t\tif(itemTouchData == touchData)\n\t\t\t{\n\t\t\t\t// so this one WAS down...\n\t\t\t\ttouchData.originalEvent =  event || window.event;\n\t\t\t\t// hitTest??\n\t\t\t\t\n\t\t\t\tif(item.touchend || item.tap)\n\t\t\t\t{\n\t\t\t\t\tif(item.__hit && !up)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(item.touchend)item.touchend(touchData);\n\t\t\t\t\t\tif(item.__isDown)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(item.tap)item.tap(touchData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!item.interactiveChildren)up = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(item.__isDown)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(item.touchendoutside)item.touchendoutside(touchData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\titem.__isDown = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.__touchData = null;\n\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t// remove the touch..\n\t\tthis.pool.push(touchData);\n\t\tthis.touchs[touchEvent.identifier] = null;\n\t}\n}\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class InteractionData\n * @constructor\n */\nPIXI.InteractionData = function()\n{\n\t/**\n\t * This point stores the global coords of where the touch/mouse event happened\n\t *\n\t * @property global \n\t * @type Point\n\t */\n\tthis.global = new PIXI.Point();\n\t\n\t// this is here for legacy... but will remove\n\tthis.local = new PIXI.Point();\n\n\t/**\n\t * The target Sprite that was interacted with\n\t *\n\t * @property target\n\t * @type Sprite\n\t */\n\tthis.target;\n\n\t/**\n\t * When passed to an event handler, this will be the original DOM Event that was captured\n\t *\n\t * @property originalEvent\n\t * @type Event\n\t */\n\tthis.originalEvent;\n}\n\n/**\n * This will return the local coords of the specified displayObject for this InteractionData\n *\n * @method getLocalPosition\n * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off\n * @return {Point} A point containing the coords of the InteractionData position relative to the DisplayObject\n */\nPIXI.InteractionData.prototype.getLocalPosition = function(displayObject)\n{\n\tvar worldTransform = displayObject.worldTransform;\n\tvar global = this.global;\n\t\n\t// do a cheeky transform to get the mouse coords;\n\tvar a00 = worldTransform[0], a01 = worldTransform[1], a02 = worldTransform[2],\n        a10 = worldTransform[3], a11 = worldTransform[4], a12 = worldTransform[5],\n        id = 1 / (a00 * a11 + a01 * -a10);\n\t// set the mouse coords...\n\treturn new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,\n\t\t\t\t\t\t\t   a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id)\n}\n\n// constructor\nPIXI.InteractionData.prototype.constructor = PIXI.InteractionData;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Stage represents the root of the display tree. Everything connected to the stage is rendered\n *\n * @class Stage\n * @extends DisplayObjectContainer\n * @constructor\n * @param backgroundColor {Number} the background color of the stage, easiest way to pass this in is in hex format\n *\t\tlike: 0xFFFFFF for white\n * @param interactive {Boolean} enable / disable interaction (default is false)\n */\nPIXI.Stage = function(backgroundColor, interactive)\n{\n\tPIXI.DisplayObjectContainer.call( this );\n\n\t/**\n\t * [read-only] Current transform of the object based on world (parent) factors\n\t *\n\t * @property worldTransform\n\t * @type Mat3\n\t * @readOnly\n\t * @private\n\t */\n\tthis.worldTransform = PIXI.mat3.create();\n\n\t/**\n\t * Whether or not the stage is interactive\n\t *\n\t * @property interactive\n\t * @type Boolean\n\t */\n\tthis.interactive = interactive;\n\n\t/**\n\t * The interaction manage for this stage, manages all interactive activity on the stage\n\t *\n\t * @property interactive\n\t * @type InteractionManager\n\t */\n\tthis.interactionManager = new PIXI.InteractionManager(this);\n\n\t/**\n\t * Whether the stage is dirty and needs to have interactions updated\n\t *\n\t * @property dirty\n\t * @type Boolean\n\t * @private\n\t */\n\tthis.dirty = true;\n\n\tthis.__childrenAdded = [];\n\tthis.__childrenRemoved = [];\n\n\t//the stage is it's own stage\n\tthis.stage = this;\n\n\t//optimize hit detection a bit\n\tthis.stage.hitArea = new PIXI.Rectangle(0,0,100000, 100000);\n\n\tthis.setBackgroundColor(backgroundColor);\n\tthis.worldVisible = true;\n}\n\n// constructor\nPIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Stage.prototype.constructor = PIXI.Stage;\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Stage.prototype.updateTransform = function()\n{\n\tthis.worldAlpha = 1;\t\t\n\tthis.vcount = PIXI.visibleCount;\n\t\n\tfor(var i=0,j=this.children.length; i<j; i++)\n\t{\n\t\tthis.children[i].updateTransform();\t\n\t}\n\t\n\tif(this.dirty)\n\t{\n\t\tthis.dirty = false;\n\t\t// update interactive!\n\t\tthis.interactionManager.dirty = true;\n\t}\n\t\n\t\n\tif(this.interactive)this.interactionManager.update();\n}\n\n/**\n * Sets the background color for the stage\n *\n * @method setBackgroundColor\n * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format\n *\t\tlike: 0xFFFFFF for white\n */\nPIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)\n{\n\tthis.backgroundColor = backgroundColor || 0x000000;\n\tthis.backgroundColorSplit = HEXtoRGB(this.backgroundColor);\n\tvar hex = this.backgroundColor.toString(16);\n\thex = \"000000\".substr(0, 6 - hex.length) + hex;\n\tthis.backgroundColorString = \"#\" + hex;\n}\n\n/**\n * This will return the point containing global coords of the mouse.\n *\n * @method getMousePosition\n * @return {Point} The point containing the coords of the global InteractionData position.\n */\nPIXI.Stage.prototype.getMousePosition = function()\n{\n\treturn this.interactionManager.mouse.global;\n}\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n/**\n * A polyfill for requestAnimationFrame\n *\n * @method requestAnimationFrame\n */\n/**\n * A polyfill for cancelAnimationFrame\n *\n * @method cancelAnimationFrame\n */\nvar lastTime = 0;\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] \n                               || window[vendors[x]+'CancelRequestAnimationFrame'];\n}\n\nif (!window.requestAnimationFrame)\n    window.requestAnimationFrame = function(callback, element) {\n        var currTime = new Date().getTime();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n          timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n\nif (!window.cancelAnimationFrame)\n    window.cancelAnimationFrame = function(id) {\n        clearTimeout(id);\n    };\n\nwindow.requestAnimFrame = window.requestAnimationFrame;\n\n/**\n * Converts a hex color number to an [R, G, B] array\n *\n * @method HEXtoRGB\n * @param hex {Number}\n */\nfunction HEXtoRGB(hex) {\n\treturn [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];\n}\n\n/**\n * A polyfill for Function.prototype.bind\n *\n * @method bind\n */\nif (typeof Function.prototype.bind != 'function') {\n  Function.prototype.bind = (function () {\n    var slice = Array.prototype.slice;\n    return function (thisArg) {\n      var target = this, boundArgs = slice.call(arguments, 1);\n \n      if (typeof target != 'function') throw new TypeError();\n \n      function bound() {\n\tvar args = boundArgs.concat(slice.call(arguments));\n\ttarget.apply(this instanceof bound ? this : thisArg, args);\n      }\n \n      bound.prototype = (function F(proto) {\n          proto && (F.prototype = proto);\n          if (!(this instanceof F)) return new F;          \n\t})(target.prototype);\n \n      return bound;\n    };\n  })();\n}\n\n/**\n * A wrapper for ajax requests to be handled cross browser\n *\n * @class AjaxRequest\n * @constructor\n */\nvar AjaxRequest = PIXI.AjaxRequest = function()\n{\n\tvar activexmodes = [\"Msxml2.XMLHTTP\", \"Microsoft.XMLHTTP\"] //activeX versions to check for in IE\n\t\n\tif (window.ActiveXObject)\n\t{ //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)\n\t\tfor (var i=0; i<activexmodes.length; i++)\n\t\t{\n\t\t\ttry{\n\t\t\t\treturn new ActiveXObject(activexmodes[i])\n\t\t\t}\n   \t\t\tcatch(e){\n    \t\t\t//suppress error\n   \t\t\t}\n\t\t}\n\t}\n\telse if (window.XMLHttpRequest) // if Mozilla, Safari etc\n  \t{\n  \t\treturn new XMLHttpRequest()\n \t}\n \telse\n \t{\n\t\treturn false;\n \t}\n}\n\n/*\n * DEBUGGING ONLY\n */\nPIXI.runList = function(item)\n{\n\tconsole.log(\">>>>>>>>>\")\n\tconsole.log(\"_\")\n\tvar safe = 0;\n\tvar tmp = item.first;\n\tconsole.log(tmp);\n\t\n\twhile(tmp._iNext)\n\t{\n\t\tsafe++;\n\t\ttmp = tmp._iNext;\n\t\tconsole.log(tmp);\n\t//\tconsole.log(tmp);\n\t\n\t\tif(safe > 100)\n\t\t{\n\t\t\tconsole.log(\"BREAK\")\n\t\t\tbreak\n\t\t}\n\t}\t\n}\n\n\n\n\n\n\n/**\n * https://github.com/mrdoob/eventtarget.js/\n * THankS mr DOob!\n */\n\n/**\n * Adds event emitter functionality to a class\n *\n * @class EventTarget\n * @example\n *\t\tfunction MyEmitter() {\n *\t\t\tPIXI.EventTarget.call(this); //mixes in event target stuff\n *\t\t}\n *\n *\t\tvar em = new MyEmitter();\n *\t\tem.emit({ type: 'eventName', data: 'some data' });\n */\nPIXI.EventTarget = function () {\n\n\tvar listeners = {};\n\t\n\tthis.addEventListener = this.on = function ( type, listener ) {\n\t\t\n\t\t\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\t\t\t\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\t\t}\n\n\t};\n\n\tthis.dispatchEvent = this.emit = function ( event ) {\n\t\t\n\t\tfor ( var listener in listeners[ event.type ] ) {\n\n\t\t\tlisteners[ event.type ][ listener ]( event );\n\t\t\t\n\t\t}\n\n\t};\n\n\tthis.removeEventListener = this.off = function ( type, listener ) {\n\n\t\tvar index = listeners[ type ].indexOf( listener );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tlisteners[ type ].splice( index, 1 );\n\n\t\t}\n\n\t};\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This helper function will automatically detect which renderer you should be using.\n * WebGL is the preferred renderer as it is a lot fastest. If webGL is not supported by\n * the browser then this function will return a canvas renderer\n *\n * @method autoDetectRenderer\n * @static\n * @param width {Number} the width of the renderers view\n * @param height {Number} the height of the renderers view\n * @param view {Canvas} the canvas to use as a view, optional\n * @param transparent=false {Boolean} the transparency of the render view, default false\n * @param antialias=false {Boolean} sets antialias (only applicable in webGL chrome at the moment)\n * \n * antialias\n */\nPIXI.autoDetectRenderer = function(width, height, view, transparent, antialias)\n{\n\tif(!width)width = 800;\n\tif(!height)height = 600;\n\n\t// BORROWED from Mr Doob (mrdoob.com)\n\tvar webgl = ( function () { try { return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )();\n\t\n\t// TEMP FIX\n\tif(webgl)\n\t{\n\t\tvar ie =  (navigator.userAgent.toLowerCase().indexOf('msie') != -1);\n\t\t webgl = !ie;\n\t}\n\t//console.log(webgl);\n\tif( webgl )\n\t{\n\t\treturn new PIXI.WebGLRenderer(width, height, view, transparent, antialias);\n\t}\n\n\treturn\tnew PIXI.CanvasRenderer(width, height, view, transparent);\n};\n\n\n\n/*\n\tPolyK library\n\turl: http://polyk.ivank.net\n\tReleased under MIT licence.\n\t\n\tCopyright (c) 2012 Ivan Kuckir\n\n\tPermission is hereby granted, free of charge, to any person\n\tobtaining a copy of this software and associated documentation\n\tfiles (the \"Software\"), to deal in the Software without\n\trestriction, including without limitation the rights to use,\n\tcopy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the\n\tSoftware is furnished to do so, subject to the following\n\tconditions:\n\n\tThe above copyright notice and this permission notice shall be\n\tincluded in all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\tOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\tNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\tHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\tWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\tFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\tOTHER DEALINGS IN THE SOFTWARE.\n\n\tThis is an amazing lib! \n\t\n\tslightly modified by mat groves (matgroves.com);\n*/\n\nPIXI.PolyK = {};\n\n/**\n * Triangulates shapes for webGL graphic fills\n *\n * @method Triangulate\n * @namespace PolyK\n * @constructor\n */\nPIXI.PolyK.Triangulate = function(p)\n{\n\tvar sign = true;\n\t\n\tvar n = p.length>>1;\n\tif(n<3) return [];\n\tvar tgs = [];\n\tvar avl = [];\n\tfor(var i=0; i<n; i++) avl.push(i);\n\t\n\tvar i = 0;\n\tvar al = n;\n\twhile(al > 3)\n\t{\n\t\tvar i0 = avl[(i+0)%al];\n\t\tvar i1 = avl[(i+1)%al];\n\t\tvar i2 = avl[(i+2)%al];\n\t\t\n\t\tvar ax = p[2*i0],  ay = p[2*i0+1];\n\t\tvar bx = p[2*i1],  by = p[2*i1+1];\n\t\tvar cx = p[2*i2],  cy = p[2*i2+1];\n\t\t\n\t\tvar earFound = false;\n\t\tif(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))\n\t\t{\n\t\t\tearFound = true;\n\t\t\tfor(var j=0; j<al; j++)\n\t\t\t{\n\t\t\t\tvar vi = avl[j];\n\t\t\t\tif(vi==i0 || vi==i1 || vi==i2) continue;\n\t\t\t\tif(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}\n\t\t\t}\n\t\t}\n\t\tif(earFound)\n\t\t{\n\t\t\ttgs.push(i0, i1, i2);\n\t\t\tavl.splice((i+1)%al, 1);\n\t\t\tal--;\n\t\t\ti = 0;\n\t\t}\n\t\telse if(i++ > 3*al) \n\t\t{\n\t\t\t// need to flip flip reverse it!\n\t\t\t// reset!\n\t\t\tif(sign)\n\t\t\t{\n\t\t\t\tvar tgs = [];\n\t\t\t\tavl = [];\n\t\t\t\tfor(var i=0; i<n; i++) avl.push(i);\n\t\t\t\t\n\t\t\t\ti = 0;\n\t\t\t\tal = n;\n\t\t\t\t\n\t\t\t\tsign = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole.log(\"PIXI Warning: shape too complex to fill\")\n\t\t\t\treturn [];\n\t\t\t}\t\t\t\t\n\t\t}\n\t}\n\ttgs.push(avl[0], avl[1], avl[2]);\n\treturn tgs;\n}\n\n/**\n * Checks if a point is within a triangle\n *\n * @class _PointInTriangle\n * @namespace PolyK\n * @private\n */\nPIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n{\n\tvar v0x = cx-ax;\n\tvar v0y = cy-ay;\n\tvar v1x = bx-ax;\n\tvar v1y = by-ay;\n\tvar v2x = px-ax;\n\tvar v2y = py-ay;\n\t\n\tvar dot00 = v0x*v0x+v0y*v0y;\n\tvar dot01 = v0x*v1x+v0y*v1y;\n\tvar dot02 = v0x*v2x+v0y*v2y;\n\tvar dot11 = v1x*v1x+v1y*v1y;\n\tvar dot12 = v1x*v2x+v1y*v2y;\n\t\n\tvar invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n\tvar u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tvar v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n\t// Check if point is in triangle\n\treturn (u >= 0) && (v >= 0) && (u + v < 1);\n}\n\n/**\n * Checks if a shape is convex\n *\n * @class _convex\n * @namespace PolyK\n * @private\n */\nPIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)\n{\n\treturn ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) == sign;\n}\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/*\n * the default suoer fast shader!\n */\n\nPIXI.shaderFragmentSrc = [\n  \"precision mediump float;\",\n  \"varying vec2 vTextureCoord;\",\n  \"varying float vColor;\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void) {\",\n    \"gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\",\n    \"gl_FragColor = gl_FragColor * vColor;\",\n  \"}\"\n];\n\nPIXI.shaderVertexSrc = [\n  \"attribute vec2 aVertexPosition;\",\n  \"attribute vec2 aTextureCoord;\",\n  \"attribute float aColor;\",\n  //\"uniform mat4 uMVMatrix;\",\n  \n  \"uniform vec2 projectionVector;\",\n  \"varying vec2 vTextureCoord;\",\n  \"varying float vColor;\",\n  \"void main(void) {\",\n   // \"gl_Position = uMVMatrix * vec4(aVertexPosition, 1.0, 1.0);\",\n    \"gl_Position = vec4( aVertexPosition.x / projectionVector.x -1.0, aVertexPosition.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",\n    \"vTextureCoord = aTextureCoord;\",\n    \"vColor = aColor;\",\n  \"}\"\n];\n\n/*\n * the triangle strip shader..\n */\n\nPIXI.stripShaderFragmentSrc = [\n  \"precision mediump float;\",\n  \"varying vec2 vTextureCoord;\",\n  \"varying float vColor;\",\n  \"uniform float alpha;\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void) {\",\n    \"gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\",\n    \"gl_FragColor = gl_FragColor * alpha;\",\n  \"}\"\n];\n\n\nPIXI.stripShaderVertexSrc = [\n  \"attribute vec2 aVertexPosition;\",\n  \"attribute vec2 aTextureCoord;\",\n  \"attribute float aColor;\",\n  \"uniform mat3 translationMatrix;\",\n  \"uniform vec2 projectionVector;\",\n  \"varying vec2 vTextureCoord;\",\n  \"varying float vColor;\",\n  \"void main(void) {\",\n\t\"vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);\",\n    \"gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",\n    \"vTextureCoord = aTextureCoord;\",\n    \"vColor = aColor;\",\n  \"}\"\n];\n\n\n/*\n * primitive shader..\n */\n\nPIXI.primitiveShaderFragmentSrc = [\n  \"precision mediump float;\",\n  \"varying vec4 vColor;\",\n  \"void main(void) {\",\n    \"gl_FragColor = vColor;\",\n  \"}\"\n];\n\nPIXI.primitiveShaderVertexSrc = [\n  \"attribute vec2 aVertexPosition;\",\n  \"attribute vec4 aColor;\",\n  \"uniform mat3 translationMatrix;\",\n  \"uniform vec2 projectionVector;\",\n  \"uniform float alpha;\",\n  \"varying vec4 vColor;\",\n  \"void main(void) {\",\n  \t\"vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);\",\n    \"gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",\n    \"vColor = aColor  * alpha;\",\n  \"}\"\n];\n\nPIXI.initPrimitiveShader = function() \n{\n\tvar gl = PIXI.gl;\n\n\tvar shaderProgram = PIXI.compileProgram(PIXI.primitiveShaderVertexSrc, PIXI.primitiveShaderFragmentSrc)\n\t\n    gl.useProgram(shaderProgram);\n\n    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\n    shaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, \"aColor\");\n    \n    shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, \"projectionVector\");\n    shaderProgram.translationMatrix = gl.getUniformLocation(shaderProgram, \"translationMatrix\");\n    \n\tshaderProgram.alpha = gl.getUniformLocation(shaderProgram, \"alpha\");\n\n\tPIXI.primitiveProgram = shaderProgram;\n}\n\nPIXI.initDefaultShader = function() \n{\n\tvar gl = this.gl;\n\tvar shaderProgram = PIXI.compileProgram(PIXI.shaderVertexSrc, PIXI.shaderFragmentSrc)\n\t\n    gl.useProgram(shaderProgram);\n\n    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\n    shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, \"projectionVector\");\n    shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, \"aTextureCoord\");\n\tshaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, \"aColor\");\n\n   // shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, \"uMVMatrix\");\n    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, \"uSampler\");\n    \n\tPIXI.shaderProgram = shaderProgram;\n}\n\nPIXI.initDefaultStripShader = function() \n{\n\tvar gl = this.gl;\n\tvar shaderProgram = PIXI.compileProgram(PIXI.stripShaderVertexSrc, PIXI.stripShaderFragmentSrc)\n\t\n    gl.useProgram(shaderProgram);\n\n    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\n    shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, \"projectionVector\");\n    shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, \"aTextureCoord\");\n\tshaderProgram.translationMatrix = gl.getUniformLocation(shaderProgram, \"translationMatrix\");\n\tshaderProgram.alpha = gl.getUniformLocation(shaderProgram, \"alpha\");\n\n\tshaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, \"aColor\");\n\n    shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, \"projectionVector\");\n    \n    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, \"uSampler\");\n    \n\tPIXI.stripShaderProgram = shaderProgram;\n}\n\nPIXI.CompileVertexShader = function(gl, shaderSrc)\n{\n  return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);\n}\n\nPIXI.CompileFragmentShader = function(gl, shaderSrc)\n{\n  return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);\n}\n\nPIXI._CompileShader = function(gl, shaderSrc, shaderType)\n{\n  var src = shaderSrc.join(\"\\n\");\n  var shader = gl.createShader(shaderType);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(gl.getShaderInfoLog(shader));\n    return null;\n  }\n\n  return shader;\n}\n\n\nPIXI.compileProgram = function(vertexSrc, fragmentSrc)\n{\n\tvar gl = PIXI.gl;\n\tvar fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);\n\tvar vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);\n\t\n\tvar shaderProgram = gl.createProgram();\n\t\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n        alert(\"Could not initialise shaders\");\n    }\n\n\treturn shaderProgram;\n} \n\n\nPIXI.activateDefaultShader = function()\n{\n\tvar gl = PIXI.gl;\n\tvar shaderProgram = PIXI.shaderProgram;\n\t\n\tgl.useProgram(shaderProgram);\n\t\n\t\n\tgl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);\n    gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);\n    gl.enableVertexAttribArray(shaderProgram.colorAttribute);\n}\n\n\t\n\nPIXI.activatePrimitiveShader = function()\n{\n\tvar gl = PIXI.gl;\n\t\n\tgl.disableVertexAttribArray(PIXI.shaderProgram.textureCoordAttribute);\n    gl.disableVertexAttribArray(PIXI.shaderProgram.colorAttribute);\n    \n\tgl.useProgram(PIXI.primitiveProgram);\n\t\n\tgl.enableVertexAttribArray(PIXI.primitiveProgram.vertexPositionAttribute);\n\tgl.enableVertexAttribArray(PIXI.primitiveProgram.colorAttribute);\n} \n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used by the webGL renderer to draw the primitive graphics data\n *\n * @class CanvasGraphics\n */\nPIXI.WebGLGraphics = function()\n{\n\t\n}\n\n/**\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics}\n * @param projection {Object}\n */\nPIXI.WebGLGraphics.renderGraphics = function(graphics, projection)\n{\n\tvar gl = PIXI.gl;\n\t\n\tif(!graphics._webGL)graphics._webGL = {points:[], indices:[], lastIndex:0, \n\t\t\t\t\t\t\t\t\t\t   buffer:gl.createBuffer(),\n\t\t\t\t\t\t\t\t\t\t   indexBuffer:gl.createBuffer()};\n\t\n\tif(graphics.dirty)\n\t{\n\t\tgraphics.dirty = false;\n\t\t\n\t\tif(graphics.clearDirty)\n\t\t{\n\t\t\tgraphics.clearDirty = false;\n\t\t\t\n\t\t\tgraphics._webGL.lastIndex = 0;\n\t\t\tgraphics._webGL.points = [];\n\t\t\tgraphics._webGL.indices = [];\n\t\t\t\n\t\t}\n\t\t\n\t\tPIXI.WebGLGraphics.updateGraphics(graphics);\n\t}\n\t\n\t\n\tPIXI.activatePrimitiveShader();\n\t\n\t// This  could be speeded up fo sure!\n\tvar m = PIXI.mat3.clone(graphics.worldTransform);\n\t\n\tPIXI.mat3.transpose(m);\n\t\n\t// set the matrix transform for the \n \tgl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n \t\n \tgl.uniformMatrix3fv(PIXI.primitiveProgram.translationMatrix, false, m);\n \t\n\tgl.uniform2f(PIXI.primitiveProgram.projectionVector, projection.x, projection.y);\n\t\n\tgl.uniform1f(PIXI.primitiveProgram.alpha, graphics.worldAlpha);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, graphics._webGL.buffer);\n\t\n\t// WHY DOES THIS LINE NEED TO BE THERE???\n\tgl.vertexAttribPointer(PIXI.shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);\n\t// its not even used.. but need to be set or it breaks?\n\t// only on pc though..\n\t\n\tgl.vertexAttribPointer(PIXI.primitiveProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 4 * 6, 0);\n\tgl.vertexAttribPointer(PIXI.primitiveProgram.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\t\n\t// set the index buffer!\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, graphics._webGL.indexBuffer);\n\t\n\tgl.drawElements(gl.TRIANGLE_STRIP,  graphics._webGL.indices.length, gl.UNSIGNED_SHORT, 0 );\n\t\n\t// return to default shader...\n\tPIXI.activateDefaultShader();\n}\n\n/**\n * Updates the graphics object\n *\n * @static\n * @private\n * @method updateGraphics\n * @param graphics {Graphics}\n */\nPIXI.WebGLGraphics.updateGraphics = function(graphics)\n{\n\tfor (var i=graphics._webGL.lastIndex; i < graphics.graphicsData.length; i++) \n\t{\n\t\tvar data = graphics.graphicsData[i];\n\t\t\n\t\tif(data.type == PIXI.Graphics.POLY)\n\t\t{\n\t\t\tif(data.fill)\n\t\t\t{\n\t\t\t\tif(data.points.length>3) \n\t\t\t\tPIXI.WebGLGraphics.buildPoly(data, graphics._webGL);\n\t\t\t}\n\t\t\t\n\t\t\tif(data.lineWidth > 0)\n\t\t\t{\n\t\t\t\tPIXI.WebGLGraphics.buildLine(data, graphics._webGL);\n\t\t\t}\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.RECT)\n\t\t{\n\t\t\tPIXI.WebGLGraphics.buildRectangle(data, graphics._webGL);\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.CIRC || data.type == PIXI.Graphics.ELIP)\n\t\t{\n\t\t\tPIXI.WebGLGraphics.buildCircle(data, graphics._webGL);\n\t\t}\n\t};\n\t\n\tgraphics._webGL.lastIndex = graphics.graphicsData.length;\n\t\n\tvar gl = PIXI.gl;\n\n\tgraphics._webGL.glPoints = new Float32Array(graphics._webGL.points);\n\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, graphics._webGL.buffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, graphics._webGL.glPoints, gl.STATIC_DRAW);\n\t\n\tgraphics._webGL.glIndicies = new Uint16Array(graphics._webGL.indices);\n\t\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, graphics._webGL.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, graphics._webGL.glIndicies, gl.STATIC_DRAW);\n}\n\n/**\n * Builds a rectangle to draw\n *\n * @static\n * @private\n * @method buildRectangle\n * @param graphics {Graphics}\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)\n{\n\t// --- //\n\t// need to convert points to a nice regular data\n\t// \n\tvar rectData = graphicsData.points;\n\tvar x = rectData[0];\n\tvar y = rectData[1];\n\tvar width = rectData[2];\n\tvar height = rectData[3];\n\t\n\t\n\tif(graphicsData.fill)\n\t{\n\t\tvar color = HEXtoRGB(graphicsData.fillColor);\n\t\tvar alpha = graphicsData.fillAlpha;\n\t\t\n\t\tvar r = color[0] * alpha;\n\t\tvar g = color[1] * alpha;\n\t\tvar b = color[2] * alpha;\n\t\n\t\tvar verts = webGLData.points;\n\t\tvar indices = webGLData.indices;\n\t\n\t\tvar vertPos = verts.length/6;\n\t\t\n\t\t// start\n\t\tverts.push(x, y);\n\t\tverts.push(r, g, b, alpha);\n\t\t\n\t\tverts.push(x + width, y);\n\t\tverts.push(r, g, b, alpha);\n\t\t\n\t\tverts.push(x , y + height);\n\t\tverts.push(r, g, b, alpha);\n\t\t\n\t\tverts.push(x + width, y + height);\n\t\tverts.push(r, g, b, alpha);\n\t\t\n\t\t// insert 2 dead triangles..\n\t\tindices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3)\n\t}\n\t\n\tif(graphicsData.lineWidth)\n\t{\n\t\tgraphicsData.points = [x, y,\n\t\t\t\t  x + width, y,\n\t\t\t\t  x + width, y + height,\n\t\t\t\t  x, y + height,\n\t\t\t\t  x, y];\n\t\n\t\tPIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\t}\n\t\n}\n\n/**\n * Builds a circle to draw\n *\n * @static\n * @private\n * @method buildCircle\n * @param graphics {Graphics}\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)\n{\n\t// --- //\n\t// need to convert points to a nice regular data\n\t// \n\tvar rectData = graphicsData.points;\n\tvar x = rectData[0];\n\tvar y = rectData[1];\n\tvar width = rectData[2];\n\tvar height = rectData[3];\n\t\n\tvar totalSegs = 40;\n\tvar seg = (Math.PI * 2) / totalSegs ;\n\t\t\n\tif(graphicsData.fill)\n\t{\n\t\tvar color = HEXtoRGB(graphicsData.fillColor);\n\t\tvar alpha = graphicsData.fillAlpha;\n\n\t\tvar r = color[0] * alpha;\n\t\tvar g = color[1] * alpha;\n\t\tvar b = color[2] * alpha;\n\t\n\t\tvar verts = webGLData.points;\n\t\tvar indices = webGLData.indices;\n\t\n\t\tvar vecPos = verts.length/6;\n\t\t\n\t\tindices.push(vecPos);\n\t\t\n\t\tfor (var i=0; i < totalSegs + 1 ; i++) \n\t\t{\n\t\t\tverts.push(x,y, r, g, b, alpha);\n\t\t\t\n\t\t\tverts.push(x + Math.sin(seg * i) * width,\n\t\t\t\t\t   y + Math.cos(seg * i) * height,\n\t\t\t\t\t   r, g, b, alpha);\n\t\t\n\t\t\tindices.push(vecPos++, vecPos++);\n\t\t};\n\t\t\n\t\tindices.push(vecPos-1);\n\t}\n\t\n\tif(graphicsData.lineWidth)\n\t{\n\t\tgraphicsData.points = [];\n\t\t\n\t\tfor (var i=0; i < totalSegs + 1; i++) \n\t\t{\n\t\t\tgraphicsData.points.push(x + Math.sin(seg * i) * width,\n\t\t\t\t\t\t\t\t\t y + Math.cos(seg * i) * height)\n\t\t};\n\t\t\n\t\tPIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\t}\n\t\n}\n\n/**\n * Builds a line to draw\n *\n * @static\n * @private\n * @method buildLine\n * @param graphics {Graphics}\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)\n{\n\t// TODO OPTIMISE!\n\t\n\tvar wrap = true;\n\tvar points = graphicsData.points;\n\tif(points.length == 0)return;\n\t\n\t// get first and last point.. figure out the middle!\n\tvar firstPoint = new PIXI.Point( points[0], points[1] );\n\tvar lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\t\n\t// if the first point is the last point - goona have issues :)\n\tif(firstPoint.x == lastPoint.x && firstPoint.y == lastPoint.y)\n\t{\n\t\tpoints.pop();\n\t\tpoints.pop();\n\t\t\n\t\tlastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\t\t\n\t\tvar midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;\n\t\tvar midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;\n\t\t\n\t\tpoints.unshift(midPointX, midPointY);\n\t\tpoints.push(midPointX, midPointY)\n\t}\n\t\n\tvar verts = webGLData.points;\n\tvar indices = webGLData.indices;\n\tvar length = points.length / 2;\n\tvar indexCount = points.length;\n\tvar indexStart = verts.length/6;\n\t\n\t// DRAW the Line\n\tvar width = graphicsData.lineWidth / 2;\n\t\n\t// sort color\n\tvar color = HEXtoRGB(graphicsData.lineColor);\n\tvar alpha = graphicsData.lineAlpha;\n\tvar r = color[0] * alpha;\n\tvar g = color[1] * alpha;\n\tvar b = color[2] * alpha;\n\t\n\tvar p1x, p1y, p2x, p2y, p3x, p3y;\n\tvar perpx, perpy, perp2x, perp2y, perp3x, perp3y;\n\tvar ipx, ipy;\n\tvar a1, b1, c1, a2, b2, c2;\n\tvar denom, pdist, dist;\n\t\n\tp1x = points[0];\n\tp1y = points[1];\n\t\n\tp2x = points[2];\n\tp2y = points[3];\n\t\n\tperpx = -(p1y - p2y);\n\tperpy =  p1x - p2x;\n\t\n\tdist = Math.sqrt(perpx*perpx + perpy*perpy);\n\t\n\tperpx /= dist;\n\tperpy /= dist;\n\tperpx *= width;\n\tperpy *= width;\n\t\n\t// start\n\tverts.push(p1x - perpx , p1y - perpy,\n\t\t\t\tr, g, b, alpha);\n\t\n\tverts.push(p1x + perpx , p1y + perpy,\n\t\t\t\tr, g, b, alpha);\n\t\n\tfor (var i = 1; i < length-1; i++) \n\t{\n\t\tp1x = points[(i-1)*2];\n\t\tp1y = points[(i-1)*2 + 1];\n\t\t\n\t\tp2x = points[(i)*2]\n\t\tp2y = points[(i)*2 + 1]\n\t\t\n\t\tp3x = points[(i+1)*2];\n\t\tp3y = points[(i+1)*2 + 1];\n\t\t\n\t\tperpx = -(p1y - p2y);\n\t\tperpy = p1x - p2x;\n\t\t\n\t\tdist = Math.sqrt(perpx*perpx + perpy*perpy);\n\t\tperpx /= dist;\n\t\tperpy /= dist;\n\t\tperpx *= width;\n\t\tperpy *= width;\n\n\t\tperp2x = -(p2y - p3y);\n\t\tperp2y = p2x - p3x;\n\t\t\n\t\tdist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);\n\t\tperp2x /= dist;\n\t\tperp2y /= dist;\n\t\tperp2x *= width;\n\t\tperp2y *= width;\n\t\t\n\t\ta1 = (-perpy + p1y) - (-perpy + p2y);\n\t    b1 = (-perpx + p2x) - (-perpx + p1x);\n\t    c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n\t    a2 = (-perp2y + p3y) - (-perp2y + p2y);\n\t    b2 = (-perp2x + p2x) - (-perp2x + p3x);\n\t    c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n\t \n\t    denom = a1*b2 - a2*b1;\n\t    \n\t    if (denom == 0) {\n\t    \tdenom+=1;\n\t    }\n\t    \n\t    px = (b1*c2 - b2*c1)/denom;\n\t    py = (a2*c1 - a1*c2)/denom;\n\t\t\n\t\tpdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);\n\t\t\n\t\tif(pdist > 140 * 140)\n\t\t{\n\t\t\tperp3x = perpx - perp2x;\n\t\t\tperp3y = perpy - perp2y;\n\t\t\t\n\t\t\tdist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);\n\t\t\tperp3x /= dist;\n\t\t\tperp3y /= dist;\n\t\t\tperp3x *= width;\n\t\t\tperp3y *= width;\n\t\t\t\n\t\t\tverts.push(p2x - perp3x, p2y -perp3y);\n\t\t\tverts.push(r, g, b, alpha);\n\t\t\t\n\t\t\tverts.push(p2x + perp3x, p2y +perp3y);\n\t\t\tverts.push(r, g, b, alpha);\n\t\t\t\n\t\t\tverts.push(p2x - perp3x, p2y -perp3y);\n\t\t\tverts.push(r, g, b, alpha);\n\t\t\t\n\t\t\tindexCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tverts.push(px , py);\n\t\t\tverts.push(r, g, b, alpha);\n\t\t\t\n\t\t\tverts.push(p2x - (px-p2x), p2y - (py - p2y));\n\t\t\tverts.push(r, g, b, alpha);\n\t\t}\n\t}\n\t\n\tp1x = points[(length-2)*2]\n\tp1y = points[(length-2)*2 + 1] \n\t\n\tp2x = points[(length-1)*2]\n\tp2y = points[(length-1)*2 + 1]\n\t\n\tperpx = -(p1y - p2y)\n\tperpy = p1x - p2x;\n\t\n\tdist = Math.sqrt(perpx*perpx + perpy*perpy);\n\tperpx /= dist;\n\tperpy /= dist;\n\tperpx *= width;\n\tperpy *= width;\n\t\n\tverts.push(p2x - perpx , p2y - perpy)\n\tverts.push(r, g, b, alpha);\n\t\n\tverts.push(p2x + perpx , p2y + perpy)\n\tverts.push(r, g, b, alpha);\n\t\n\tindices.push(indexStart);\n\t\n\tfor (var i=0; i < indexCount; i++) \n\t{\n\t\tindices.push(indexStart++);\n\t};\n\t\n\tindices.push(indexStart-1);\n}\n\n/**\n * Builds a polygon to draw\n *\n * @static\n * @private\n * @method buildPoly\n * @param graphics {Graphics}\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)\n{\n\tvar points = graphicsData.points;\n\tif(points.length < 6)return;\n\t\n\t// get first and last point.. figure out the middle!\n\tvar verts = webGLData.points;\n\tvar indices = webGLData.indices;\n\t\n\tvar length = points.length / 2;\n\t\n\t// sort color\n\tvar color = HEXtoRGB(graphicsData.fillColor);\n\tvar alpha = graphicsData.fillAlpha;\n\tvar r = color[0] * alpha;\n\tvar g = color[1] * alpha;\n\tvar b = color[2] * alpha;\n\t\n\tvar triangles = PIXI.PolyK.Triangulate(points);\n\t\n\tvar vertPos = verts.length / 6;\n\t\n\tfor (var i=0; i < triangles.length; i+=3) \n\t{\n\t\tindices.push(triangles[i] + vertPos);\n\t\tindices.push(triangles[i] + vertPos);\n\t\tindices.push(triangles[i+1] + vertPos);\n\t\tindices.push(triangles[i+2] +vertPos);\n\t\tindices.push(triangles[i+2] + vertPos);\n\t};\n\t\n\tfor (var i = 0; i < length; i++) \n\t{\n\t\tverts.push(points[i * 2], points[i * 2 + 1],\n\t\t\t\t   r, g, b, alpha);\n\t};\n}\n\nfunction HEXtoRGB(hex) {\n\treturn [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];\n}\n\n\n\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI._defaultFrame = new PIXI.Rectangle(0,0,1,1);\n\n// an instance of the gl context..\n// only one at the moment :/\nPIXI.gl;\n\n/**\n * the WebGLRenderer is draws the stage and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batch's or Sprite Cloud's\n * Dont forget to add the view to your DOM or you will not see anything :)\n *\n * @class WebGLRenderer\n * @constructor\n * @param width=0 {Number} the width of the canvas view\n * @param height=0 {Number} the height of the canvas view\n * @param view {Canvas} the canvas to use as a view, optional\n * @param transparent=false {Boolean} the transparency of the render view, default false\n * @param antialias=false {Boolean} sets antialias (only applicable in chrome at the moment)\n * \n */\nPIXI.WebGLRenderer = function(width, height, view, transparent, antialias)\n{\n\t// do a catch.. only 1 webGL renderer..\n\n\tthis.transparent = !!transparent;\n\n\tthis.width = width || 800;\n\tthis.height = height || 600;\n\n\tthis.view = view || document.createElement( 'canvas' ); \n    this.view.width = this.width;\n\tthis.view.height = this.height;\n\n\t// deal with losing context..\t\n    var scope = this;\n\tthis.view.addEventListener('webglcontextlost', function(event) { scope.handleContextLost(event); }, false)\n\tthis.view.addEventListener('webglcontextrestored', function(event) { scope.handleContextRestored(event); }, false)\n\n\tthis.batchs = [];\n\n\ttry \n \t{\n        PIXI.gl = this.gl = this.view.getContext(\"experimental-webgl\",  {  \t\n    \t\t alpha: this.transparent,\n    \t\t antialias:!!antialias, // SPEED UP??\n    \t\t premultipliedAlpha:false,\n    \t\t stencil:true\n        });\n    } \n    catch (e) \n    {\n    \tthrow new Error(\" This browser does not support webGL. Try using the canvas renderer\" + this);\n    }\n\n    PIXI.initPrimitiveShader();\n    PIXI.initDefaultShader();\n    PIXI.initDefaultStripShader();\n\n    PIXI.activateDefaultShader();\n\n    var gl = this.gl;\n    PIXI.WebGLRenderer.gl = gl;\n\n    this.batch = new PIXI.WebGLBatch(gl);\n   \tgl.disable(gl.DEPTH_TEST);\n   \tgl.disable(gl.CULL_FACE);\n\n    gl.enable(gl.BLEND);\n    gl.colorMask(true, true, true, this.transparent); \n\n    PIXI.projection = new PIXI.Point(400, 300);\n\n    this.resize(this.width, this.height);\n    this.contextLost = false;\n\n    this.stageRenderGroup = new PIXI.WebGLRenderGroup(this.gl);\n}\n\n// constructor\nPIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;\n\n/**\n * Gets a new WebGLBatch from the pool\n *\n * @static\n * @method getBatch\n * @return {WebGLBatch}\n * @private \n */\nPIXI.WebGLRenderer.getBatch = function()\n{\n\tif(PIXI._batchs.length == 0)\n\t{\n\t\treturn new PIXI.WebGLBatch(PIXI.WebGLRenderer.gl);\n\t}\n\telse\n\t{\n\t\treturn PIXI._batchs.pop();\n\t}\n}\n\n/**\n * Puts a batch back into the pool\n *\n * @static\n * @method returnBatch\n * @param batch {WebGLBatch} The batch to return\n * @private\n */\nPIXI.WebGLRenderer.returnBatch = function(batch)\n{\n\tbatch.clean();\t\n\tPIXI._batchs.push(batch);\n}\n\n/**\n * Renders the stage to its webGL view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.WebGLRenderer.prototype.render = function(stage)\n{\n\tif(this.contextLost)return;\n\t\n\t\n\t// if rendering a new stage clear the batchs..\n\tif(this.__stage !== stage)\n\t{\n\t\t// TODO make this work\n\t\t// dont think this is needed any more?\n\t\tthis.__stage = stage;\n\t\tthis.stageRenderGroup.setRenderable(stage);\n\t}\n\t\n\t// TODO not needed now... \n\t// update children if need be\n\t// best to remove first!\n\t/*for (var i=0; i < stage.__childrenRemoved.length; i++)\n\t{\n\t\tvar group = stage.__childrenRemoved[i].__renderGroup\n\t\tif(group)group.removeDisplayObject(stage.__childrenRemoved[i]);\n\t}*/\n\n\t// update any textures\t\n\tPIXI.WebGLRenderer.updateTextures();\n\t\t\n\t// update the scene graph\t\n\tPIXI.visibleCount++;\n\tstage.updateTransform();\n\t\n\tvar gl = this.gl;\n\t\n\t// -- Does this need to be set every frame? -- //\n\tgl.colorMask(true, true, true, this.transparent); \n\tgl.viewport(0, 0, this.width, this.height);\t\n\t\n   \tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\t\n\tgl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], !this.transparent);     \n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\t// HACK TO TEST\n\t\n\tthis.stageRenderGroup.backgroundColor = stage.backgroundColorSplit;\n\tthis.stageRenderGroup.render(PIXI.projection);\n\t\n\t// interaction\n\t// run interaction!\n\tif(stage.interactive)\n\t{\n\t\t//need to add some events!\n\t\tif(!stage._interactiveEventsAdded)\n\t\t{\n\t\t\tstage._interactiveEventsAdded = true;\n\t\t\tstage.interactionManager.setTarget(this);\n\t\t}\n\t}\n\t\n\t// after rendering lets confirm all frames that have been uodated..\n\tif(PIXI.Texture.frameUpdates.length > 0)\n\t{\n\t\tfor (var i=0; i < PIXI.Texture.frameUpdates.length; i++) \n\t\t{\n\t\t  \tPIXI.Texture.frameUpdates[i].updateFrame = false;\n\t\t};\n\t\t\n\t\tPIXI.Texture.frameUpdates = [];\n\t}\n}\n\n/**\n * Updates the textures loaded into this webgl renderer\n *\n * @static\n * @method updateTextures\n * @private\n */\nPIXI.WebGLRenderer.updateTextures = function()\n{\n\t//TODO break this out into a texture manager...\n\tfor (var i=0; i < PIXI.texturesToUpdate.length; i++) PIXI.WebGLRenderer.updateTexture(PIXI.texturesToUpdate[i]);\n\tfor (var i=0; i < PIXI.texturesToDestroy.length; i++) PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);\n\tPIXI.texturesToUpdate = [];\n\tPIXI.texturesToDestroy = [];\n}\n\n/**\n * Updates a loaded webgl texture\n *\n * @static\n * @method updateTexture\n * @param texture {Texture} The texture to update\n * @private\n */\nPIXI.WebGLRenderer.updateTexture = function(texture)\n{\n\t//TODO break this out into a texture manager...\n\tvar gl = PIXI.gl;\n\t\n\tif(!texture._glTexture)\n\t{\n\t\ttexture._glTexture = gl.createTexture();\n\t}\n\n\tif(texture.hasLoaded)\n\t{\n\t\tgl.bindTexture(gl.TEXTURE_2D, texture._glTexture);\n\t \tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n\t\t// reguler...\n\n\t\tif(!texture._powerOf2)\n\t\t{\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n\t\t}\n\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t}\n}\n\n/**\n * Destroys a loaded webgl texture\n *\n * @method destroyTexture\n * @param texture {Texture} The texture to update\n * @private\n */\nPIXI.WebGLRenderer.destroyTexture = function(texture)\n{\n\t//TODO break this out into a texture manager...\n\tvar gl = PIXI.gl;\n\n\tif(texture._glTexture)\n\t{\n\t\ttexture._glTexture = gl.createTexture();\n\t\tgl.deleteTexture(gl.TEXTURE_2D, texture._glTexture);\n\t}\n}\n\n/**\n * resizes the webGL view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the webGL view\n * @param height {Number} the new height of the webGL view\n */\nPIXI.WebGLRenderer.prototype.resize = function(width, height)\n{\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.view.width = width;\n\tthis.view.height = height;\n\n\tthis.gl.viewport(0, 0, this.width, this.height);\t\n\n\t//var projectionMatrix = this.projectionMatrix;\n\n\tPIXI.projection.x =  this.width/2;\n\tPIXI.projection.y =  this.height/2;\n\n//\tprojectionMatrix[0] = 2/this.width;\n//\tprojectionMatrix[5] = -2/this.height;\n//\tprojectionMatrix[12] = -1;\n//\tprojectionMatrix[13] = 1;\n}\n\n/**\n * Handles a lost webgl context\n *\n * @method handleContextLost\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextLost = function(event)\n{\n\tevent.preventDefault();\n\tthis.contextLost = true;\n}\n\n/**\n * Handles a restored webgl context\n *\n * @method handleContextRestored\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextRestored = function(event)\n{\n\tthis.gl = this.view.getContext(\"experimental-webgl\",  {  \t\n\t\talpha: true\n    });\n\n\tthis.initShaders();\t\n\n\tfor(var key in PIXI.TextureCache) \n\t{\n        \tvar texture = PIXI.TextureCache[key].baseTexture;\n        \ttexture._glTexture = null;\n        \tPIXI.WebGLRenderer.updateTexture(texture);\n\t};\n\n\tfor (var i=0; i <  this.batchs.length; i++) \n\t{\n\t\tthis.batchs[i].restoreLostContext(this.gl)//\n\t\tthis.batchs[i].dirty = true;\n\t};\n\n\tPIXI._restoreBatchs(this.gl);\n\n\tthis.contextLost = false;\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI._batchs = [];\n\n/**\n * @private\n */\nPIXI._getBatch = function(gl)\n{\n\tif(PIXI._batchs.length == 0)\n\t{\n\t\treturn new PIXI.WebGLBatch(gl);\n\t}\n\telse\n\t{\n\t\treturn PIXI._batchs.pop();\n\t}\n}\n\n/**\n * @private\n */\nPIXI._returnBatch = function(batch)\n{\n\tbatch.clean();\t\n\tPIXI._batchs.push(batch);\n}\n\n/**\n * @private\n */\nPIXI._restoreBatchs = function(gl)\n{\n\tfor (var i=0; i < PIXI._batchs.length; i++) \n\t{\n\t  PIXI._batchs[i].restoreLostContext(gl);\n\t};\n}\n\n/**\n * A WebGLBatch Enables a group of sprites to be drawn using the same settings.\n * if a group of sprites all have the same baseTexture and blendMode then they can be grouped into a batch.\n * All the sprites in a batch can then be drawn in one go by the GPU which is hugely efficient. ALL sprites\n * in the webGL renderer are added to a batch even if the batch only contains one sprite. Batching is handled\n * automatically by the webGL renderer. A good tip is: the smaller the number of batchs there are, the faster\n * the webGL renderer will run.\n *\n * @class WebGLBatch\n * @constructor\n * @param gl {WebGLContext} an instance of the webGL context\n */\nPIXI.WebGLBatch = function(gl)\n{\n\tthis.gl = gl;\n\t\n\tthis.size = 0;\n\n\tthis.vertexBuffer =  gl.createBuffer();\n\tthis.indexBuffer =  gl.createBuffer();\n\tthis.uvBuffer =  gl.createBuffer();\n\tthis.colorBuffer =  gl.createBuffer();\n\tthis.blendMode = PIXI.blendModes.NORMAL;\n\tthis.dynamicSize = 1;\n}\n\n// constructor\nPIXI.WebGLBatch.prototype.constructor = PIXI.WebGLBatch;\n\n/**\n * Cleans the batch so that is can be returned to an object pool and reused\n *\n * @method clean\n */\nPIXI.WebGLBatch.prototype.clean = function()\n{\n\tthis.verticies = [];\n\tthis.uvs = [];\n\tthis.indices = [];\n\tthis.colors = [];\n\tthis.dynamicSize = 1;\n\tthis.texture = null;\n\tthis.last = null;\n\tthis.size = 0;\n\tthis.head;\n\tthis.tail;\n}\n\n/**\n * Recreates the buffers in the event of a context loss\n *\n * @method restoreLostContext\n * @param gl {WebGLContext}\n */\nPIXI.WebGLBatch.prototype.restoreLostContext = function(gl)\n{\n\tthis.gl = gl;\n\tthis.vertexBuffer =  gl.createBuffer();\n\tthis.indexBuffer =  gl.createBuffer();\n\tthis.uvBuffer =  gl.createBuffer();\n\tthis.colorBuffer =  gl.createBuffer();\n}\n\n/**\n * inits the batch's texture and blend mode based if the supplied sprite\n *\n * @method init\n * @param sprite {Sprite} the first sprite to be added to the batch. Only sprites with\n *\t\tthe same base texture and blend mode will be allowed to be added to this batch\n */\t\nPIXI.WebGLBatch.prototype.init = function(sprite)\n{\n\tsprite.batch = this;\n\tthis.dirty = true;\n\tthis.blendMode = sprite.blendMode;\n\tthis.texture = sprite.texture.baseTexture;\n\tthis.head = sprite;\n\tthis.tail = sprite;\n\tthis.size = 1;\n\n\tthis.growBatch();\n}\n\n/**\n * inserts a sprite before the specified sprite\n *\n * @method insertBefore\n * @param sprite {Sprite} the sprite to be added\n * @param nextSprite {nextSprite} the first sprite will be inserted before this sprite\n */\t\nPIXI.WebGLBatch.prototype.insertBefore = function(sprite, nextSprite)\n{\n\tthis.size++;\n\n\tsprite.batch = this;\n\tthis.dirty = true;\n\tvar tempPrev = nextSprite.__prev;\n\tnextSprite.__prev = sprite;\n\tsprite.__next = nextSprite;\n\n\tif(tempPrev)\n\t{\n\t\tsprite.__prev = tempPrev;\n\t\ttempPrev.__next = sprite;\n\t}\n\telse\n\t{\n\t\tthis.head = sprite;\n\t}\n}\n\n/**\n * inserts a sprite after the specified sprite\n *\n * @method insertAfter\n * @param sprite {Sprite} the sprite to be added\n * @param  previousSprite {Sprite} the first sprite will be inserted after this sprite\n */\t\nPIXI.WebGLBatch.prototype.insertAfter = function(sprite, previousSprite)\n{\n\tthis.size++;\n\n\tsprite.batch = this;\n\tthis.dirty = true;\n\n\tvar tempNext = previousSprite.__next;\n\tpreviousSprite.__next = sprite;\n\tsprite.__prev = previousSprite;\n\n\tif(tempNext)\n\t{\n\t\tsprite.__next = tempNext;\n\t\ttempNext.__prev = sprite;\n\t}\n\telse\n\t{\n\t\tthis.tail = sprite\n\t}\n}\n\n/**\n * removes a sprite from the batch\n *\n * @method remove\n * @param sprite {Sprite} the sprite to be removed\n */\t\nPIXI.WebGLBatch.prototype.remove = function(sprite)\n{\n\tthis.size--;\n\n\tif(this.size == 0)\n\t{\n\t\tsprite.batch = null;\n\t\tsprite.__prev = null;\n\t\tsprite.__next = null;\n\t\treturn;\n\t}\n\n\tif(sprite.__prev)\n\t{\n\t\tsprite.__prev.__next = sprite.__next;\n\t}\n\telse\n\t{\n\t\tthis.head = sprite.__next;\n\t\tthis.head.__prev = null;\n\t}\n\n\tif(sprite.__next)\n\t{\n\t\tsprite.__next.__prev = sprite.__prev;\n\t}\n\telse\n\t{\n\t\tthis.tail = sprite.__prev;\n\t\tthis.tail.__next = null\n\t}\n\n\tsprite.batch = null;\n\tsprite.__next = null;\n\tsprite.__prev = null;\n\tthis.dirty = true;\n}\n\n/**\n * Splits the batch into two with the specified sprite being the start of the new batch.\n *\n * @method split\n * @param sprite {Sprite} the sprite that indicates where the batch should be split\n * @return {WebGLBatch} the new batch\n */\nPIXI.WebGLBatch.prototype.split = function(sprite)\n{\n\tthis.dirty = true;\n\n\tvar batch = new PIXI.WebGLBatch(this.gl);\n\tbatch.init(sprite);\n\tbatch.texture = this.texture;\n\tbatch.tail = this.tail;\n\n\tthis.tail = sprite.__prev;\n\tthis.tail.__next = null;\n\n\tsprite.__prev = null;\n\t// return a splite batch!\n\n\t// TODO this size is wrong!\n\t// need to recalculate :/ problem with a linked list!\n\t// unless it gets calculated in the \"clean\"?\n\n\t// need to loop through items as there is no way to know the length on a linked list :/\n\tvar tempSize = 0;\n\twhile(sprite)\n\t{\n\t\ttempSize++;\n\t\tsprite.batch = batch;\n\t\tsprite = sprite.__next;\n\t}\n\n\tbatch.size = tempSize;\n\tthis.size -= tempSize;\n\n\treturn batch;\n}\n\n/**\n * Merges two batchs together\n *\n * @method merge\n * @param batch {WebGLBatch} the batch that will be merged \n */\nPIXI.WebGLBatch.prototype.merge = function(batch)\n{\n\tthis.dirty = true;\n\n\tthis.tail.__next = batch.head;\n\tbatch.head.__prev = this.tail;\n\n\tthis.size += batch.size;\n\n\tthis.tail = batch.tail;\n\n\tvar sprite = batch.head;\n\twhile(sprite)\n\t{\n\t\tsprite.batch = this;\n\t\tsprite = sprite.__next;\n\t}\n}\n\n/**\n * Grows the size of the batch. As the elements in the batch cannot have a dynamic size this\n * function is used to increase the size of the batch. It also creates a little extra room so\n * that the batch does not need to be resized every time a sprite is added\n *\n * @method growBatch\n */\nPIXI.WebGLBatch.prototype.growBatch = function()\n{\n\tvar gl = this.gl;\n\tif( this.size == 1)\n\t{\n\t\tthis.dynamicSize = 1;\n\t}\n\telse\n\t{\n\t\tthis.dynamicSize = this.size * 1.5\n\t}\n\t// grow verts\n\tthis.verticies = new Float32Array(this.dynamicSize * 8);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER,this.verticies , gl.DYNAMIC_DRAW);\n\n\tthis.uvs  = new Float32Array( this.dynamicSize * 8 );\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, this.uvs , gl.DYNAMIC_DRAW);\n\n\tthis.dirtyUVS = true;\n\n\tthis.colors  = new Float32Array( this.dynamicSize * 4 );\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, this.colors , gl.DYNAMIC_DRAW);\n\n\tthis.dirtyColors = true;\n\n\tthis.indices = new Uint16Array(this.dynamicSize * 6); \n\tvar length = this.indices.length/6;\n\n\tfor (var i=0; i < length; i++) \n\t{\n\t    var index2 = i * 6;\n\t    var index3 = i * 4;\n\t\tthis.indices[index2 + 0] = index3 + 0;\n\t\tthis.indices[index2 + 1] = index3 + 1;\n\t\tthis.indices[index2 + 2] = index3 + 2;\n\t\tthis.indices[index2 + 3] = index3 + 0;\n\t\tthis.indices[index2 + 4] = index3 + 2;\n\t\tthis.indices[index2 + 5] = index3 + 3;\n\t};\n\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n}\n\n/**\n * Refresh's all the data in the batch and sync's it with the webGL buffers\n *\n * @method refresh\n */\nPIXI.WebGLBatch.prototype.refresh = function()\n{\n\tvar gl = this.gl;\n\n\tif (this.dynamicSize < this.size)\n\t{\n\t\tthis.growBatch();\n\t}\n\n\tvar indexRun = 0;\n\tvar worldTransform, width, height, aX, aY, w0, w1, h0, h1, index;\n\tvar a, b, c, d, tx, ty;\n\n\tvar displayObject = this.head;\n\n\twhile(displayObject)\n\t{\n\t\tindex = indexRun * 8;\n\n\t\tvar texture = displayObject.texture;\n\n\t\tvar frame = texture.frame;\n\t\tvar tw = texture.baseTexture.width;\n\t\tvar th = texture.baseTexture.height;\n\n\t\tthis.uvs[index + 0] = frame.x / tw;\n\t\tthis.uvs[index +1] = frame.y / th;\n\n\t\tthis.uvs[index +2] = (frame.x + frame.width) / tw;\n\t\tthis.uvs[index +3] = frame.y / th;\n\n\t\tthis.uvs[index +4] = (frame.x + frame.width) / tw;\n\t\tthis.uvs[index +5] = (frame.y + frame.height) / th; \n\n\t\tthis.uvs[index +6] = frame.x / tw;\n\t\tthis.uvs[index +7] = (frame.y + frame.height) / th;\n\n\t\tdisplayObject.updateFrame = false;\n\n\t\tcolorIndex = indexRun * 4;\n\t\tthis.colors[colorIndex] = this.colors[colorIndex + 1] = this.colors[colorIndex + 2] = this.colors[colorIndex + 3] = displayObject.worldAlpha;\n\n\t\tdisplayObject = displayObject.__next;\n\n\t\tindexRun ++;\n\t}\n\n\tthis.dirtyUVS = true;\n\tthis.dirtyColors = true;\n}\n\n/**\n * Updates all the relevant geometry and uploads the data to the GPU\n *\n * @method update\n */\nPIXI.WebGLBatch.prototype.update = function()\n{\n\tvar gl = this.gl;\n\tvar worldTransform, width, height, aX, aY, w0, w1, h0, h1, index, index2, index3\n\n\tvar a, b, c, d, tx, ty;\n\n\tvar indexRun = 0;\n\n\tvar displayObject = this.head;\n\n\twhile(displayObject)\n\t{\n\t\tif(displayObject.vcount === PIXI.visibleCount)\n\t\t{\n\t\t\twidth = displayObject.texture.frame.width;\n\t\t\theight = displayObject.texture.frame.height;\n\n\t\t\t// TODO trim??\n\t\t\taX = displayObject.anchor.x;// - displayObject.texture.trim.x\n\t\t\taY = displayObject.anchor.y; //- displayObject.texture.trim.y\n\t\t\tw0 = width * (1-aX);\n\t\t\tw1 = width * -aX;\n\n\t\t\th0 = height * (1-aY);\n\t\t\th1 = height * -aY;\n\n\t\t\tindex = indexRun * 8;\n\n\t\t\tworldTransform = displayObject.worldTransform;\n\n\t\t\ta = worldTransform[0];\n\t\t\tb = worldTransform[3];\n\t\t\tc = worldTransform[1];\n\t\t\td = worldTransform[4];\n\t\t\ttx = worldTransform[2];\n\t\t\tty = worldTransform[5];\n\n\t\t\tthis.verticies[index + 0 ] = a * w1 + c * h1 + tx; \n\t\t\tthis.verticies[index + 1 ] = d * h1 + b * w1 + ty;\n\n\t\t\tthis.verticies[index + 2 ] = a * w0 + c * h1 + tx; \n\t\t\tthis.verticies[index + 3 ] = d * h1 + b * w0 + ty; \n\n\t\t\tthis.verticies[index + 4 ] = a * w0 + c * h0 + tx; \n\t\t\tthis.verticies[index + 5 ] = d * h0 + b * w0 + ty; \n\n\t\t\tthis.verticies[index + 6] =  a * w1 + c * h0 + tx; \n\t\t\tthis.verticies[index + 7] =  d * h0 + b * w1 + ty; \n\n\t\t\tif(displayObject.updateFrame || displayObject.texture.updateFrame)\n\t\t\t{\n\t\t\t\tthis.dirtyUVS = true;\n\n\t\t\t\tvar texture = displayObject.texture;\n\n\t\t\t\tvar frame = texture.frame;\n\t\t\t\tvar tw = texture.baseTexture.width;\n\t\t\t\tvar th = texture.baseTexture.height;\n\n\t\t\t\tthis.uvs[index + 0] = frame.x / tw;\n\t\t\t\tthis.uvs[index +1] = frame.y / th;\n\n\t\t\t\tthis.uvs[index +2] = (frame.x + frame.width) / tw;\n\t\t\t\tthis.uvs[index +3] = frame.y / th;\n\n\t\t\t\tthis.uvs[index +4] = (frame.x + frame.width) / tw;\n\t\t\t\tthis.uvs[index +5] = (frame.y + frame.height) / th; \n\n\t\t\t\tthis.uvs[index +6] = frame.x / tw;\n\t\t\t\tthis.uvs[index +7] = (frame.y + frame.height) / th;\n\n\t\t\t\tdisplayObject.updateFrame = false;\n\t\t\t}\n\n\t\t\t// TODO this probably could do with some optimisation....\n\t\t\tif(displayObject.cacheAlpha != displayObject.worldAlpha)\n\t\t\t{\n\t\t\t\tdisplayObject.cacheAlpha = displayObject.worldAlpha;\n\n\t\t\t\tvar colorIndex = indexRun * 4;\n\t\t\t\tthis.colors[colorIndex] = this.colors[colorIndex + 1] = this.colors[colorIndex + 2] = this.colors[colorIndex + 3] = displayObject.worldAlpha;\n\t\t\t\tthis.dirtyColors = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tindex = indexRun * 8;\n\n\t\t\tthis.verticies[index + 0 ] = 0;\n\t\t\tthis.verticies[index + 1 ] = 0;\n\n\t\t\tthis.verticies[index + 2 ] = 0;\n\t\t\tthis.verticies[index + 3 ] = 0;\n\n\t\t\tthis.verticies[index + 4 ] = 0;\n\t\t\tthis.verticies[index + 5 ] = 0;\n\n\t\t\tthis.verticies[index + 6] = 0;\n\t\t\tthis.verticies[index + 7] = 0;\n\t\t}\n\n\t\tindexRun++;\n\t\tdisplayObject = displayObject.__next;\n   }\n}\n\n/**\n * Draws the batch to the frame buffer\n *\n * @method render\n */\nPIXI.WebGLBatch.prototype.render = function(start, end)\n{\n\tstart = start || 0;\n\n\tif(end == undefined)end = this.size;\n\t\n\tif(this.dirty)\n\t{\n\t\tthis.refresh();\n\t\tthis.dirty = false;\n\t}\n\n\tif (this.size == 0)return;\n\n\tthis.update();\n\tvar gl = this.gl;\n\n\t//TODO optimize this!\n\n\tvar shaderProgram = PIXI.shaderProgram;\n\tgl.useProgram(shaderProgram);\n\n\t// update the verts..\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\t// ok..\n\tgl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies)\n    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);\n\t// update the uvs\n   \tgl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n    if(this.dirtyUVS)\n    {\n    \tthis.dirtyUVS = false;\n    \tgl.bufferSubData(gl.ARRAY_BUFFER,  0, this.uvs);\n    }\n\n    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.texture._glTexture);\n\n\t// update color!\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n\n\tif(this.dirtyColors)\n    {\n    \tthis.dirtyColors = false;\n    \tgl.bufferSubData(gl.ARRAY_BUFFER, 0, this.colors);\n\t}\n\n    gl.vertexAttribPointer(shaderProgram.colorAttribute, 1, gl.FLOAT, false, 0, 0);\n\n\t// dont need to upload!\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n\tvar len = end - start;\n\n    // DRAW THAT this!\n    gl.drawElements(gl.TRIANGLES, len * 6, gl.UNSIGNED_SHORT, start * 2 * 6 );\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A WebGLBatch Enables a group of sprites to be drawn using the same settings.\n * if a group of sprites all have the same baseTexture and blendMode then they can be\n * grouped into a batch. All the sprites in a batch can then be drawn in one go by the\n * GPU which is hugely efficient. ALL sprites in the webGL renderer are added to a batch\n * even if the batch only contains one sprite. Batching is handled automatically by the\n * webGL renderer. A good tip is: the smaller the number of batchs there are, the faster\n * the webGL renderer will run.\n *\n * @class WebGLBatch\n * @contructor\n * @param gl {WebGLContext} An instance of the webGL context\n */\nPIXI.WebGLRenderGroup = function(gl)\n{\n\tthis.gl = gl;\n\tthis.root;\n\t\n\tthis.backgroundColor;\n\tthis.batchs = [];\n\tthis.toRemove = [];\n}\n\n// constructor\nPIXI.WebGLRenderGroup.prototype.constructor = PIXI.WebGLRenderGroup;\n\n/**\n * Add a display object to the webgl renderer\n *\n * @method setRenderable\n * @param displayObject {DisplayObject}\n * @private \n */\nPIXI.WebGLRenderGroup.prototype.setRenderable = function(displayObject)\n{\n\t// has this changed??\n\tif(this.root)this.removeDisplayObjectAndChildren(this.root);\n\t\n\tdisplayObject.worldVisible = displayObject.visible;\n\t\n\t// soooooo //\n\t// to check if any batchs exist already??\n\t\n\t// TODO what if its already has an object? should remove it\n\tthis.root = displayObject;\n\tthis.addDisplayObjectAndChildren(displayObject);\n}\n\n/**\n * Renders the stage to its webgl view\n *\n * @method render\n * @param projection {Object}\n */\nPIXI.WebGLRenderGroup.prototype.render = function(projection)\n{\n\tPIXI.WebGLRenderer.updateTextures();\n\t\n\tvar gl = this.gl;\n\n\t\n\tgl.uniform2f(PIXI.shaderProgram.projectionVector, projection.x, projection.y);\n\tgl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\n\t// will render all the elements in the group\n\tvar renderable;\n\t\n\tfor (var i=0; i < this.batchs.length; i++) \n\t{\n\t\t\n\t\trenderable = this.batchs[i];\n\t\tif(renderable instanceof PIXI.WebGLBatch)\n\t\t{\n\t\t\tthis.batchs[i].render();\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// non sprite batch..\n\t\tvar worldVisible = renderable.vcount === PIXI.visibleCount;\n\n\t\tif(renderable instanceof PIXI.TilingSprite)\n\t\t{\n\t\t\tif(worldVisible)this.renderTilingSprite(renderable, projection);\n\t\t}\n\t\telse if(renderable instanceof PIXI.Strip)\n\t\t{\n\t\t\tif(worldVisible)this.renderStrip(renderable, projection);\n\t\t}\n\t\telse if(renderable instanceof PIXI.Graphics)\n\t\t{\n\t\t\tif(worldVisible && renderable.renderable) PIXI.WebGLGraphics.renderGraphics(renderable, projection);//, projectionMatrix);\n\t\t}\n\t\telse if(renderable instanceof PIXI.FilterBlock)\n\t\t{\n\t\t\t/*\n\t\t\t * for now only masks are supported..\n\t\t\t */\n\t\t\tif(renderable.open)\n\t\t\t{\n    \t\t\tgl.enable(gl.STENCIL_TEST);\n\t\t\t\t\t\n\t\t\t\tgl.colorMask(false, false, false, false);\n\t\t\t\tgl.stencilFunc(gl.ALWAYS,1,0xff);\n\t\t\t\tgl.stencilOp(gl.KEEP,gl.KEEP,gl.REPLACE);\n  \n\t\t\t\tPIXI.WebGLGraphics.renderGraphics(renderable.mask, projection);\n  \t\t\t\t\t\n\t\t\t\tgl.colorMask(true, true, true, false);\n\t\t\t\tgl.stencilFunc(gl.NOTEQUAL,0,0xff);\n\t\t\t\tgl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n/**\n * Renders the stage to its webgl view\n *\n * @method handleFilter\n * @param filter {FilterBlock}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.handleFilter = function(filter, projection)\n{\n\t\n}\n\n/**\n * Renders a specific displayObject\n *\n * @method renderSpecific\n * @param displayObject {DisplayObject}\n * @param projection {Object}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.renderSpecific = function(displayObject, projection)\n{\n\tPIXI.WebGLRenderer.updateTextures();\n\t\n\tvar gl = this.gl;\n\n\tgl.uniform2f(PIXI.shaderProgram.projectionVector, projection.x, projection.y);\n\n\t// to do!\n\t// render part of the scene...\n\t\n\tvar startIndex;\n\tvar startBatchIndex;\n\t\n\tvar endIndex;\n\tvar endBatchIndex;\n\t\n\t/*\n\t *  LOOK FOR THE NEXT SPRITE\n\t *  This part looks for the closest next sprite that can go into a batch\n\t *  it keeps looking until it finds a sprite or gets to the end of the display\n\t *  scene graph\n\t */\n\tvar nextRenderable = displayObject.first;\n\twhile(nextRenderable._iNext)\n\t{\n\t\tnextRenderable = nextRenderable._iNext;\n\t\tif(nextRenderable.renderable && nextRenderable.__renderGroup)break;\n\t}\n\tvar startBatch = nextRenderable.batch;\n\t\n\tif(nextRenderable instanceof PIXI.Sprite)\n\t{\n\t\tstartBatch = nextRenderable.batch;\n\t\t\n\t\tvar head = startBatch.head;\n\t\tvar next = head;\n\t\t\n\t\t// ok now we have the batch.. need to find the start index!\n\t\tif(head == nextRenderable)\n\t\t{\n\t\t\tstartIndex = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstartIndex = 1;\n\t\t\t\n\t\t\twhile(head.__next != nextRenderable)\n\t\t\t{\n\t\t\t\tstartIndex++;\n\t\t\t\thead = head.__next;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tstartBatch = nextRenderable;\n\t}\n\t\n\t// Get the LAST renderable object\n\tvar lastRenderable = displayObject;\n\tvar endBatch;\n\tvar lastItem = displayObject;\n\twhile(lastItem.children.length > 0)\n\t{\n\t\tlastItem = lastItem.children[lastItem.children.length-1];\n\t\tif(lastItem.renderable)lastRenderable = lastItem;\n\t}\n\t\n\tif(lastRenderable instanceof PIXI.Sprite)\n\t{\n\t\tendBatch = lastRenderable.batch;\n\t\t\n\t\tvar head = endBatch.head;\n\t\t\n\t\tif(head == lastRenderable)\n\t\t{\n\t\t\tendIndex = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tendIndex = 1;\n\t\t\t\n\t\t\twhile(head.__next != lastRenderable)\n\t\t\t{\n\t\t\t\tendIndex++;\n\t\t\t\thead = head.__next;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tendBatch = lastRenderable;\n\t}\n\t\n\t// TODO - need to fold this up a bit!\n\t\n\tif(startBatch == endBatch)\n\t{\n\t\tif(startBatch instanceof PIXI.WebGLBatch)\n\t\t{\n\t\t\tstartBatch.render(startIndex, endIndex+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.renderSpecial(startBatch, projection);\n\t\t}\n\t\treturn;\n\t}\n\t\n\t// now we have first and last!\n\tstartBatchIndex = this.batchs.indexOf(startBatch);\n\tendBatchIndex = this.batchs.indexOf(endBatch);\n\t\n\t// DO the first batch\n\tif(startBatch instanceof PIXI.WebGLBatch)\n\t{\n\t\tstartBatch.render(startIndex);\n\t}\n\telse\n\t{\n\t\tthis.renderSpecial(startBatch, projection);\n\t}\n\t\n\t// DO the middle batchs..\n\tfor (var i=startBatchIndex+1; i < endBatchIndex; i++) \n\t{\n\t\trenderable = this.batchs[i];\n\t\n\t\tif(renderable instanceof PIXI.WebGLBatch)\n\t\t{\n\t\t\tthis.batchs[i].render();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.renderSpecial(renderable, projection);\n\t\t}\n\t}\n\t\n\t// DO the last batch..\n\tif(endBatch instanceof PIXI.WebGLBatch)\n\t{\n\t\tendBatch.render(0, endIndex+1);\n\t}\n\telse\n\t{\n\t\tthis.renderSpecial(endBatch, projection);\n\t}\n}\n\n/**\n * Renders a specific renderable\n *\n * @method renderSpecial\n * @param renderable {DisplayObject}\n * @param projection {Object}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.renderSpecial = function(renderable, projection)\n{\n\tvar worldVisible = renderable.vcount === PIXI.visibleCount\n\n\tif(renderable instanceof PIXI.TilingSprite)\n\t{\n\t\tif(worldVisible)this.renderTilingSprite(renderable, projection);\n\t}\n\telse if(renderable instanceof PIXI.Strip)\n\t{\n\t\tif(worldVisible)this.renderStrip(renderable, projection);\n\t}\n\telse if(renderable instanceof PIXI.CustomRenderable)\n\t{\n\t\tif(worldVisible) renderable.renderWebGL(this, projection);\n\t}\n\telse if(renderable instanceof PIXI.Graphics)\n\t{\n\t\tif(worldVisible && renderable.renderable) PIXI.WebGLGraphics.renderGraphics(renderable, projection);\n\t}\n\telse if(renderable instanceof PIXI.FilterBlock)\n\t{\n\t\t/*\n\t\t * for now only masks are supported..\n\t\t */\n\n\t\tvar gl = PIXI.gl;\n\n\t\tif(renderable.open)\n\t\t{\n\t\t\tgl.enable(gl.STENCIL_TEST);\n\t\t\t\t\n\t\t\tgl.colorMask(false, false, false, false);\n\t\t\tgl.stencilFunc(gl.ALWAYS,1,0xff);\n\t\t\tgl.stencilOp(gl.KEEP,gl.KEEP,gl.REPLACE);\n  \n\t\t\tPIXI.WebGLGraphics.renderGraphics(renderable.mask, projection);\n\t\t\t\n\t\t\t// we know this is a render texture so enable alpha too..\n\t\t\tgl.colorMask(true, true, true, true);\n\t\t\tgl.stencilFunc(gl.NOTEQUAL,0,0xff);\n\t\t\tgl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t}\n\t}\n}\n\n/**\n * Updates a webgl texture\n *\n * @method updateTexture\n * @param displayObject {DisplayObject}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.updateTexture = function(displayObject)\n{\n\t\n\t// TODO definitely can optimse this function..\n\t\n\tthis.removeObject(displayObject);\n\t\n\t/*\n\t *  LOOK FOR THE PREVIOUS RENDERABLE\n\t *  This part looks for the closest previous sprite that can go into a batch\n\t *  It keeps going back until it finds a sprite or the stage\n\t */\n\tvar previousRenderable = displayObject.first;\n\twhile(previousRenderable != this.root)\n\t{\n\t\tpreviousRenderable = previousRenderable._iPrev;\n\t\tif(previousRenderable.renderable && previousRenderable.__renderGroup)break;\n\t}\n\t\n\t/*\n\t *  LOOK FOR THE NEXT SPRITE\n\t *  This part looks for the closest next sprite that can go into a batch\n\t *  it keeps looking until it finds a sprite or gets to the end of the display\n\t *  scene graph\n\t */\n\tvar nextRenderable = displayObject.last;\n\twhile(nextRenderable._iNext)\n\t{\n\t\tnextRenderable = nextRenderable._iNext;\n\t\tif(nextRenderable.renderable && nextRenderable.__renderGroup)break;\n\t}\n\t\n\tthis.insertObject(displayObject, previousRenderable, nextRenderable);\n}\n\n/**\n * Adds filter blocks\n *\n * @method addFilterBlocks\n * @param start {FilterBlock}\n * @param end {FilterBlock}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.addFilterBlocks = function(start, end)\n{\n\tstart.__renderGroup = this;\n\tend.__renderGroup = this;\n\t/*\n\t *  LOOK FOR THE PREVIOUS RENDERABLE\n\t *  This part looks for the closest previous sprite that can go into a batch\n\t *  It keeps going back until it finds a sprite or the stage\n\t */\n\tvar previousRenderable = start;\n\twhile(previousRenderable != this.root)\n\t{\n\t\tpreviousRenderable = previousRenderable._iPrev;\n\t\tif(previousRenderable.renderable && previousRenderable.__renderGroup)break;\n\t}\n\tthis.insertAfter(start, previousRenderable);\n\t\t\n\t/*\n\t *  LOOK FOR THE NEXT SPRITE\n\t *  This part looks for the closest next sprite that can go into a batch\n\t *  it keeps looking until it finds a sprite or gets to the end of the display\n\t *  scene graph\n\t */\n\tvar previousRenderable2 = end;\n\twhile(previousRenderable2 != this.root)\n\t{\n\t\tpreviousRenderable2 = previousRenderable2._iPrev;\n\t\tif(previousRenderable2.renderable && previousRenderable2.__renderGroup)break;\n\t}\n\tthis.insertAfter(end, previousRenderable2);\n}\n\n/**\n * Remove filter blocks\n *\n * @method removeFilterBlocks\n * @param start {FilterBlock}\n * @param end {FilterBlock}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.removeFilterBlocks = function(start, end)\n{\n\tthis.removeObject(start);\n\tthis.removeObject(end);\n}\n\n/**\n * Adds a display object and children to the webgl context\n *\n * @method addDisplayObjectAndChildren\n * @param displayObject {DisplayObject}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.addDisplayObjectAndChildren = function(displayObject)\n{\n\tif(displayObject.__renderGroup)displayObject.__renderGroup.removeDisplayObjectAndChildren(displayObject);\n\t\n\t/*\n\t *  LOOK FOR THE PREVIOUS RENDERABLE\n\t *  This part looks for the closest previous sprite that can go into a batch\n\t *  It keeps going back until it finds a sprite or the stage\n\t */\n\t\n\tvar previousRenderable = displayObject.first;\n\twhile(previousRenderable != this.root.first)\n\t{\n\t\tpreviousRenderable = previousRenderable._iPrev;\n\t\tif(previousRenderable.renderable && previousRenderable.__renderGroup)break;\n\t}\n\t\n\t/*\n\t *  LOOK FOR THE NEXT SPRITE\n\t *  This part looks for the closest next sprite that can go into a batch\n\t *  it keeps looking until it finds a sprite or gets to the end of the display\n\t *  scene graph\n\t */\n\tvar nextRenderable = displayObject.last;\n\twhile(nextRenderable._iNext)\n\t{\n\t\tnextRenderable = nextRenderable._iNext;\n\t\tif(nextRenderable.renderable && nextRenderable.__renderGroup)break;\n\t}\n\t\n\t// one the display object hits this. we can break the loop\t\n\t\n\tvar tempObject = displayObject.first;\n\tvar testObject = displayObject.last._iNext;\n\tdo\t\n\t{\n\t\ttempObject.__renderGroup = this;\n\t\t\n\t\tif(tempObject.renderable)\n\t\t{\n\t\t\n\t\t\tthis.insertObject(tempObject, previousRenderable, nextRenderable);\n\t\t\tpreviousRenderable = tempObject;\n\t\t}\n\t\t\n\t\ttempObject = tempObject._iNext;\n\t}\n\twhile(tempObject != testObject)\n}\n\n/**\n * Removes a display object and children to the webgl context\n *\n * @method removeDisplayObjectAndChildren\n * @param displayObject {DisplayObject}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.removeDisplayObjectAndChildren = function(displayObject)\n{\n\tif(displayObject.__renderGroup != this)return;\n\t\n//\tvar displayObject = displayObject.first;\n\tvar lastObject = displayObject.last;\n\tdo\t\n\t{\n\t\tdisplayObject.__renderGroup = null;\n\t\tif(displayObject.renderable)this.removeObject(displayObject);\n\t\tdisplayObject = displayObject._iNext;\n\t}\n\twhile(displayObject)\n}\n\n/**\n * Inserts a displayObject into the linked list\n *\n * @method insertObject\n * @param displayObject {DisplayObject}\n * @param previousObject {DisplayObject}\n * @param nextObject {DisplayObject}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.insertObject = function(displayObject, previousObject, nextObject)\n{\n\t// while looping below THE OBJECT MAY NOT HAVE BEEN ADDED\n\tvar previousSprite = previousObject;\n\tvar nextSprite = nextObject;\n\t\n\t/*\n\t * so now we have the next renderable and the previous renderable\n\t * \n\t */\n\tif(displayObject instanceof PIXI.Sprite)\n\t{\n\t\tvar previousBatch\n\t\tvar nextBatch\n\t\t\n\t\tif(previousSprite instanceof PIXI.Sprite)\n\t\t{\n\t\t\tpreviousBatch = previousSprite.batch;\n\t\t\tif(previousBatch)\n\t\t\t{\n\t\t\t\tif(previousBatch.texture == displayObject.texture.baseTexture && previousBatch.blendMode == displayObject.blendMode)\n\t\t\t\t{\n\t\t\t\t\tpreviousBatch.insertAfter(displayObject, previousSprite);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// TODO reword!\n\t\t\tpreviousBatch = previousSprite;\n\t\t}\n\t\n\t\tif(nextSprite)\n\t\t{\n\t\t\tif(nextSprite instanceof PIXI.Sprite)\n\t\t\t{\n\t\t\t\tnextBatch = nextSprite.batch;\n\t\t\t\n\t\t\t\t//batch may not exist if item was added to the display list but not to the webGL\n\t\t\t\tif(nextBatch)\n\t\t\t\t{\n\t\t\t\t\tif(nextBatch.texture == displayObject.texture.baseTexture && nextBatch.blendMode == displayObject.blendMode)\n\t\t\t\t\t{\n\t\t\t\t\t\tnextBatch.insertBefore(displayObject, nextSprite);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(nextBatch == previousBatch)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// THERE IS A SPLIT IN THIS BATCH! //\n\t\t\t\t\t\t\tvar splitBatch = previousBatch.split(nextSprite);\n\t\t\t\t\t\t\t// COOL!\n\t\t\t\t\t\t\t// add it back into the array\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * OOPS!\n\t\t\t\t\t\t\t * seems the new sprite is in the middle of a batch\n\t\t\t\t\t\t\t * lets split it.. \n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tvar batch = PIXI.WebGLRenderer.getBatch();\n\n\t\t\t\t\t\t\tvar index = this.batchs.indexOf( previousBatch );\n\t\t\t\t\t\t\tbatch.init(displayObject);\n\t\t\t\t\t\t\tthis.batchs.splice(index+1, 0, batch, splitBatch);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO re-word!\n\t\t\t\t\n\t\t\t\tnextBatch = nextSprite;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t * looks like it does not belong to any batch!\n\t\t * but is also not intersecting one..\n\t\t * time to create anew one!\n\t\t */\n\t\t\n\t\tvar batch =  PIXI.WebGLRenderer.getBatch();\n\t\tbatch.init(displayObject);\n\n\t\tif(previousBatch) // if this is invalid it means \n\t\t{\n\t\t\tvar index = this.batchs.indexOf( previousBatch );\n\t\t\tthis.batchs.splice(index+1, 0, batch);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.batchs.push(batch);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\telse if(displayObject instanceof PIXI.TilingSprite)\n\t{\n\t\t\n\t\t// add to a batch!!\n\t\tthis.initTilingSprite(displayObject);\n\t//\tthis.batchs.push(displayObject);\n\t\t\n\t}\n\telse if(displayObject instanceof PIXI.Strip)\n\t{\n\t\t// add to a batch!!\n\t\tthis.initStrip(displayObject);\n\t//\tthis.batchs.push(displayObject);\n\t}\n\telse if(displayObject)// instanceof PIXI.Graphics)\n\t{\n\t\t//displayObject.initWebGL(this);\n\t\t\n\t\t// add to a batch!!\n\t\t//this.initStrip(displayObject);\n\t\t//this.batchs.push(displayObject);\n\t}\n\t\n\tthis.insertAfter(displayObject, previousSprite);\n\t\t\t\n\t// insert and SPLIT!\n\n}\n\n/**\n * Inserts a displayObject into the linked list\n *\n * @method insertAfter\n * @param item {DisplayObject}\n * @param displayObject {DisplayObject} The object to insert\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.insertAfter = function(item, displayObject)\n{\n\tif(displayObject instanceof PIXI.Sprite)\n\t{\n\t\tvar previousBatch = displayObject.batch;\n\t\t\n\t\tif(previousBatch)\n\t\t{\n\t\t\t// so this object is in a batch!\n\t\t\t\n\t\t\t// is it not? need to split the batch\n\t\t\tif(previousBatch.tail == displayObject)\n\t\t\t{\n\t\t\t\t// is it tail? insert in to batchs\t\n\t\t\t\tvar index = this.batchs.indexOf( previousBatch );\n\t\t\t\tthis.batchs.splice(index+1, 0, item);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO MODIFY ADD / REMOVE CHILD TO ACCOUNT FOR FILTERS (also get prev and next) //\n\t\t\t\t\n\t\t\t\t// THERE IS A SPLIT IN THIS BATCH! //\n\t\t\t\tvar splitBatch = previousBatch.split(displayObject.__next);\n\t\t\t\t\n\t\t\t\t// COOL!\n\t\t\t\t// add it back into the array\t\n\t\t\t\t/*\n\t\t\t\t * OOPS!\n\t\t\t\t * seems the new sprite is in the middle of a batch\n\t\t\t\t * lets split it.. \n\t\t\t\t */\n\t\t\t\tvar index = this.batchs.indexOf( previousBatch );\n\t\t\t\tthis.batchs.splice(index+1, 0, item, splitBatch);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.batchs.push(item);\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar index = this.batchs.indexOf( displayObject );\n\t\tthis.batchs.splice(index+1, 0, item);\n\t}\n}\n\n/**\n * Removes a displayObject from the linked list\n *\n * @method removeObject\n * @param displayObject {DisplayObject} The object to remove\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.removeObject = function(displayObject)\n{\n\t// loop through children..\n\t// display object //\n\t\n\t// add a child from the render group..\n\t// remove it and all its children!\n\t//displayObject.cacheVisible = false;//displayObject.visible;\n\n\t/*\n\t * removing is a lot quicker..\n\t * \n\t */\n\tvar batchToRemove;\n\t\n\tif(displayObject instanceof PIXI.Sprite)\n\t{\n\t\t// should always have a batch!\n\t\tvar batch = displayObject.batch;\n\t\tif(!batch)return; // this means the display list has been altered befre rendering\n\t\t\n\t\tbatch.remove(displayObject);\n\t\t\n\t\tif(batch.size==0)\n\t\t{\n\t\t\tbatchToRemove = batch;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbatchToRemove = displayObject;\n\t}\n\t\n\t/*\n\t * Looks like there is somthing that needs removing!\n\t */\n\tif(batchToRemove)\t\n\t{\n\t\tvar index = this.batchs.indexOf( batchToRemove );\n\t\tif(index == -1)return;// this means it was added then removed before rendered\n\t\t\n\t\t// ok so.. check to see if you adjacent batchs should be joined.\n\t\t// TODO may optimise?\n\t\tif(index == 0 || index == this.batchs.length-1)\n\t\t{\n\t\t\t// wha - eva! just get of the empty batch!\n\t\t\tthis.batchs.splice(index, 1);\n\t\t\tif(batchToRemove instanceof PIXI.WebGLBatch)PIXI.WebGLRenderer.returnBatch(batchToRemove);\n\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(this.batchs[index-1] instanceof PIXI.WebGLBatch && this.batchs[index+1] instanceof PIXI.WebGLBatch)\n\t\t{\n\t\t\tif(this.batchs[index-1].texture == this.batchs[index+1].texture && this.batchs[index-1].blendMode == this.batchs[index+1].blendMode)\n\t\t\t{\n\t\t\t\t//console.log(\"MERGE\")\n\t\t\t\tthis.batchs[index-1].merge(this.batchs[index+1]);\n\t\t\t\t\n\t\t\t\tif(batchToRemove instanceof PIXI.WebGLBatch)PIXI.WebGLRenderer.returnBatch(batchToRemove);\n\t\t\t\tPIXI.WebGLRenderer.returnBatch(this.batchs[index+1]);\n\t\t\t\tthis.batchs.splice(index, 2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.batchs.splice(index, 1);\n\t\tif(batchToRemove instanceof PIXI.WebGLBatch)PIXI.WebGLRenderer.returnBatch(batchToRemove);\n\t}\n}\n\n/**\n * Initializes a tiling sprite\n *\n * @method initTilingSprite\n * @param sprite {TilingSprite} The tiling sprite to initialize\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.initTilingSprite = function(sprite)\n{\n\tvar gl = this.gl;\n\n\t// make the texture tilable..\n\t\t\t\n\tsprite.verticies = new Float32Array([0, 0,\n\t\t\t\t\t\t\t\t\t\t  sprite.width, 0,\n\t\t\t\t\t\t\t\t\t\t  sprite.width,  sprite.height,\n\t\t\t\t\t\t\t\t\t\t 0,  sprite.height]);\n\t\t\t\t\t\n\tsprite.uvs = new Float32Array([0, 0,\n\t\t\t\t\t\t\t\t\t1, 0,\n\t\t\t\t\t\t\t\t\t1, 1,\n\t\t\t\t\t\t\t\t\t0, 1]);\n\t\t\t\t\n\tsprite.colors = new Float32Array([1,1,1,1]);\n\t\n\tsprite.indices =  new Uint16Array([0, 1, 3,2])//, 2]);\n\t\n\tsprite._vertexBuffer = gl.createBuffer();\n\tsprite._indexBuffer = gl.createBuffer();\n\tsprite._uvBuffer = gl.createBuffer();\n\tsprite._colorBuffer = gl.createBuffer();\n\t\t\t\t\t\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, sprite._vertexBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, sprite.verticies, gl.STATIC_DRAW);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, sprite._uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER,  sprite.uvs, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, sprite._colorBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, sprite.colors, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sprite._indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sprite.indices, gl.STATIC_DRAW);\n    \n//    return ( (x > 0) && ((x & (x - 1)) == 0) );\n\n\tif(sprite.texture.baseTexture._glTexture)\n\t{\n    \tgl.bindTexture(gl.TEXTURE_2D, sprite.texture.baseTexture._glTexture);\n    \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n\t\tsprite.texture.baseTexture._powerOf2 = true;\n\t}\n\telse\n\t{\n\t\tsprite.texture.baseTexture._powerOf2 = true;\n\t}\n}\n\n/**\n * Renders a Strip\n *\n * @method renderStrip\n * @param strip {Strip} The strip to render\n * @param projection {Object}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.renderStrip = function(strip, projection)\n{\n\tvar gl = this.gl;\n\tvar shaderProgram = PIXI.shaderProgram;\n//\tmat\n\t//var mat4Real = PIXI.mat3.toMat4(strip.worldTransform);\n\t//PIXI.mat4.transpose(mat4Real);\n\t//PIXI.mat4.multiply(projectionMatrix, mat4Real, mat4Real )\n\n\t\n\tgl.useProgram(PIXI.stripShaderProgram);\n\n\tvar m = PIXI.mat3.clone(strip.worldTransform);\n\t\n\tPIXI.mat3.transpose(m);\n\t\n\t// set the matrix transform for the \n \tgl.uniformMatrix3fv(PIXI.stripShaderProgram.translationMatrix, false, m);\n\tgl.uniform2f(PIXI.stripShaderProgram.projectionVector, projection.x, projection.y);\n\tgl.uniform1f(PIXI.stripShaderProgram.alpha, strip.worldAlpha);\n\n/*\n\tif(strip.blendMode == PIXI.blendModes.NORMAL)\n\t{\n\t\tgl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t}\n\telse\n\t{\n\t\tgl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);\n\t}\n\t*/\n\t\n\t\n\tif(!strip.dirty)\n\t{\n\t\t\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, strip._vertexBuffer);\n\t\tgl.bufferSubData(gl.ARRAY_BUFFER, 0, strip.verticies)\n\t    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);\n\t\t\n\t\t// update the uvs\n\t   \tgl.bindBuffer(gl.ARRAY_BUFFER, strip._uvBuffer);\n\t    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);\n\t\t\t\n\t    gl.activeTexture(gl.TEXTURE0);\n\t    gl.bindTexture(gl.TEXTURE_2D, strip.texture.baseTexture._glTexture);\n\t\t\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, strip._colorBuffer);\n\t    gl.vertexAttribPointer(shaderProgram.colorAttribute, 1, gl.FLOAT, false, 0, 0);\n\t\t\n\t\t// dont need to upload!\n\t    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, strip._indexBuffer);\n\t}\n\telse\n\t{\n\t\tstrip.dirty = false;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, strip._vertexBuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, strip.verticies, gl.STATIC_DRAW)\n\t    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);\n\t\t\n\t\t// update the uvs\n\t   \tgl.bindBuffer(gl.ARRAY_BUFFER, strip._uvBuffer);\n\t   \tgl.bufferData(gl.ARRAY_BUFFER, strip.uvs, gl.STATIC_DRAW)\n\t    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);\n\t\t\t\n\t    gl.activeTexture(gl.TEXTURE0);\n\t    gl.bindTexture(gl.TEXTURE_2D, strip.texture.baseTexture._glTexture);\n\t\t\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, strip._colorBuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, strip.colors, gl.STATIC_DRAW)\n\t    gl.vertexAttribPointer(shaderProgram.colorAttribute, 1, gl.FLOAT, false, 0, 0);\n\t\t\n\t\t// dont need to upload!\n\t    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, strip._indexBuffer);\n\t    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, strip.indices, gl.STATIC_DRAW);\n\t    \n\t}\n\t//console.log(gl.TRIANGLE_STRIP);\n\t\n\tgl.drawElements(gl.TRIANGLE_STRIP, strip.indices.length, gl.UNSIGNED_SHORT, 0);\n    \n  \tgl.useProgram(PIXI.shaderProgram);\n}\n\n/**\n * Renders a TilingSprite\n *\n * @method renderTilingSprite\n * @param sprite {TilingSprite} The tiling sprite to render\n * @param projectionMatrix {Object}\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.renderTilingSprite = function(sprite, projectionMatrix)\n{\n\tvar gl = this.gl;\n\tvar shaderProgram = PIXI.shaderProgram;\n\t\n\tvar tilePosition = sprite.tilePosition;\n\tvar tileScale = sprite.tileScale;\n\t\n\tvar offsetX =  tilePosition.x/sprite.texture.baseTexture.width;\n\tvar offsetY =  tilePosition.y/sprite.texture.baseTexture.height;\n\t\n\tvar scaleX =  (sprite.width / sprite.texture.baseTexture.width)  / tileScale.x;\n\tvar scaleY =  (sprite.height / sprite.texture.baseTexture.height) / tileScale.y;\n\n\tsprite.uvs[0] = 0 - offsetX;\n\tsprite.uvs[1] = 0 - offsetY;\n\t\n\tsprite.uvs[2] = (1 * scaleX)  -offsetX;\n\tsprite.uvs[3] = 0 - offsetY;\n\t\n\tsprite.uvs[4] = (1 *scaleX) - offsetX;\n\tsprite.uvs[5] = (1 *scaleY) - offsetY;\n\t\n\tsprite.uvs[6] = 0 - offsetX;\n\tsprite.uvs[7] = (1 *scaleY) - offsetY;\n\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, sprite._uvBuffer);\n\tgl.bufferSubData(gl.ARRAY_BUFFER, 0, sprite.uvs)\n\t\n\tthis.renderStrip(sprite, projectionMatrix);\n}\n\n/**\n * Initializes a strip to be rendered\n *\n * @method initStrip\n * @param strip {Strip} The strip to initialize\n * @private\n */\nPIXI.WebGLRenderGroup.prototype.initStrip = function(strip)\n{\n\t// build the strip!\n\tvar gl = this.gl;\n\tvar shaderProgram = this.shaderProgram;\n\t\n\tstrip._vertexBuffer = gl.createBuffer();\n\tstrip._indexBuffer = gl.createBuffer();\n\tstrip._uvBuffer = gl.createBuffer();\n\tstrip._colorBuffer = gl.createBuffer();\n\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, strip._vertexBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, strip.verticies, gl.DYNAMIC_DRAW);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, strip._uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER,  strip.uvs, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, strip._colorBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, strip.colors, gl.STATIC_DRAW);\n\n\t\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, strip._indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, strip.indices, gl.STATIC_DRAW);\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * the CanvasRenderer draws the stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Dont forget to add the view to your DOM or you will not see anything :)\n *\n * @class CanvasRenderer\n * @constructor\n * @param width=0 {Number} the width of the canvas view\n * @param height=0 {Number} the height of the canvas view\n * @param view {Canvas} the canvas to use as a view, optional\n * @param transparent=false {Boolean} the transparency of the render view, default false\n */\nPIXI.CanvasRenderer = function(width, height, view, transparent)\n{\n\tthis.transparent = transparent;\n\n\t/**\n\t * The width of the canvas view\n\t *\n\t * @property width\n\t * @type Number\n\t * @default 800\n\t */\n\tthis.width = width || 800;\n\n\t/**\n\t * The height of the canvas view\n\t *\n\t * @property height\n\t * @type Number\n\t * @default 600\n\t */\n\tthis.height = height || 600;\n\n\t/**\n\t * The canvas element that the everything is drawn to\n\t *\n\t * @property view\n\t * @type Canvas\n\t */\n\tthis.view = view || document.createElement( 'canvas' );\n\n\t/**\n\t * The canvas context that the everything is drawn to\n\t * @property context\n\t * @type Canvas 2d Context\n\t */\n\tthis.context = this.view.getContext(\"2d\");\n\n\tthis.refresh = true;\n\t// hack to enable some hardware acceleration!\n\t//this.view.style[\"transform\"] = \"translatez(0)\";\n\t\n    this.view.width = this.width;\n\tthis.view.height = this.height;  \n\tthis.count = 0;\n}\n\n// constructor\nPIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;\n\n/**\n * Renders the stage to its canvas view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.CanvasRenderer.prototype.render = function(stage)\n{\n\t\n\t//stage.__childrenAdded = [];\n\t//stage.__childrenRemoved = [];\n\t\n\t// update textures if need be\n\tPIXI.texturesToUpdate = [];\n\tPIXI.texturesToDestroy = [];\n\t\n\tPIXI.visibleCount++;\n\tstage.updateTransform();\n\t\n\t// update the background color\n\tif(this.view.style.backgroundColor!=stage.backgroundColorString && !this.transparent)this.view.style.backgroundColor = stage.backgroundColorString;\n\n\tthis.context.setTransform(1,0,0,1,0,0); \n\tthis.context.clearRect(0, 0, this.width, this.height)\n    this.renderDisplayObject(stage);\n    //as\n   \n    // run interaction!\n\tif(stage.interactive)\n\t{\n\t\t//need to add some events!\n\t\tif(!stage._interactiveEventsAdded)\n\t\t{\n\t\t\tstage._interactiveEventsAdded = true;\n\t\t\tstage.interactionManager.setTarget(this);\n\t\t}\n\t}\n\t\n\t// remove frame updates..\n\tif(PIXI.Texture.frameUpdates.length > 0)\n\t{\n\t\tPIXI.Texture.frameUpdates = [];\n\t}\n\t\n\t\n}\n\n/**\n * resizes the canvas view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas view\n * @param height {Number} the new height of the canvas view\n */\nPIXI.CanvasRenderer.prototype.resize = function(width, height)\n{\n\tthis.width = width;\n\tthis.height = height;\n\t\n\tthis.view.width = width;\n\tthis.view.height = height;\n}\n\n/**\n * Renders a display object\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The displayObject to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject)\n{\n\t// no loger recurrsive!\n\tvar transform;\n\tvar context = this.context;\n\t\n\tcontext.globalCompositeOperation = 'source-over';\n\t\n\t// one the display object hits this. we can break the loop\t\n\tvar testObject = displayObject.last._iNext;\n\tdisplayObject = displayObject.first;\n\t\n\tdo\t\n\t{\n\t\ttransform = displayObject.worldTransform;\n\t\t\n\t\tif(!displayObject.visible)\n\t\t{\n\t\t\tdisplayObject = displayObject.last._iNext;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(!displayObject.renderable)\n\t\t{\n\t\t\tdisplayObject = displayObject._iNext;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(displayObject instanceof PIXI.Sprite)\n\t\t{\n\t\t\t\t\n\t\t\tvar frame = displayObject.texture.frame;\n\t\t\t\n\t\t\tif(frame)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = displayObject.worldAlpha;\n\t\t\t\t\n\t\t\t\tcontext.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5]);\n\t\t\t\t\t\n\t\t\t\tcontext.drawImage(displayObject.texture.baseTexture.source, \n\t\t\t\t\t\t\t\t   frame.x,\n\t\t\t\t\t\t\t\t   frame.y,\n\t\t\t\t\t\t\t\t   frame.width,\n\t\t\t\t\t\t\t\t   frame.height,\n\t\t\t\t\t\t\t\t   (displayObject.anchor.x) * -frame.width, \n\t\t\t\t\t\t\t\t   (displayObject.anchor.y) * -frame.height,\n\t\t\t\t\t\t\t\t   frame.width,\n\t\t\t\t\t\t\t\t   frame.height);\n\t\t\t}\t\t\t\t\t   \n\t   \t}\n\t   \telse if(displayObject instanceof PIXI.Strip)\n\t\t{\n\t\t\tcontext.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5])\n\t\t\tthis.renderStrip(displayObject);\n\t\t}\n\t\telse if(displayObject instanceof PIXI.TilingSprite)\n\t\t{\n\t\t\tcontext.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5])\n\t\t\tthis.renderTilingSprite(displayObject);\n\t\t}\n\t\telse if(displayObject instanceof PIXI.CustomRenderable)\n\t\t{\n\t\t\tdisplayObject.renderCanvas(this);\n\t\t}\n\t\telse if(displayObject instanceof PIXI.Graphics)\n\t\t{\n\t\t\tcontext.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5])\n\t\t\tPIXI.CanvasGraphics.renderGraphics(displayObject, context);\n\t\t}\n\t\telse if(displayObject instanceof PIXI.FilterBlock)\n\t\t{\n\t\t\tif(displayObject.open)\n\t\t\t{\n\t\t\t\tcontext.save();\n\t\t\t\t\n\t\t\t\tvar cacheAlpha = displayObject.mask.alpha;\n\t\t\t\tvar maskTransform = displayObject.mask.worldTransform;\n\t\t\t\t\n\t\t\t\tcontext.setTransform(maskTransform[0], maskTransform[3], maskTransform[1], maskTransform[4], maskTransform[2], maskTransform[5])\n\t\t\t\t\n\t\t\t\tdisplayObject.mask.worldAlpha = 0.5;\n\t\t\t\t\n\t\t\t\tcontext.worldAlpha = 0;\n\t\t\t\t\n\t\t\t\tPIXI.CanvasGraphics.renderGraphicsMask(displayObject.mask, context);\n\t\t\t\tcontext.clip();\n\t\t\t\t\n\t\t\t\tdisplayObject.mask.worldAlpha = cacheAlpha;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontext.restore();\n\t\t\t}\n\t\t}\n\t//\tcount++\n\t\tdisplayObject = displayObject._iNext;\n\t\t\n\t\t\n\t}\n\twhile(displayObject != testObject)\n\n\t\n}\n\n/**\n * Renders a flat strip\n *\n * @method renderStripFlat\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderStripFlat = function(strip)\n{\n\tvar context = this.context;\n\tvar verticies = strip.verticies;\n\tvar uvs = strip.uvs;\n\t\n\tvar length = verticies.length/2;\n\tthis.count++;\n\t\n\tcontext.beginPath();\n\tfor (var i=1; i < length-2; i++) \n\t{\n\t\t\n\t\t// draw some triangles!\n\t\tvar index = i*2;\n\t\t\n\t\t var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n \t\t var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n \t\t \n\t\tcontext.moveTo(x0, y0);\n\t\tcontext.lineTo(x1, y1);\n\t\tcontext.lineTo(x2, y2);\n\t\t\n\t};\t\n\t\n\tcontext.fillStyle = \"#FF0000\";\n\tcontext.fill();\n\tcontext.closePath();\n}\n\n/**\n * Renders a tiling sprite\n *\n * @method renderTilingSprite\n * @param sprite {TilingSprite} The tilingsprite to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderTilingSprite = function(sprite)\n{\n\tvar context = this.context;\n\t\n\tcontext.globalAlpha = sprite.worldAlpha;\n\t\n \tif(!sprite.__tilePattern) sprite.__tilePattern = context.createPattern(sprite.texture.baseTexture.source, \"repeat\");\n \t\n\tcontext.beginPath();\n\t\n\tvar tilePosition = sprite.tilePosition;\n\tvar tileScale = sprite.tileScale;\n\t\n    // offset\n    context.scale(tileScale.x,tileScale.y);\n    context.translate(tilePosition.x, tilePosition.y);\n \t\n\tcontext.fillStyle = sprite.__tilePattern;\n\tcontext.fillRect(-tilePosition.x,-tilePosition.y,sprite.width / tileScale.x, sprite.height / tileScale.y);\n\t\n\tcontext.scale(1/tileScale.x, 1/tileScale.y);\n    context.translate(-tilePosition.x, -tilePosition.y);\n    \n    context.closePath();\n}\n\n/**\n * Renders a strip\n *\n * @method renderStrip\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderStrip = function(strip)\n{\n\tvar context = this.context;\n\n\t// draw triangles!!\n\tvar verticies = strip.verticies;\n\tvar uvs = strip.uvs;\n\t\n\tvar length = verticies.length/2;\n\tthis.count++;\n\tfor (var i=1; i < length-2; i++) \n\t{\n\t\t\n\t\t// draw some triangles!\n\t\tvar index = i*2;\n\t\t\n\t\t var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n \t\t var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n \t\t \n  \t\t var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;\n   \t\t var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;\n\n\n\t\tcontext.save();\n\t\tcontext.beginPath();\n\t\tcontext.moveTo(x0, y0);\n\t\tcontext.lineTo(x1, y1);\n\t\tcontext.lineTo(x2, y2);\n\t\tcontext.closePath();\n\t\t\n\t\tcontext.clip();\n\t\t\n\t\t\n        // Compute matrix transform\n        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;\n        var delta_a = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;\n        var delta_b = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;\n        var delta_c = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;\n        var delta_d = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;\n        var delta_e = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;\n        var delta_f = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;\n\t\t\n\t\t\n\t\t\n\t\t    \n        context.transform(delta_a/delta, delta_d/delta,\n                      delta_b/delta, delta_e/delta,\n                      delta_c/delta, delta_f/delta);\n                 \n\t\tcontext.drawImage(strip.texture.baseTexture.source, 0, 0);\n\t  \tcontext.restore();\n\t};\n\t\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A set of functions used by the canvas renderer to draw the primitive graphics data\n *\n * @class CanvasGraphics\n */\nPIXI.CanvasGraphics = function()\n{\n\t\n}\n\n\n/*\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics}\n * @param context {Context2D}\n */\nPIXI.CanvasGraphics.renderGraphics = function(graphics, context)\n{\n\tvar worldAlpha = graphics.worldAlpha;\n\t\n\tfor (var i=0; i < graphics.graphicsData.length; i++) \n\t{\n\t\tvar data = graphics.graphicsData[i];\n\t\tvar points = data.points;\n\t\t\n\t\tcontext.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);\n\n\t\tcontext.lineWidth = data.lineWidth;\n\t\t\n\t\tif(data.type === PIXI.Graphics.POLY)\n\t\t{\n\t\t\tcontext.beginPath();\n\t\t\t\n\t\t\tcontext.moveTo(points[0], points[1]);\n\t\t\t\n\t\t\tfor (var j=1; j < points.length/2; j++)\n\t\t\t{\n\t\t\t\tcontext.lineTo(points[j * 2], points[j * 2 + 1]);\n\t\t\t} \n\t      \t\n\t      \t// if the first and last point are the same close the path - much neater :)\n\t      \tif(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n\t      \t{\n\t      \t\tcontext.closePath();\n\t      \t}\n\t\t\t\n\t\t\tif(data.fill)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.fillAlpha * worldAlpha;\n\t\t\t\tcontext.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n      \t\t\tcontext.fill();\n\t\t\t}\n\t\t\tif(data.lineWidth)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.lineAlpha * worldAlpha;\n      \t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t\telse if(data.type === PIXI.Graphics.RECT)\n\t\t{\n\t\t\t\t\n\t\t\t// TODO - need to be Undefined!\n\t\t\tif(data.fillColor != undefined)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.fillAlpha * worldAlpha;\n\t\t\t\tcontext.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n\t\t\t\tcontext.fillRect(points[0], points[1], points[2], points[3]);\n\t\t\t\t\n\t\t\t}\n\t\t\tif(data.lineWidth)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.lineAlpha * worldAlpha;\n\t\t\t\tcontext.strokeRect(points[0], points[1], points[2], points[3]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.CIRC)\n\t\t{\n\t\t\t// TODO - need to be Undefined!\n      \t\tcontext.beginPath();\n\t\t\tcontext.arc(points[0], points[1], points[2],0,2*Math.PI);\n\t\t\tcontext.closePath();\n\t\t\t\n\t\t\tif(data.fill)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.fillAlpha * worldAlpha;\n\t\t\t\tcontext.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n      \t\t\tcontext.fill();\n\t\t\t}\n\t\t\tif(data.lineWidth)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.lineAlpha * worldAlpha;\n      \t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.ELIP)\n\t\t{\n\t\t\t\n\t\t\t// elipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\t\t\t\n\t\t\tvar elipseData =  data.points;\n\t\t\t\n\t\t\tvar w = elipseData[2] * 2;\n\t\t\tvar h = elipseData[3] * 2;\n\t\n\t\t\tvar x = elipseData[0] - w/2;\n\t\t\tvar y = elipseData[1] - h/2;\n\t\t\t\n      \t\tcontext.beginPath();\n\t\t\t\n\t\t\tvar kappa = .5522848,\n\t\t\tox = (w / 2) * kappa, // control point offset horizontal\n\t\t\toy = (h / 2) * kappa, // control point offset vertical\n\t\t\txe = x + w,           // x-end\n\t\t\tye = y + h,           // y-end\n\t\t\txm = x + w / 2,       // x-middle\n\t\t\tym = y + h / 2;       // y-middle\n\t\t\t\n\t\t\tcontext.moveTo(x, ym);\n\t\t\tcontext.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n\t\t\tcontext.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n\t\t\tcontext.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n\t\t\tcontext.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  \n\t\t\tcontext.closePath();\n\t\t\t\n\t\t\tif(data.fill)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.fillAlpha * worldAlpha;\n\t\t\t\tcontext.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n      \t\t\tcontext.fill();\n\t\t\t}\n\t\t\tif(data.lineWidth)\n\t\t\t{\n\t\t\t\tcontext.globalAlpha = data.lineAlpha * worldAlpha;\n      \t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n      \t\n\t};\n}\n\n/*\n * Renders a graphics mask\n *\n * @static\n * @private\n * @method renderGraphicsMask\n * @param graphics {Graphics}\n * @param context {Context2D}\n */\nPIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)\n{\n\tvar worldAlpha = graphics.worldAlpha;\n\t\n\tvar len = graphics.graphicsData.length;\n\tif(len > 1)\n\t{\n\t\tlen = 1;\n\t\tconsole.log(\"Pixi.js warning: masks in canvas can only mask using the first path in the graphics object\")\n\t}\n\t\n\tfor (var i=0; i < 1; i++) \n\t{\n\t\tvar data = graphics.graphicsData[i];\n\t\tvar points = data.points;\n\t\t\n\t\tif(data.type == PIXI.Graphics.POLY)\n\t\t{\n\t\t\tcontext.beginPath();\n\t\t\tcontext.moveTo(points[0], points[1]);\n\t\t\t\n\t\t\tfor (var j=1; j < points.length/2; j++)\n\t\t\t{\n\t\t\t\tcontext.lineTo(points[j * 2], points[j * 2 + 1]);\n\t\t\t} \n\t      \t\n\t      \t// if the first and last point are the same close the path - much neater :)\n\t      \tif(points[0] == points[points.length-2] && points[1] == points[points.length-1])\n\t      \t{\n\t      \t\tcontext.closePath();\n\t      \t}\n\t\t\t\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.RECT)\n\t\t{\n\t\t\tcontext.beginPath();\n\t\t\tcontext.rect(points[0], points[1], points[2], points[3]);\n\t\t\tcontext.closePath();\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.CIRC)\n\t\t{\n\t\t\t// TODO - need to be Undefined!\n      \t\tcontext.beginPath();\n\t\t\tcontext.arc(points[0], points[1], points[2],0,2*Math.PI);\n\t\t\tcontext.closePath();\n\t\t}\n\t\telse if(data.type == PIXI.Graphics.ELIP)\n\t\t{\n\t\t\t\n\t\t\t// elipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\t\t\tvar elipseData =  data.points;\n\t\t\t\n\t\t\tvar w = elipseData[2] * 2;\n\t\t\tvar h = elipseData[3] * 2;\n\t\n\t\t\tvar x = elipseData[0] - w/2;\n\t\t\tvar y = elipseData[1] - h/2;\n\t\t\t\n      \t\tcontext.beginPath();\n\t\t\t\n\t\t\tvar kappa = .5522848,\n\t\t\tox = (w / 2) * kappa, // control point offset horizontal\n\t\t\toy = (h / 2) * kappa, // control point offset vertical\n\t\t\txe = x + w,           // x-end\n\t\t\tye = y + h,           // y-end\n\t\t\txm = x + w / 2,       // x-middle\n\t\t\tym = y + h / 2;       // y-middle\n\t\t\t\n\t\t\tcontext.moveTo(x, ym);\n\t\t\tcontext.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n\t\t\tcontext.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n\t\t\tcontext.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n\t\t\tcontext.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\t\t\tcontext.closePath();\n\t\t}\n      \t\n\t   \n\t};\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * The Graphics class contains a set of methods that you can use to create primitive shapes and lines. \n * It is important to know that with the webGL renderer only simple polys can be filled at this stage\n * Complex polys will not be filled. Heres an example of a complex poly: http://www.goodboydigital.com/wp-content/uploads/2013/06/complexPolygon.png\n *\n * @class Graphics \n * @extends DisplayObjectContainer\n * @constructor\n */\nPIXI.Graphics = function()\n{\n\tPIXI.DisplayObjectContainer.call( this );\n\t\n\tthis.renderable = true;\n\n    /**\n     * The alpha of the fill of this graphics object\n     *\n     * @property fillAlpha\n     * @type Number\n     */\n\tthis.fillAlpha = 1;\n\n    /**\n     * The width of any lines drawn\n     *\n     * @property lineWidth\n     * @type Number\n     */\n\tthis.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn\n     *\n     * @property lineColor\n     * @type String\n     */\n\tthis.lineColor = \"black\";\n\n    /**\n     * Graphics data\n     *\n     * @property graphicsData\n     * @type Array\n     * @private\n     */\n\tthis.graphicsData = [];\n\n    /**\n     * Current path\n     *\n     * @property currentPath\n     * @type Object\n     * @private\n     */\n\tthis.currentPath = {points:[]};\n}\n\n// constructor\nPIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Graphics.prototype.constructor = PIXI.Graphics;\n\n/**\n * Specifies a line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @method lineStyle\n * @param lineWidth {Number} width of the line to draw, will update the object's stored style\n * @param color {Number} color of the line to draw, will update the object's stored style\n * @param alpha {Number} alpha of the line to draw, will update the object's stored style\n */\nPIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)\n{\n\tif(this.currentPath.points.length == 0)this.graphicsData.pop();\n\t\n\tthis.lineWidth = lineWidth || 0;\n\tthis.lineColor = color || 0;\n\tthis.lineAlpha = (alpha == undefined) ? 1 : alpha;\n\t\n\tthis.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha, \n\t\t\t\t\t\tfillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};\n\t\n\tthis.graphicsData.push(this.currentPath);\n}\n\n/**\n * Moves the current drawing position to (x, y).\n *\n * @method moveTo\n * @param x {Number} the X coord to move to\n * @param y {Number} the Y coord to move to\n */\nPIXI.Graphics.prototype.moveTo = function(x, y)\n{\n\tif(this.currentPath.points.length == 0)this.graphicsData.pop();\n\t\n\tthis.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha, \n\t\t\t\t\t\tfillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};\n\t\n\tthis.currentPath.points.push(x, y);\n\t\n\tthis.graphicsData.push(this.currentPath);\n}\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * the current drawing position is then set to (x, y).\n *\n * @method lineTo\n * @param x {Number} the X coord to draw to\n * @param y {Number} the Y coord to draw to\n */\nPIXI.Graphics.prototype.lineTo = function(x, y)\n{\n\tthis.currentPath.points.push(x, y);\n\tthis.dirty = true;\n}\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @method beginFill\n * @param color {uint} the color of the fill\n * @param alpha {Number} the alpha\n */\nPIXI.Graphics.prototype.beginFill = function(color, alpha)\n{\n\tthis.filling = true;\n\tthis.fillColor = color || 0;\n\tthis.fillAlpha = (alpha == undefined) ? 1 : alpha;\n}\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @method endFill\n */\nPIXI.Graphics.prototype.endFill = function()\n{\n\tthis.filling = false;\n\tthis.fillColor = null;\n\tthis.fillAlpha = 1;\n}\n\n/**\n * @method drawRect\n *\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n */\nPIXI.Graphics.prototype.drawRect = function( x, y, width, height )\n{\n\tif(this.currentPath.points.length == 0)this.graphicsData.pop();\n\t\n\tthis.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha, \n\t\t\t\t\t\tfillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, \n\t\t\t\t\t\tpoints:[x, y, width, height], type:PIXI.Graphics.RECT};\n\t\t\t\t\t\t\n\tthis.graphicsData.push(this.currentPath);\n\tthis.dirty = true;\n}\n\n/**\n * Draws a circle.\n *\n * @method drawCircle\n * @param x {Number} The X coord of the center of the circle\n * @param y {Number} The Y coord of the center of the circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Graphics.prototype.drawCircle = function( x, y, radius)\n{\n\tif(this.currentPath.points.length == 0)this.graphicsData.pop();\n\t\n\tthis.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha, \n\t\t\t\t\t\tfillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, \n\t\t\t\t\t\tpoints:[x, y, radius, radius], type:PIXI.Graphics.CIRC};\n\t\t\t\t\t\t\n\tthis.graphicsData.push(this.currentPath);\n\tthis.dirty = true;\n}\n\n/**\n * Draws an elipse.\n *\n * @method drawElipse\n * @param x {Number}\n * @param y {Number}\n * @param width {Number}\n * @param height {Number}\n */\nPIXI.Graphics.prototype.drawElipse = function( x, y, width, height)\n{\n\tif(this.currentPath.points.length == 0)this.graphicsData.pop();\n\t\n\tthis.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha, \n\t\t\t\t\t\tfillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, \n\t\t\t\t\t\tpoints:[x, y, width, height], type:PIXI.Graphics.ELIP};\n\t\t\t\t\t\t\n\tthis.graphicsData.push(this.currentPath);\n\tthis.dirty = true;\n}\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @method clear\n */\nPIXI.Graphics.prototype.clear = function()\n{\n\tthis.lineWidth = 0;\n\tthis.filling = false;\n\t\n\tthis.dirty = true;\n\tthis.clearDirty = true;\n\tthis.graphicsData = [];\n}\n\n// SOME TYPES:\nPIXI.Graphics.POLY = 0;\nPIXI.Graphics.RECT = 1;\nPIXI.Graphics.CIRC = 2;\nPIXI.Graphics.ELIP = 3;\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\nPIXI.Strip = function(texture, width, height)\n{\n\tPIXI.DisplayObjectContainer.call( this );\n\tthis.texture = texture;\n\tthis.blendMode = PIXI.blendModes.NORMAL;\n\t\n\ttry\n\t{\n\t\tthis.uvs = new Float32Array([0, 1,\n\t\t\t\t1, 1,\n\t\t\t\t1, 0, 0,1]);\n\t\n\t\tthis.verticies = new Float32Array([0, 0,\n\t\t\t\t\t\t  0,0,\n\t\t\t\t\t\t  0,0, 0,\n\t\t\t\t\t\t  0, 0]);\n\t\t\t\t\t\t  \n\t\tthis.colors = new Float32Array([1, 1, 1, 1]);\n\t\t\n\t\tthis.indices = new Uint16Array([0, 1, 2, 3]);\n\t}\n\tcatch(error)\n\t{\n\t\tthis.uvs = [0, 1,\n\t\t\t\t1, 1,\n\t\t\t\t1, 0, 0,1];\n\t\n\t\tthis.verticies = [0, 0,\n\t\t\t\t\t\t  0,0,\n\t\t\t\t\t\t  0,0, 0,\n\t\t\t\t\t\t  0, 0];\n\t\t\t\t\t\t  \n\t\tthis.colors = [1, 1, 1, 1];\n\t\t\n\t\tthis.indices = [0, 1, 2, 3];\n\t}\n\t\n\t\n\t/*\n\tthis.uvs = new Float32Array()\n\tthis.verticies = new Float32Array()\n\tthis.colors = new Float32Array()\n\tthis.indices = new Uint16Array()\n*/\n\tthis.width = width;\n\tthis.height = height;\n\t\n\t// load the texture!\n\tif(texture.baseTexture.hasLoaded)\n\t{\n\t\tthis.width   = this.texture.frame.width;\n\t\tthis.height  = this.texture.frame.height;\n\t\tthis.updateFrame = true;\n\t}\n\telse\n\t{\n\t\tthis.onTextureUpdateBind = this.onTextureUpdate.bind(this);\n\t\tthis.texture.addEventListener( 'update', this.onTextureUpdateBind );\n\t}\n\t\n\tthis.renderable = true;\n}\n\n// constructor\nPIXI.Strip.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Strip.prototype.constructor = PIXI.Strip;\n\nPIXI.Strip.prototype.setTexture = function(texture)\n{\n\t//TODO SET THE TEXTURES\n\t//TODO VISIBILITY\n\t\n\t// stop current texture \n\tthis.texture = texture;\n\tthis.width   = texture.frame.width;\n\tthis.height  = texture.frame.height;\n\tthis.updateFrame = true;\n}\n\nPIXI.Strip.prototype.onTextureUpdate = function(event)\n{\n\tthis.updateFrame = true;\n}\n// some helper functions..\n\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n\nPIXI.Rope = function(texture, points)\n{\n\tPIXI.Strip.call( this, texture );\n\tthis.points = points;\n\t\n\ttry\n\t{\n\t\tthis.verticies = new Float32Array( points.length * 4);\n\t\tthis.uvs = new Float32Array( points.length * 4);\n\t\tthis.colors = new Float32Array(  points.length * 2);\n\t\tthis.indices = new Uint16Array( points.length * 2);\n\t}\n\tcatch(error)\n\t{\n\t\tthis.verticies = verticies\n\t\t\n\t\tthis.uvs = uvs\n\t\tthis.colors = colors\n\t\tthis.indices = indices\n\t}\n\t\n\tthis.refresh();\n}\n\n\n// constructor\nPIXI.Rope.prototype = Object.create( PIXI.Strip.prototype );\nPIXI.Rope.prototype.constructor = PIXI.Rope;\n\nPIXI.Rope.prototype.refresh = function()\n{\n\tvar points = this.points;\n\tif(points.length < 1)return;\n\t\n\tvar uvs = this.uvs\n\tvar indices = this.indices;\n\tvar colors = this.colors;\n\t\n\tvar lastPoint = points[0];\n\tvar nextPoint;\n\tvar perp = {x:0, y:0};\n\tvar point = points[0];\n\t\n\tthis.count-=0.2;\n\t\n\t\n\tuvs[0] = 0\n\tuvs[1] = 1\n\tuvs[2] = 0\n\tuvs[3] = 1\n\t\n\tcolors[0] = 1;\n\tcolors[1] = 1;\n\t\n\tindices[0] = 0;\n\tindices[1] = 1;\n\t\n\tvar total = points.length;\n\t\t\n\tfor (var i =  1; i < total; i++) \n\t{\n\t\t\n\t\tvar point = points[i];\n\t\tvar index = i * 4;\n\t\t// time to do some smart drawing!\n\t\tvar amount = i/(total-1)\n\t\t\n\t\tif(i%2)\n\t\t{\n\t\t\tuvs[index] = amount;\n\t\t\tuvs[index+1] = 0;\n\t\t\t\n\t\t\tuvs[index+2] = amount\n\t\t\tuvs[index+3] = 1\n\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuvs[index] = amount\n\t\t\tuvs[index+1] = 0\n\t\t\t\n\t\t\tuvs[index+2] = amount\n\t\t\tuvs[index+3] = 1\n\t\t}\n\t\t\n\t\tindex = i * 2;\n\t\tcolors[index] = 1;\n\t\tcolors[index+1] = 1;\n\t\t\n\t\tindex = i * 2;\n\t\tindices[index] = index;\n\t\tindices[index + 1] = index + 1;\n\t\t\n\t\tlastPoint = point;\n\t}\n}\n\nPIXI.Rope.prototype.updateTransform = function()\n{\n\t\n\tvar points = this.points;\n\tif(points.length < 1)return;\n\t\n\tvar verticies = this.verticies \n\t\n\tvar lastPoint = points[0];\n\tvar nextPoint;\n\tvar perp = {x:0, y:0};\n\tvar point = points[0];\n\t\n\tthis.count-=0.2;\n\t\n\tverticies[0] = point.x + perp.x \n\tverticies[1] = point.y + perp.y //+ 200\n\tverticies[2] = point.x - perp.x \n\tverticies[3] = point.y - perp.y//+200\n\t// time to do some smart drawing!\n\t\n\tvar total = points.length;\n\t\t\n\tfor (var i =  1; i < total; i++) \n\t{\n\t\t\n\t\tvar point = points[i];\n\t\tvar index = i * 4;\n\t\t\n\t\tif(i < points.length-1)\n\t\t{\n\t\t\tnextPoint = points[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextPoint = point\n\t\t}\n\t\t\n\t\tperp.y = -(nextPoint.x - lastPoint.x);\n\t\tperp.x = nextPoint.y - lastPoint.y;\n\t\t\n\t\tvar ratio = (1 - (i / (total-1))) * 10;\n\t\t\t\tif(ratio > 1)ratio = 1;\n\t\t\t\t\n\t\tvar perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);\n\t\tvar num = this.texture.height/2//(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\t\tperp.x /= perpLength;\n\t\tperp.y /= perpLength;\n\t\n\t\tperp.x *= num;\n\t\tperp.y *= num;\n\t\t\n\t\tverticies[index] = point.x + perp.x \n\t\tverticies[index+1] = point.y + perp.y\n\t\tverticies[index+2] = point.x - perp.x \n\t\tverticies[index+3] = point.y - perp.y\n\n\t\tlastPoint = point;\n\t}\n\t\n\tPIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n}\n\nPIXI.Rope.prototype.setTexture = function(texture)\n{\n\t// stop current texture \n\tthis.texture = texture;\n\tthis.updateFrame = true;\n}\n\n\n\n\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class TilingSprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {Number}  the width of the tiling sprite\n * @param height {Number} the height of the tiling sprite\n */\nPIXI.TilingSprite = function(texture, width, height)\n{\n\tPIXI.DisplayObjectContainer.call( this );\n\n\t/**\n\t * The texture that the sprite is using\n\t *\n\t * @property texture\n\t * @type Texture\n\t */\n\tthis.texture = texture;\n\n\t/**\n\t * The width of the tiling sprite\n\t *\n\t * @property width\n\t * @type Number\n\t */\n\tthis.width = width;\n\n\t/**\n\t * The height of the tiling sprite\n\t *\n\t * @property height\n\t * @type Number\n\t */\n\tthis.height = height;\n\n\t/**\n\t * The scaling of the image that is being tiled\n\t *\n\t * @property tileScale\n\t * @type Point\n\t */\t\n\tthis.tileScale = new PIXI.Point(1,1);\n\n\t/**\n\t * The offset position of the image that is being tiled\n\t *\n\t * @property tilePosition\n\t * @type Point\n\t */\t\n\tthis.tilePosition = new PIXI.Point(0,0);\n\n\tthis.renderable = true;\n\t\n\tthis.blendMode = PIXI.blendModes.NORMAL\n}\n\n// constructor\nPIXI.TilingSprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;\n\n/**\n * Sets the texture of the tiling sprite\n *\n * @method setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n */\nPIXI.TilingSprite.prototype.setTexture = function(texture)\n{\n\t//TODO SET THE TEXTURES\n\t//TODO VISIBILITY\n\t\n\t// stop current texture \n\tthis.texture = texture;\n\tthis.updateFrame = true;\n}\n\n/**\n * When the texture is updated, this event will fire to update the frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.TilingSprite.prototype.onTextureUpdate = function(event)\n{\n\tthis.updateFrame = true;\n}\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi\n *\n * Awesome JS run time provided by EsotericSoftware\n * https://github.com/EsotericSoftware/spine-runtimes\n *\n */\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * Spine animation data needs to be loaded using the PIXI.AssetLoader or PIXI.SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * @class Spine\n * @extends DisplayObjectContainer\n * @constructor\n * @param url {String} The url of the spine anim file to be used\n */\nPIXI.Spine = function (url) {\n\tPIXI.DisplayObjectContainer.call(this);\n\n\tthis.spineData = PIXI.AnimCache[url];\n\n\tif (!this.spineData) {\n\t\tthrow new Error(\"Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: \" + url);\n\t}\n\n\tthis.skeleton = new spine.Skeleton(this.spineData);\n\tthis.skeleton.updateWorldTransform();\n\n\tthis.stateData = new spine.AnimationStateData(this.spineData);\n\tthis.state = new spine.AnimationState(this.stateData);\n\n\tthis.slotContainers = [];\n\n\tfor (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {\n\t\tvar slot = this.skeleton.drawOrder[i];\n\t\tvar attachment = slot.attachment;\n\t\tvar slotContainer = new PIXI.DisplayObjectContainer();\n\t\tthis.slotContainers.push(slotContainer);\n\t\tthis.addChild(slotContainer);\n\t\tif (!(attachment instanceof spine.RegionAttachment)) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar spriteName = attachment.rendererObject.name;\n\t\tvar sprite = this.createSprite(slot, attachment.rendererObject);\n\t\tslot.currentSprite = sprite;\n\t\tslot.currentSpriteName = spriteName;\n\t\tslotContainer.addChild(sprite);\n\t}\n};\n\nPIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Spine.prototype.constructor = PIXI.Spine;\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Spine.prototype.updateTransform = function () {\n\tthis.lastTime = this.lastTime || Date.now();\n\tvar timeDelta = (Date.now() - this.lastTime) * 0.001;\n\tthis.lastTime = Date.now();\n\tthis.state.update(timeDelta);\n\tthis.state.apply(this.skeleton);\n\tthis.skeleton.updateWorldTransform();\n\n\tvar drawOrder = this.skeleton.drawOrder;\n\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\n\t\tvar slot = drawOrder[i];\n\t\tvar attachment = slot.attachment;\n\t\tvar slotContainer = this.slotContainers[i];\n\t\tif (!(attachment instanceof spine.RegionAttachment)) {\n\t\t\tslotContainer.visible = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (attachment.rendererObject) {\n\t\t\tif (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {\n\t\t\t\tvar spriteName = attachment.rendererObject.name;\n\t\t\t\tif (slot.currentSprite !== undefined) {\n\t\t\t\t\tslot.currentSprite.visible = false;\n\t\t\t\t}\n\t\t\t\tslot.sprites = slot.sprites || {};\n\t\t\t\tif (slot.sprites[spriteName] !== undefined) {\n\t\t\t\t\tslot.sprites[spriteName].visible = true;\n\t\t\t\t} else {\n\t\t\t\t\tvar sprite = this.createSprite(slot, attachment.rendererObject);\n\t\t\t\t\tslotContainer.addChild(sprite);\n\t\t\t\t}\n\t\t\t\tslot.currentSprite = slot.sprites[spriteName];\n\t\t\t\tslot.currentSpriteName = spriteName;\n\t\t\t}\n\t\t}\n\t\tslotContainer.visible = true;\n\n\t\tvar bone = slot.bone;\n\n\t\tslotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\n\t\tslotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\n\t\tslotContainer.scale.x = bone.worldScaleX;\n\t\tslotContainer.scale.y = bone.worldScaleY;\n\n\t\tslotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);\n\t}\n\n\tPIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\n\nPIXI.Spine.prototype.createSprite = function (slot, descriptor) {\n\tvar name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + \".png\";\n\tvar sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));\n\tsprite.scale = descriptor.scale;\n\tsprite.rotation = descriptor.rotation;\n\tsprite.anchor.x = sprite.anchor.y = 0.5;\n\n\tslot.sprites = slot.sprites || {};\n\tslot.sprites[descriptor.name] = sprite;\n\treturn sprite;\n};\n\n/*\n * Awesome JS run time provided by EsotericSoftware\n * \n * https://github.com/EsotericSoftware/spine-runtimes\n * \n */\n\nvar spine = {};\n\nspine.BoneData = function (name, parent) {\n\tthis.name = name;\n\tthis.parent = parent;\n};\nspine.BoneData.prototype = {\n\tlength: 0,\n\tx: 0, y: 0,\n\trotation: 0,\n\tscaleX: 1, scaleY: 1\n};\n\nspine.SlotData = function (name, boneData) {\n\tthis.name = name;\n\tthis.boneData = boneData;\n};\nspine.SlotData.prototype = {\n\tr: 1, g: 1, b: 1, a: 1,\n\tattachmentName: null\n};\n\nspine.Bone = function (boneData, parent) {\n\tthis.data = boneData;\n\tthis.parent = parent;\n\tthis.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n\tx: 0, y: 0,\n\trotation: 0,\n\tscaleX: 1, scaleY: 1,\n\tm00: 0, m01: 0, worldX: 0, // a b x\n\tm10: 0, m11: 0, worldY: 0, // c d y\n\tworldRotation: 0,\n\tworldScaleX: 1, worldScaleY: 1,\n\tupdateWorldTransform: function (flipX, flipY) {\n\t\tvar parent = this.parent;\n\t\tif (parent != null) {\n\t\t\tthis.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\n\t\t\tthis.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\n\t\t\tthis.worldScaleX = parent.worldScaleX * this.scaleX;\n\t\t\tthis.worldScaleY = parent.worldScaleY * this.scaleY;\n\t\t\tthis.worldRotation = parent.worldRotation + this.rotation;\n\t\t} else {\n\t\t\tthis.worldX = this.x;\n\t\t\tthis.worldY = this.y;\n\t\t\tthis.worldScaleX = this.scaleX;\n\t\t\tthis.worldScaleY = this.scaleY;\n\t\t\tthis.worldRotation = this.rotation;\n\t\t}\n\t\tvar radians = this.worldRotation * Math.PI / 180;\n\t\tvar cos = Math.cos(radians);\n\t\tvar sin = Math.sin(radians);\n\t\tthis.m00 = cos * this.worldScaleX;\n\t\tthis.m10 = sin * this.worldScaleX;\n\t\tthis.m01 = -sin * this.worldScaleY;\n\t\tthis.m11 = cos * this.worldScaleY;\n\t\tif (flipX) {\n\t\t\tthis.m00 = -this.m00;\n\t\t\tthis.m01 = -this.m01;\n\t\t}\n\t\tif (flipY) {\n\t\t\tthis.m10 = -this.m10;\n\t\t\tthis.m11 = -this.m11;\n\t\t}\n\t\tif (spine.Bone.yDown) {\n\t\t\tthis.m10 = -this.m10;\n\t\t\tthis.m11 = -this.m11;\n\t\t}\n\t},\n\tsetToSetupPose: function () {\n\t\tvar data = this.data;\n\t\tthis.x = data.x;\n\t\tthis.y = data.y;\n\t\tthis.rotation = data.rotation;\n\t\tthis.scaleX = data.scaleX;\n\t\tthis.scaleY = data.scaleY;\n\t}\n};\n\nspine.Slot = function (slotData, skeleton, bone) {\n\tthis.data = slotData;\n\tthis.skeleton = skeleton;\n\tthis.bone = bone;\n\tthis.setToSetupPose();\n};\nspine.Slot.prototype = {\n\tr: 1, g: 1, b: 1, a: 1,\n\t_attachmentTime: 0,\n\tattachment: null,\n\tsetAttachment: function (attachment) {\n\t\tthis.attachment = attachment;\n\t\tthis._attachmentTime = this.skeleton.time;\n\t},\n\tsetAttachmentTime: function (time) {\n\t\tthis._attachmentTime = this.skeleton.time - time;\n\t},\n\tgetAttachmentTime: function () {\n\t\treturn this.skeleton.time - this._attachmentTime;\n\t},\n\tsetToSetupPose: function () {\n\t\tvar data = this.data;\n\t\tthis.r = data.r;\n\t\tthis.g = data.g;\n\t\tthis.b = data.b;\n\t\tthis.a = data.a;\n\n\t\tvar slotDatas = this.skeleton.data.slots;\n\t\tfor (var i = 0, n = slotDatas.length; i < n; i++) {\n\t\t\tif (slotDatas[i] == data) {\n\t\t\t\tthis.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\nspine.Skin = function (name) {\n\tthis.name = name;\n\tthis.attachments = {};\n};\nspine.Skin.prototype = {\n\taddAttachment: function (slotIndex, name, attachment) {\n\t\tthis.attachments[slotIndex + \":\" + name] = attachment;\n\t},\n\tgetAttachment: function (slotIndex, name) {\n\t\treturn this.attachments[slotIndex + \":\" + name];\n\t},\n\t_attachAll: function (skeleton, oldSkin) {\n\t\tfor (var key in oldSkin.attachments) {\n\t\t\tvar colon = key.indexOf(\":\");\n\t\t\tvar slotIndex = parseInt(key.substring(0, colon));\n\t\t\tvar name = key.substring(colon + 1);\n\t\t\tvar slot = skeleton.slots[slotIndex];\n\t\t\tif (slot.attachment && slot.attachment.name == name) {\n\t\t\t\tvar attachment = this.getAttachment(slotIndex, name);\n\t\t\t\tif (attachment) slot.setAttachment(attachment);\n\t\t\t}\n\t\t}\n\t}\n};\n\nspine.Animation = function (name, timelines, duration) {\n\tthis.name = name;\n\tthis.timelines = timelines;\n\tthis.duration = duration;\n};\nspine.Animation.prototype = {\n\tapply: function (skeleton, time, loop) {\n\t\tif (loop && this.duration != 0) time %= this.duration;\n\t\tvar timelines = this.timelines;\n\t\tfor (var i = 0, n = timelines.length; i < n; i++)\n\t\t\ttimelines[i].apply(skeleton, time, 1);\n\t},\n\tmix: function (skeleton, time, loop, alpha) {\n\t\tif (loop && this.duration != 0) time %= this.duration;\n\t\tvar timelines = this.timelines;\n\t\tfor (var i = 0, n = timelines.length; i < n; i++)\n\t\t\ttimelines[i].apply(skeleton, time, alpha);\n\t}\n};\n\nspine.binarySearch = function (values, target, step) {\n\tvar low = 0;\n\tvar high = Math.floor(values.length / step) - 2;\n\tif (high == 0) return step;\n\tvar current = high >>> 1;\n\twhile (true) {\n\t\tif (values[(current + 1) * step] <= target)\n\t\t\tlow = current + 1;\n\t\telse\n\t\t\thigh = current;\n\t\tif (low == high) return (low + 1) * step;\n\t\tcurrent = (low + high) >>> 1;\n\t}\n};\nspine.linearSearch = function (values, target, step) {\n\tfor (var i = 0, last = values.length - step; i <= last; i += step)\n\t\tif (values[i] > target) return i;\n\treturn -1;\n};\n\nspine.Curves = function (frameCount) {\n\tthis.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...\n\tthis.curves.length = (frameCount - 1) * 6;\n};\nspine.Curves.prototype = {\n\tsetLinear: function (frameIndex) {\n\t\tthis.curves[frameIndex * 6] = 0/*LINEAR*/;\n\t},\n\tsetStepped: function (frameIndex) {\n\t\tthis.curves[frameIndex * 6] = -1/*STEPPED*/;\n\t},\n\t/** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n\t * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n\t * the difference between the keyframe's values. */\n\tsetCurve: function (frameIndex, cx1, cy1, cx2, cy2) {\n\t\tvar subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;\n\t\tvar subdiv_step2 = subdiv_step * subdiv_step;\n\t\tvar subdiv_step3 = subdiv_step2 * subdiv_step;\n\t\tvar pre1 = 3 * subdiv_step;\n\t\tvar pre2 = 3 * subdiv_step2;\n\t\tvar pre4 = 6 * subdiv_step2;\n\t\tvar pre5 = 6 * subdiv_step3;\n\t\tvar tmp1x = -cx1 * 2 + cx2;\n\t\tvar tmp1y = -cy1 * 2 + cy2;\n\t\tvar tmp2x = (cx1 - cx2) * 3 + 1;\n\t\tvar tmp2y = (cy1 - cy2) * 3 + 1;\n\t\tvar i = frameIndex * 6;\n\t\tvar curves = this.curves;\n\t\tcurves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\n\t\tcurves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\n\t\tcurves[i + 2] = tmp1x * pre4 + tmp2x * pre5;\n\t\tcurves[i + 3] = tmp1y * pre4 + tmp2y * pre5;\n\t\tcurves[i + 4] = tmp2x * pre5;\n\t\tcurves[i + 5] = tmp2y * pre5;\n\t},\n\tgetCurvePercent: function (frameIndex, percent) {\n\t\tpercent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\n\t\tvar curveIndex = frameIndex * 6;\n\t\tvar curves = this.curves;\n\t\tvar dfx = curves[curveIndex];\n\t\tif (!dfx/*LINEAR*/) return percent;\n\t\tif (dfx == -1/*STEPPED*/) return 0;\n\t\tvar dfy = curves[curveIndex + 1];\n\t\tvar ddfx = curves[curveIndex + 2];\n\t\tvar ddfy = curves[curveIndex + 3];\n\t\tvar dddfx = curves[curveIndex + 4];\n\t\tvar dddfy = curves[curveIndex + 5];\n\t\tvar x = dfx, y = dfy;\n\t\tvar i = 10/*BEZIER_SEGMENTS*/ - 2;\n\t\twhile (true) {\n\t\t\tif (x >= percent) {\n\t\t\t\tvar lastX = x - dfx;\n\t\t\t\tvar lastY = y - dfy;\n\t\t\t\treturn lastY + (y - lastY) * (percent - lastX) / (x - lastX);\n\t\t\t}\n\t\t\tif (i == 0) break;\n\t\t\ti--;\n\t\t\tdfx += ddfx;\n\t\t\tdfy += ddfy;\n\t\t\tddfx += dddfx;\n\t\t\tddfy += dddfy;\n\t\t\tx += dfx;\n\t\t\ty += dfy;\n\t\t}\n\t\treturn y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n\t}\n};\n\nspine.RotateTimeline = function (frameCount) {\n\tthis.curves = new spine.Curves(frameCount);\n\tthis.frames = []; // time, angle, ...\n\tthis.frames.length = frameCount * 2;\n};\nspine.RotateTimeline.prototype = {\n\tboneIndex: 0,\n\tgetFrameCount: function () {\n\t\treturn this.frames.length / 2;\n\t},\n\tsetFrame: function (frameIndex, time, angle) {\n\t\tframeIndex *= 2;\n\t\tthis.frames[frameIndex] = time;\n\t\tthis.frames[frameIndex + 1] = angle;\n\t},\n\tapply: function (skeleton, time, alpha) {\n\t\tvar frames = this.frames;\n\t\tif (time < frames[0]) return; // Time is before first frame.\n\n\t\tvar bone = skeleton.bones[this.boneIndex];\n\n\t\tif (time >= frames[frames.length - 2]) { // Time is after last frame.\n\t\t\tvar amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\n\t\t\twhile (amount > 180)\n\t\t\t\tamount -= 360;\n\t\t\twhile (amount < -180)\n\t\t\t\tamount += 360;\n\t\t\tbone.rotation += amount * alpha;\n\t\t\treturn;\n\t\t}\n\n\t\t// Interpolate between the last frame and the current frame.\n\t\tvar frameIndex = spine.binarySearch(frames, time, 2);\n\t\tvar lastFrameValue = frames[frameIndex - 1];\n\t\tvar frameTime = frames[frameIndex];\n\t\tvar percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);\n\t\tpercent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\n\n\t\tvar amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;\n\t\twhile (amount > 180)\n\t\t\tamount -= 360;\n\t\twhile (amount < -180)\n\t\t\tamount += 360;\n\t\tamount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;\n\t\twhile (amount > 180)\n\t\t\tamount -= 360;\n\t\twhile (amount < -180)\n\t\t\tamount += 360;\n\t\tbone.rotation += amount * alpha;\n\t}\n};\n\nspine.TranslateTimeline = function (frameCount) {\n\tthis.curves = new spine.Curves(frameCount);\n\tthis.frames = []; // time, x, y, ...\n\tthis.frames.length = frameCount * 3;\n};\nspine.TranslateTimeline.prototype = {\n\tboneIndex: 0,\n\tgetFrameCount: function () {\n\t\treturn this.frames.length / 3;\n\t},\n\tsetFrame: function (frameIndex, time, x, y) {\n\t\tframeIndex *= 3;\n\t\tthis.frames[frameIndex] = time;\n\t\tthis.frames[frameIndex + 1] = x;\n\t\tthis.frames[frameIndex + 2] = y;\n\t},\n\tapply: function (skeleton, time, alpha) {\n\t\tvar frames = this.frames;\n\t\tif (time < frames[0]) return; // Time is before first frame.\n\n\t\tvar bone = skeleton.bones[this.boneIndex];\n\n\t\tif (time >= frames[frames.length - 3]) { // Time is after last frame.\n\t\t\tbone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\n\t\t\tbone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\n\t\t\treturn;\n\t\t}\n\n\t\t// Interpolate between the last frame and the current frame.\n\t\tvar frameIndex = spine.binarySearch(frames, time, 3);\n\t\tvar lastFrameX = frames[frameIndex - 2];\n\t\tvar lastFrameY = frames[frameIndex - 1];\n\t\tvar frameTime = frames[frameIndex];\n\t\tvar percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);\n\t\tpercent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n\t\tbone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;\n\t\tbone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;\n\t}\n};\n\nspine.ScaleTimeline = function (frameCount) {\n\tthis.curves = new spine.Curves(frameCount);\n\tthis.frames = []; // time, x, y, ...\n\tthis.frames.length = frameCount * 3;\n};\nspine.ScaleTimeline.prototype = {\n\tboneIndex: 0,\n\tgetFrameCount: function () {\n\t\treturn this.frames.length / 3;\n\t},\n\tsetFrame: function (frameIndex, time, x, y) {\n\t\tframeIndex *= 3;\n\t\tthis.frames[frameIndex] = time;\n\t\tthis.frames[frameIndex + 1] = x;\n\t\tthis.frames[frameIndex + 2] = y;\n\t},\n\tapply: function (skeleton, time, alpha) {\n\t\tvar frames = this.frames;\n\t\tif (time < frames[0]) return; // Time is before first frame.\n\n\t\tvar bone = skeleton.bones[this.boneIndex];\n\n\t\tif (time >= frames[frames.length - 3]) { // Time is after last frame.\n\t\t\tbone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;\n\t\t\tbone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;\n\t\t\treturn;\n\t\t}\n\n\t\t// Interpolate between the last frame and the current frame.\n\t\tvar frameIndex = spine.binarySearch(frames, time, 3);\n\t\tvar lastFrameX = frames[frameIndex - 2];\n\t\tvar lastFrameY = frames[frameIndex - 1];\n\t\tvar frameTime = frames[frameIndex];\n\t\tvar percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);\n\t\tpercent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n\t\tbone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;\n\t\tbone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;\n\t}\n};\n\nspine.ColorTimeline = function (frameCount) {\n\tthis.curves = new spine.Curves(frameCount);\n\tthis.frames = []; // time, r, g, b, a, ...\n\tthis.frames.length = frameCount * 5;\n};\nspine.ColorTimeline.prototype = {\n\tslotIndex: 0,\n\tgetFrameCount: function () {\n\t\treturn this.frames.length / 2;\n\t},\n\tsetFrame: function (frameIndex, time, x, y) {\n\t\tframeIndex *= 5;\n\t\tthis.frames[frameIndex] = time;\n\t\tthis.frames[frameIndex + 1] = r;\n\t\tthis.frames[frameIndex + 2] = g;\n\t\tthis.frames[frameIndex + 3] = b;\n\t\tthis.frames[frameIndex + 4] = a;\n\t},\n\tapply: function (skeleton, time, alpha) {\n\t\tvar frames = this.frames;\n\t\tif (time < frames[0]) return; // Time is before first frame.\n\n\t\tvar slot = skeleton.slots[this.slotIndex];\n\n\t\tif (time >= frames[frames.length - 5]) { // Time is after last frame.\n\t\t\tvar i = frames.length - 1;\n\t\t\tslot.r = frames[i - 3];\n\t\t\tslot.g = frames[i - 2];\n\t\t\tslot.b = frames[i - 1];\n\t\t\tslot.a = frames[i];\n\t\t\treturn;\n\t\t}\n\n\t\t// Interpolate between the last frame and the current frame.\n\t\tvar frameIndex = spine.binarySearch(frames, time, 5);\n\t\tvar lastFrameR = frames[frameIndex - 4];\n\t\tvar lastFrameG = frames[frameIndex - 3];\n\t\tvar lastFrameB = frames[frameIndex - 2];\n\t\tvar lastFrameA = frames[frameIndex - 1];\n\t\tvar frameTime = frames[frameIndex];\n\t\tvar percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);\n\t\tpercent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\n\n\t\tvar r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;\n\t\tvar g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;\n\t\tvar b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;\n\t\tvar a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;\n\t\tif (alpha < 1) {\n\t\t\tslot.r += (r - slot.r) * alpha;\n\t\t\tslot.g += (g - slot.g) * alpha;\n\t\t\tslot.b += (b - slot.b) * alpha;\n\t\t\tslot.a += (a - slot.a) * alpha;\n\t\t} else {\n\t\t\tslot.r = r;\n\t\t\tslot.g = g;\n\t\t\tslot.b = b;\n\t\t\tslot.a = a;\n\t\t}\n\t}\n};\n\nspine.AttachmentTimeline = function (frameCount) {\n\tthis.curves = new spine.Curves(frameCount);\n\tthis.frames = []; // time, ...\n\tthis.frames.length = frameCount;\n\tthis.attachmentNames = []; // time, ...\n\tthis.attachmentNames.length = frameCount;\n};\nspine.AttachmentTimeline.prototype = {\n\tslotIndex: 0,\n\tgetFrameCount: function () {\n            return this.frames.length;\n\t},\n\tsetFrame: function (frameIndex, time, attachmentName) {\n\t\tthis.frames[frameIndex] = time;\n\t\tthis.attachmentNames[frameIndex] = attachmentName;\n\t},\n\tapply: function (skeleton, time, alpha) {\n\t\tvar frames = this.frames;\n\t\tif (time < frames[0]) return; // Time is before first frame.\n\n\t\tvar frameIndex;\n\t\tif (time >= frames[frames.length - 1]) // Time is after last frame.\n\t\t\tframeIndex = frames.length - 1;\n\t\telse\n\t\t\tframeIndex = spine.binarySearch(frames, time, 1) - 1;\n\n\t\tvar attachmentName = this.attachmentNames[frameIndex];\n\t\tskeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\n\t}\n};\n\nspine.SkeletonData = function () {\n\tthis.bones = [];\n\tthis.slots = [];\n\tthis.skins = [];\n\tthis.animations = [];\n};\nspine.SkeletonData.prototype = {\n\tdefaultSkin: null,\n\t/** @return May be null. */\n\tfindBone: function (boneName) {\n\t\tvar bones = this.bones;\n\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\tif (bones[i].name == boneName) return bones[i];\n\t\treturn null;\n\t},\n\t/** @return -1 if the bone was not found. */\n\tfindBoneIndex: function (boneName) {\n\t\tvar bones = this.bones;\n\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\tif (bones[i].name == boneName) return i;\n\t\treturn -1;\n\t},\n\t/** @return May be null. */\n\tfindSlot: function (slotName) {\n\t\tvar slots = this.slots;\n\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\tif (slots[i].name == slotName) return slot[i];\n\t\t}\n\t\treturn null;\n\t},\n\t/** @return -1 if the bone was not found. */\n\tfindSlotIndex: function (slotName) {\n\t\tvar slots = this.slots;\n\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\tif (slots[i].name == slotName) return i;\n\t\treturn -1;\n\t},\n\t/** @return May be null. */\n\tfindSkin: function (skinName) {\n\t\tvar skins = this.skins;\n\t\tfor (var i = 0, n = skins.length; i < n; i++)\n\t\t\tif (skins[i].name == skinName) return skins[i];\n\t\treturn null;\n\t},\n\t/** @return May be null. */\n\tfindAnimation: function (animationName) {\n\t\tvar animations = this.animations;\n\t\tfor (var i = 0, n = animations.length; i < n; i++)\n\t\t\tif (animations[i].name == animationName) return animations[i];\n\t\treturn null;\n\t}\n};\n\nspine.Skeleton = function (skeletonData) {\n\tthis.data = skeletonData;\n\n\tthis.bones = [];\n\tfor (var i = 0, n = skeletonData.bones.length; i < n; i++) {\n\t\tvar boneData = skeletonData.bones[i];\n\t\tvar parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n\t\tthis.bones.push(new spine.Bone(boneData, parent));\n\t}\n\n\tthis.slots = [];\n\tthis.drawOrder = [];\n\tfor (var i = 0, n = skeletonData.slots.length; i < n; i++) {\n\t\tvar slotData = skeletonData.slots[i];\n\t\tvar bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n\t\tvar slot = new spine.Slot(slotData, this, bone);\n\t\tthis.slots.push(slot);\n\t\tthis.drawOrder.push(slot);\n\t}\n};\nspine.Skeleton.prototype = {\n\tx: 0, y: 0,\n\tskin: null,\n\tr: 1, g: 1, b: 1, a: 1,\n\ttime: 0,\n\tflipX: false, flipY: false,\n\t/** Updates the world transform for each bone. */\n\tupdateWorldTransform: function () {\n\t\tvar flipX = this.flipX;\n\t\tvar flipY = this.flipY;\n\t\tvar bones = this.bones;\n\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\tbones[i].updateWorldTransform(flipX, flipY);\n\t},\n\t/** Sets the bones and slots to their setup pose values. */\n\tsetToSetupPose: function () {\n\t\tthis.setBonesToSetupPose();\n\t\tthis.setSlotsToSetupPose();\n\t},\n\tsetBonesToSetupPose: function () {\n\t\tvar bones = this.bones;\n\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\tbones[i].setToSetupPose();\n\t},\n\tsetSlotsToSetupPose: function () {\n\t\tvar slots = this.slots;\n\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\tslots[i].setToSetupPose(i);\n\t},\n\t/** @return May return null. */\n\tgetRootBone: function () {\n\t\treturn this.bones.length == 0 ? null : this.bones[0];\n\t},\n\t/** @return May be null. */\n\tfindBone: function (boneName) {\n\t\tvar bones = this.bones;\n\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\tif (bones[i].data.name == boneName) return bones[i];\n\t\treturn null;\n\t},\n\t/** @return -1 if the bone was not found. */\n\tfindBoneIndex: function (boneName) {\n\t\tvar bones = this.bones;\n\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\tif (bones[i].data.name == boneName) return i;\n\t\treturn -1;\n\t},\n\t/** @return May be null. */\n\tfindSlot: function (slotName) {\n\t\tvar slots = this.slots;\n\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\tif (slots[i].data.name == slotName) return slots[i];\n\t\treturn null;\n\t},\n\t/** @return -1 if the bone was not found. */\n\tfindSlotIndex: function (slotName) {\n\t\tvar slots = this.slots;\n\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\tif (slots[i].data.name == slotName) return i;\n\t\treturn -1;\n\t},\n\tsetSkinByName: function (skinName) {\n\t\tvar skin = this.data.findSkin(skinName);\n\t\tif (!skin) throw \"Skin not found: \" + skinName;\n\t\tthis.setSkin(skin);\n\t},\n\t/** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments\n\t * from the new skin are attached if the corresponding attachment from the old skin was attached.\n\t * @param newSkin May be null. */\n\tsetSkin: function (newSkin) {\n\t\tif (this.skin && newSkin) newSkin._attachAll(this, this.skin);\n\t\tthis.skin = newSkin;\n\t},\n\t/** @return May be null. */\n\tgetAttachmentBySlotName: function (slotName, attachmentName) {\n\t\treturn this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n\t},\n\t/** @return May be null. */\n\tgetAttachmentBySlotIndex: function (slotIndex, attachmentName) {\n\t\tif (this.skin) {\n\t\t\tvar attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\t\t\tif (attachment) return attachment;\n\t\t}\n\t\tif (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\t\treturn null;\n\t},\n\t/** @param attachmentName May be null. */\n\tsetAttachment: function (slotName, attachmentName) {\n\t\tvar slots = this.slots;\n\t\tfor (var i = 0, n = slots.size; i < n; i++) {\n\t\t\tvar slot = slots[i];\n\t\t\tif (slot.data.name == slotName) {\n\t\t\t\tvar attachment = null;\n\t\t\t\tif (attachmentName) {\n\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\n\t\t\t\t\tif (attachment == null) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n\t\t\t\t}\n\t\t\t\tslot.setAttachment(attachment);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow \"Slot not found: \" + slotName;\n\t},\n\tupdate: function (delta) {\n\t\ttime += delta;\n\t}\n};\n\nspine.AttachmentType = {\n\tregion: 0\n};\n\nspine.RegionAttachment = function () {\n\tthis.offset = [];\n\tthis.offset.length = 8;\n\tthis.uvs = [];\n\tthis.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n\tx: 0, y: 0,\n\trotation: 0,\n\tscaleX: 1, scaleY: 1,\n\twidth: 0, height: 0,\n\trendererObject: null,\n\tregionOffsetX: 0, regionOffsetY: 0,\n\tregionWidth: 0, regionHeight: 0,\n\tregionOriginalWidth: 0, regionOriginalHeight: 0,\n\tsetUVs: function (u, v, u2, v2, rotate) {\n\t\tvar uvs = this.uvs;\n\t\tif (rotate) {\n\t\t\tuvs[2/*X2*/] = u;\n\t\t\tuvs[3/*Y2*/] = v2;\n\t\t\tuvs[4/*X3*/] = u;\n\t\t\tuvs[5/*Y3*/] = v;\n\t\t\tuvs[6/*X4*/] = u2;\n\t\t\tuvs[7/*Y4*/] = v;\n\t\t\tuvs[0/*X1*/] = u2;\n\t\t\tuvs[1/*Y1*/] = v2;\n\t\t} else {\n\t\t\tuvs[0/*X1*/] = u;\n\t\t\tuvs[1/*Y1*/] = v2;\n\t\t\tuvs[2/*X2*/] = u;\n\t\t\tuvs[3/*Y2*/] = v;\n\t\t\tuvs[4/*X3*/] = u2;\n\t\t\tuvs[5/*Y3*/] = v;\n\t\t\tuvs[6/*X4*/] = u2;\n\t\t\tuvs[7/*Y4*/] = v2;\n\t\t}\n\t},\n\tupdateOffset: function () {\n\t\tvar regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n\t\tvar regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n\t\tvar localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n\t\tvar localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n\t\tvar localX2 = localX + this.regionWidth * regionScaleX;\n\t\tvar localY2 = localY + this.regionHeight * regionScaleY;\n\t\tvar radians = this.rotation * Math.PI / 180;\n\t\tvar cos = Math.cos(radians);\n\t\tvar sin = Math.sin(radians);\n\t\tvar localXCos = localX * cos + this.x;\n\t\tvar localXSin = localX * sin;\n\t\tvar localYCos = localY * cos + this.y;\n\t\tvar localYSin = localY * sin;\n\t\tvar localX2Cos = localX2 * cos + this.x;\n\t\tvar localX2Sin = localX2 * sin;\n\t\tvar localY2Cos = localY2 * cos + this.y;\n\t\tvar localY2Sin = localY2 * sin;\n\t\tvar offset = this.offset;\n\t\toffset[0/*X1*/] = localXCos - localYSin;\n\t\toffset[1/*Y1*/] = localYCos + localXSin;\n\t\toffset[2/*X2*/] = localXCos - localY2Sin;\n\t\toffset[3/*Y2*/] = localY2Cos + localXSin;\n\t\toffset[4/*X3*/] = localX2Cos - localY2Sin;\n\t\toffset[5/*Y3*/] = localY2Cos + localX2Sin;\n\t\toffset[6/*X4*/] = localX2Cos - localYSin;\n\t\toffset[7/*Y4*/] = localYCos + localX2Sin;\n\t},\n\tcomputeVertices: function (x, y, bone, vertices) {\n\t\tx += bone.worldX;\n\t\ty += bone.worldY;\n\t\tvar m00 = bone.m00;\n\t\tvar m01 = bone.m01;\n\t\tvar m10 = bone.m10;\n\t\tvar m11 = bone.m11;\n\t\tvar offset = this.offset;\n\t\tvertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n\t\tvertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n\t\tvertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n\t\tvertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n\t\tvertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n\t\tvertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n\t\tvertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n\t\tvertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n\t}\n}\n\nspine.AnimationStateData = function (skeletonData) {\n\tthis.skeletonData = skeletonData;\n\tthis.animationToMixTime = {};\n};\nspine.AnimationStateData.prototype = {\n        defaultMix: 0,\n\tsetMixByName: function (fromName, toName, duration) {\n\t\tvar from = this.skeletonData.findAnimation(fromName);\n\t\tif (!from) throw \"Animation not found: \" + fromName;\n\t\tvar to = this.skeletonData.findAnimation(toName);\n\t\tif (!to) throw \"Animation not found: \" + toName;\n\t\tthis.setMix(from, to, duration);\n\t},\n\tsetMix: function (from, to, duration) {\n\t\tthis.animationToMixTime[from.name + \":\" + to.name] = duration;\n\t},\n\tgetMix: function (from, to) {\n\t\tvar time = this.animationToMixTime[from.name + \":\" + to.name];\n            return time ? time : this.defaultMix;\n\t}\n};\n\nspine.AnimationState = function (stateData) {\n\tthis.data = stateData;\n\tthis.queue = [];\n};\nspine.AnimationState.prototype = {\n\tcurrent: null,\n\tprevious: null,\n\tcurrentTime: 0,\n\tpreviousTime: 0,\n\tcurrentLoop: false,\n\tpreviousLoop: false,\n\tmixTime: 0,\n\tmixDuration: 0,\n\tupdate: function (delta) {\n\t\tthis.currentTime += delta;\n\t\tthis.previousTime += delta;\n\t\tthis.mixTime += delta;\n\n\t\tif (this.queue.length > 0) {\n\t\t\tvar entry = this.queue[0];\n\t\t\tif (this.currentTime >= entry.delay) {\n\t\t\t\tthis._setAnimation(entry.animation, entry.loop);\n\t\t\t\tthis.queue.shift();\n\t\t\t}\n\t\t}\n\t},\n\tapply: function (skeleton) {\n\t\tif (!this.current) return;\n\t\tif (this.previous) {\n\t\t\tthis.previous.apply(skeleton, this.previousTime, this.previousLoop);\n\t\t\tvar alpha = this.mixTime / this.mixDuration;\n\t\t\tif (alpha >= 1) {\n\t\t\t\talpha = 1;\n\t\t\t\tthis.previous = null;\n\t\t\t}\n\t\t\tthis.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);\n\t\t} else\n\t\t\tthis.current.apply(skeleton, this.currentTime, this.currentLoop);\n\t},\n\tclearAnimation: function () {\n\t\tthis.previous = null;\n\t\tthis.current = null;\n\t\tthis.queue.length = 0;\n\t},\n\t_setAnimation: function (animation, loop) {\n\t\tthis.previous = null;\n\t\tif (animation && this.current) {\n\t\t\tthis.mixDuration = this.data.getMix(this.current, animation);\n\t\t\tif (this.mixDuration > 0) {\n\t\t\t\tthis.mixTime = 0;\n\t\t\t\tthis.previous = this.current;\n\t\t\t\tthis.previousTime = this.currentTime;\n\t\t\t\tthis.previousLoop = this.currentLoop;\n\t\t\t}\n\t\t}\n\t\tthis.current = animation;\n\t\tthis.currentLoop = loop;\n\t\tthis.currentTime = 0;\n\t},\n\t/** @see #setAnimation(Animation, Boolean) */\n\tsetAnimationByName: function (animationName, loop) {\n\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\n\t\tif (!animation) throw \"Animation not found: \" + animationName;\n\t\tthis.setAnimation(animation, loop);\n\t},\n\t/** Set the current animation. Any queued animations are cleared and the current animation time is set to 0.\n\t * @param animation May be null. */\n\tsetAnimation: function (animation, loop) {\n\t\tthis.queue.length = 0;\n\t\tthis._setAnimation(animation, loop);\n\t},\n\t/** @see #addAnimation(Animation, Boolean, Number) */\n\taddAnimationByName: function (animationName, loop, delay) {\n\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\n\t\tif (!animation) throw \"Animation not found: \" + animationName;\n\t\tthis.addAnimation(animation, loop, delay);\n\t},\n\t/** Adds an animation to be played delay seconds after the current or last queued animation.\n\t * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n\taddAnimation: function (animation, loop, delay) {\n\t\tvar entry = {};\n\t\tentry.animation = animation;\n\t\tentry.loop = loop;\n\n\t\tif (!delay || delay <= 0) {\n\t\t\tvar previousAnimation = this.queue.length == 0 ? this.current : this.queue[this.queue.length - 1].animation;\n\t\t\tif (previousAnimation != null)\n\t\t\t\tdelay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0);\n\t\t\telse\n\t\t\t\tdelay = 0;\n\t\t}\n\t\tentry.delay = delay;\n\n\t\tthis.queue.push(entry);\n\t},\n\t/** Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping. */\n\tisComplete: function () {\n\t\treturn !this.current || this.currentTime >= this.current.duration;\n\t}\n};\n\nspine.SkeletonJson = function (attachmentLoader) {\n\tthis.attachmentLoader = attachmentLoader;\n};\nspine.SkeletonJson.prototype = {\n\tscale: 1,\n\treadSkeletonData: function (root) {\n\t\tvar skeletonData = new spine.SkeletonData();\n\n\t\t// Bones.\n\t\tvar bones = root[\"bones\"];\n\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\tvar boneMap = bones[i];\n\t\t\tvar parent = null;\n\t\t\tif (boneMap[\"parent\"]) {\n\t\t\t\tparent = skeletonData.findBone(boneMap[\"parent\"]);\n\t\t\t\tif (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n\t\t\t}\n\t\t\tvar boneData = new spine.BoneData(boneMap[\"name\"], parent);\n\t\t\tboneData.length = (boneMap[\"length\"] || 0) * this.scale;\n\t\t\tboneData.x = (boneMap[\"x\"] || 0) * this.scale;\n\t\t\tboneData.y = (boneMap[\"y\"] || 0) * this.scale;\n\t\t\tboneData.rotation = (boneMap[\"rotation\"] || 0);\n\t\t\tboneData.scaleX = boneMap[\"scaleX\"] || 1;\n\t\t\tboneData.scaleY = boneMap[\"scaleY\"] || 1;\n\t\t\tskeletonData.bones.push(boneData);\n\t\t}\n\n\t\t// Slots.\n\t\tvar slots = root[\"slots\"];\n\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\tvar slotMap = slots[i];\n\t\t\tvar boneData = skeletonData.findBone(slotMap[\"bone\"]);\n\t\t\tif (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n\t\t\tvar slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n\t\t\tvar color = slotMap[\"color\"];\n\t\t\tif (color) {\n\t\t\t\tslotData.r = spine.SkeletonJson.toColor(color, 0);\n\t\t\t\tslotData.g = spine.SkeletonJson.toColor(color, 1);\n\t\t\t\tslotData.b = spine.SkeletonJson.toColor(color, 2);\n\t\t\t\tslotData.a = spine.SkeletonJson.toColor(color, 3);\n\t\t\t}\n\n\t\t\tslotData.attachmentName = slotMap[\"attachment\"];\n\n\t\t\tskeletonData.slots.push(slotData);\n\t\t}\n\n\t\t// Skins.\n\t\tvar skins = root[\"skins\"];\n\t\tfor (var skinName in skins) {\n\t\t\tif (!skins.hasOwnProperty(skinName)) continue;\n\t\t\tvar skinMap = skins[skinName];\n\t\t\tvar skin = new spine.Skin(skinName);\n\t\t\tfor (var slotName in skinMap) {\n\t\t\t\tif (!skinMap.hasOwnProperty(slotName)) continue;\n\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\n\t\t\t\tvar slotEntry = skinMap[slotName];\n\t\t\t\tfor (var attachmentName in slotEntry) {\n\t\t\t\t\tif (!slotEntry.hasOwnProperty(attachmentName)) continue;\n\t\t\t\t\tvar attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\n\t\t\t\t\tif (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);\n\t\t\t\t}\n\t\t\t}\n\t\t\tskeletonData.skins.push(skin);\n\t\t\tif (skin.name == \"default\") skeletonData.defaultSkin = skin;\n\t\t}\n\n\t\t// Animations.\n\t\tvar animations = root[\"animations\"];\n\t\tfor (var animationName in animations) {\n\t\t\tif (!animations.hasOwnProperty(animationName)) continue;\n\t\t\tthis.readAnimation(animationName, animations[animationName], skeletonData);\n\t\t}\n\n\t\treturn skeletonData;\n\t},\n\treadAttachment: function (skin, name, map) {\n\t\tname = map[\"name\"] || name;\n\n\t\tvar type = spine.AttachmentType[map[\"type\"] || \"region\"];\n\n\t\tif (type == spine.AttachmentType.region) {\n\t\t\tvar attachment = new spine.RegionAttachment();\n\t\t\tattachment.x = (map[\"x\"] || 0) * this.scale;\n\t\t\tattachment.y = (map[\"y\"] || 0) * this.scale;\n\t\t\tattachment.scaleX = map[\"scaleX\"] || 1;\n\t\t\tattachment.scaleY = map[\"scaleY\"] || 1;\n\t\t\tattachment.rotation = map[\"rotation\"] || 0;\n\t\t\tattachment.width = (map[\"width\"] || 32) * this.scale;\n\t\t\tattachment.height = (map[\"height\"] || 32) * this.scale;\n\t\t\tattachment.updateOffset();\n\n\t\t\tattachment.rendererObject = {};\n\t\t\tattachment.rendererObject.name = name;\n\t\t\tattachment.rendererObject.scale = {};\n\t\t\tattachment.rendererObject.scale.x = attachment.scaleX;\n\t\t\tattachment.rendererObject.scale.y = attachment.scaleY;\n\t\t\tattachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;\n\t\t\treturn attachment;\n\t\t}\n\n            throw \"Unknown attachment type: \" + type;\n\t},\n\n\treadAnimation: function (name, map, skeletonData) {\n\t\tvar timelines = [];\n\t\tvar duration = 0;\n\n\t\tvar bones = map[\"bones\"];\n\t\tfor (var boneName in bones) {\n\t\t\tif (!bones.hasOwnProperty(boneName)) continue;\n\t\t\tvar boneIndex = skeletonData.findBoneIndex(boneName);\n\t\t\tif (boneIndex == -1) throw \"Bone not found: \" + boneName;\n\t\t\tvar boneMap = bones[boneName];\n\n\t\t\tfor (var timelineName in boneMap) {\n\t\t\t\tif (!boneMap.hasOwnProperty(timelineName)) continue;\n\t\t\t\tvar values = boneMap[timelineName];\n\t\t\t\tif (timelineName == \"rotate\") {\n\t\t\t\t\tvar timeline = new spine.RotateTimeline(values.length);\n\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\n\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\tfor (var i = 0, n = values.length; i < n; i++) {\n\t\t\t\t\t\tvar valueMap = values[i];\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n\t\t\t\t\t\tspine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n\t\t\t\t} else if (timelineName == \"translate\" || timelineName == \"scale\") {\n\t\t\t\t\tvar timeline;\n\t\t\t\t\tvar timelineScale = 1;\n\t\t\t\t\tif (timelineName == \"scale\")\n\t\t\t\t\t\ttimeline = new spine.ScaleTimeline(values.length);\n\t\t\t\t\telse {\n\t\t\t\t\t\ttimeline = new spine.TranslateTimeline(values.length);\n\t\t\t\t\t\ttimelineScale = this.scale;\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\n\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\tfor (var i = 0, n = values.length; i < n; i++) {\n\t\t\t\t\t\tvar valueMap = values[i];\n\t\t\t\t\t\tvar x = (valueMap[\"x\"] || 0) * timelineScale;\n\t\t\t\t\t\tvar y = (valueMap[\"y\"] || 0) * timelineScale;\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n\t\t\t\t\t\tspine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n\t\t\t\t} else\n\t\t\t\t\tthrow \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n\t\t\t}\n\t\t}\n\t\tvar slots = map[\"slots\"];\n\t\tfor (var slotName in slots) {\n\t\t\tif (!slots.hasOwnProperty(slotName)) continue;\n\t\t\tvar slotMap = slots[slotName];\n\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\n\n\t\t\tfor (var timelineName in slotMap) {\n\t\t\t\tif (!slotMap.hasOwnProperty(timelineName)) continue;\n\t\t\t\tvar values = slotMap[timelineName];\n\t\t\t\tif (timelineName == \"color\") {\n\t\t\t\t\tvar timeline = new spine.ColorTimeline(values.length);\n\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\n\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\tfor (var i = 0, n = values.length; i < n; i++) {\n\t\t\t\t\t\tvar valueMap = values[i];\n\t\t\t\t\t\tvar color = valueMap[\"color\"];\n\t\t\t\t\t\tvar r = spine.SkeletonJson.toColor(color, 0);\n\t\t\t\t\t\tvar g = spine.SkeletonJson.toColor(color, 1);\n\t\t\t\t\t\tvar b = spine.SkeletonJson.toColor(color, 2);\n\t\t\t\t\t\tvar a = spine.SkeletonJson.toColor(color, 3);\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n\t\t\t\t\t\tspine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);\n\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n\t\t\t\t} else if (timelineName == \"attachment\") {\n\t\t\t\t\tvar timeline = new spine.AttachmentTimeline(values.length);\n\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\n\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\tfor (var i = 0, n = values.length; i < n; i++) {\n\t\t\t\t\t\tvar valueMap = values[i];\n\t\t\t\t\t\ttimeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n\t\t\t\t} else\n\t\t\t\t\tthrow \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n\t\t\t}\n\t\t}\n\t\tskeletonData.animations.push(new spine.Animation(name, timelines, duration));\n\t}\n};\nspine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {\n\tvar curve = valueMap[\"curve\"];\n\tif (!curve) return;\n\tif (curve == \"stepped\")\n\t\ttimeline.curves.setStepped(frameIndex);\n\telse if (curve instanceof Array)\n\t\ttimeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n};\nspine.SkeletonJson.toColor = function (hexString, colorIndex) {\n\tif (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n\treturn parseInt(hexString.substring(colorIndex * 2, 2), 16) / 255;\n};\n\nspine.Atlas = function (atlasText, textureLoader) {\n\tthis.textureLoader = textureLoader;\n\tthis.pages = [];\n\tthis.regions = [];\n\n\tvar reader = new spine.AtlasReader(atlasText);\n\tvar tuple = [];\n\ttuple.length = 4;\n\tvar page = null;\n\twhile (true) {\n\t\tvar line = reader.readLine();\n\t\tif (line == null) break;\n\t\tline = reader.trim(line);\n\t\tif (line.length == 0)\n\t\t\tpage = null;\n\t\telse if (!page) {\n\t\t\tpage = new spine.AtlasPage();\n\t\t\tpage.name = line;\n\n\t\t\tpage.format = spine.Atlas.Format[reader.readValue()];\n\n\t\t\treader.readTuple(tuple);\n\t\t\tpage.minFilter = spine.Atlas.TextureFilter[tuple[0]];\n\t\t\tpage.magFilter = spine.Atlas.TextureFilter[tuple[1]];\n\n\t\t\tvar direction = reader.readValue();\n\t\t\tpage.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n\t\t\tpage.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n\t\t\tif (direction == \"x\")\n\t\t\t\tpage.uWrap = spine.Atlas.TextureWrap.repeat;\n\t\t\telse if (direction == \"y\")\n\t\t\t\tpage.vWrap = spine.Atlas.TextureWrap.repeat;\n\t\t\telse if (direction == \"xy\")\n\t\t\t\tpage.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\n\n\t\t\ttextureLoader.load(page, line);\n\n\t\t\tthis.pages.push(page);\n\n\t\t} else {\n\t\t\tvar region = new spine.AtlasRegion();\n\t\t\tregion.name = line;\n\t\t\tregion.page = page;\n\n\t\t\tregion.rotate = reader.readValue() == \"true\";\n\n\t\t\treader.readTuple(tuple);\n\t\t\tvar x = parseInt(tuple[0]);\n\t\t\tvar y = parseInt(tuple[1]);\n\n\t\t\treader.readTuple(tuple);\n\t\t\tvar width = parseInt(tuple[0]);\n\t\t\tvar height = parseInt(tuple[1]);\n\n\t\t\tregion.u = x / page.width;\n\t\t\tregion.v = y / page.height;\n\t\t\tif (region.rotate) {\n\t\t\t\tregion.u2 = (x + height) / page.width;\n\t\t\t\tregion.v2 = (y + width) / page.height;\n\t\t\t} else {\n\t\t\t\tregion.u2 = (x + width) / page.width;\n\t\t\t\tregion.v2 = (y + height) / page.height;\n\t\t\t}\n\t\t\tregion.x = x;\n\t\t\tregion.y = y;\n\t\t\tregion.width = Math.abs(width);\n\t\t\tregion.height = Math.abs(height);\n\n\t\t\tif (reader.readTuple(tuple) == 4) { // split is optional\n\t\t\t\tregion.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n\t\t\t\tif (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n\t\t\t\t\tregion.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tregion.originalWidth = parseInt(tuple[0]);\n\t\t\tregion.originalHeight = parseInt(tuple[1]);\n\n\t\t\treader.readTuple(tuple);\n\t\t\tregion.offsetX = parseInt(tuple[0]);\n\t\t\tregion.offsetY = parseInt(tuple[1]);\n\n\t\t\tregion.index = parseInt(reader.readValue());\n\n\t\t\tthis.regions.push(region);\n\t\t}\n\t}\n};\nspine.Atlas.prototype = {\n\tfindRegion: function (name) {\n\t\tvar regions = this.regions;\n\t\tfor (var i = 0, n = regions.length; i < n; i++)\n\t\t\tif (regions[i].name == name) return regions[i];\n\t\treturn null;\n\t},\n\tdispose: function () {\n\t\tvar pages = this.pages;\n\t\tfor (var i = 0, n = pages.length; i < n; i++)\n\t\t\tthis.textureLoader.unload(pages[i].rendererObject);\n\t},\n\tupdateUVs: function (page) {\n\t\tvar regions = this.regions;\n\t\tfor (var i = 0, n = regions.length; i < n; i++) {\n\t\t\tvar region = regions[i];\n\t\t\tif (region.page != page) continue;\n\t\t\tregion.u = region.x / page.width;\n\t\t\tregion.v = region.y / page.height;\n\t\t\tif (region.rotate) {\n\t\t\t\tregion.u2 = (region.x + region.height) / page.width;\n\t\t\t\tregion.v2 = (region.y + region.width) / page.height;\n\t\t\t} else {\n\t\t\t\tregion.u2 = (region.x + region.width) / page.width;\n\t\t\t\tregion.v2 = (region.y + region.height) / page.height;\n\t\t\t}\n\t\t}\n\t}\n};\n\nspine.Atlas.Format = {\n\talpha: 0,\n\tintensity: 1,\n\tluminanceAlpha: 2,\n\trgb565: 3,\n\trgba4444: 4,\n\trgb888: 5,\n\trgba8888: 6\n};\n\nspine.Atlas.TextureFilter = {\n\tnearest: 0,\n\tlinear: 1,\n\tmipMap: 2,\n\tmipMapNearestNearest: 3,\n\tmipMapLinearNearest: 4,\n\tmipMapNearestLinear: 5,\n\tmipMapLinearLinear: 6\n};\n\nspine.Atlas.TextureWrap = {\n\tmirroredRepeat: 0,\n\tclampToEdge: 1,\n\trepeat: 2\n};\n\nspine.AtlasPage = function () {};\nspine.AtlasPage.prototype = {\n\tname: null,\n\tformat: null,\n\tminFilter: null,\n\tmagFilter: null,\n\tuWrap: null,\n\tvWrap: null,\n\trendererObject: null,\n\twidth: 0,\n\theight: 0\n};\n\nspine.AtlasRegion = function () {};\nspine.AtlasRegion.prototype = {\n\tpage: null,\n\tname: null,\n\tx: 0, y: 0,\n\twidth: 0, height: 0,\n\tu: 0, v: 0, u2: 0, v2: 0,\n\toffsetX: 0, offsetY: 0,\n\toriginalWidth: 0, originalHeight: 0,\n\tindex: 0,\n\trotate: false,\n\tsplits: null,\n\tpads: null,\n};\n\nspine.AtlasReader = function (text) {\n\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\n};\nspine.AtlasReader.prototype = {\n\tindex: 0,\n\ttrim: function (value) {\n\t\treturn value.replace(/^\\s+|\\s+$/g, \"\");\n\t},\n\treadLine: function () {\n\t\tif (this.index >= this.lines.length) return null;\n\t\treturn this.lines[this.index++];\n\t},\n\treadValue: function () {\n\t\tvar line = this.readLine();\n\t\tvar colon = line.indexOf(\":\");\n\t\tif (colon == -1) throw \"Invalid line: \" + line;\n\t\treturn this.trim(line.substring(colon + 1));\n\t},\n\t/** Returns the number of tuple values read (2 or 4). */\n\treadTuple: function (tuple) {\n\t\tvar line = this.readLine();\n\t\tvar colon = line.indexOf(\":\");\n\t\tif (colon == -1) throw \"Invalid line: \" + line;\n\t\tvar i = 0, lastMatch= colon + 1;\n\t\tfor (; i < 3; i++) {\n\t\t\tvar comma = line.indexOf(\",\", lastMatch);\n\t\t\tif (comma == -1) {\n\t\t\t\tif (i == 0) throw \"Invalid line: \" + line;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\n\t\t\tlastMatch = comma + 1;\n\t\t}\n\t\ttuple[i] = this.trim(line.substring(lastMatch));\n\t\treturn i + 1;\n\t}\n}\n\nspine.AtlasAttachmentLoader = function (atlas) {\n\tthis.atlas = atlas;\n}\nspine.AtlasAttachmentLoader.prototype = {\n\tnewAttachment: function (skin, type, name) {\n\t\tswitch (type) {\n\t\tcase spine.AttachmentType.region:\n\t\t\tvar region = this.atlas.findRegion(name);\n\t\t\tif (!region) throw \"Region not found in atlas: \" + name + \" (\" + type + \")\";\n\t\t\tvar attachment = new spine.RegionAttachment(name);\n\t\t\tattachment.rendererObject = region;\n\t\t\tattachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n\t\t\tattachment.regionOffsetX = region.offsetX;\n\t\t\tattachment.regionOffsetY = region.offsetY;\n\t\t\tattachment.regionWidth = region.width;\n\t\t\tattachment.regionHeight = region.height;\n\t\t\tattachment.regionOriginalWidth = region.originalWidth;\n\t\t\tattachment.regionOriginalHeight = region.originalHeight;\n\t\t\treturn attachment;\n\t\t}\n\t\tthrow \"Unknown attachment type: \" + type;\n\t}\n}\n\nPIXI.AnimCache = {};\nspine.Bone.yDown = true;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * This object is one that will allow you to specify custom rendering functions based on render type\n *\n * @class CustomRenderable \n * @extends DisplayObject\n * @constructor\n */\nPIXI.CustomRenderable = function()\n{\n\tPIXI.DisplayObject.call( this );\n\t\n}\n\n// constructor\nPIXI.CustomRenderable.prototype = Object.create( PIXI.DisplayObject.prototype );\nPIXI.CustomRenderable.prototype.constructor = PIXI.CustomRenderable;\n\n/**\n * If this object is being rendered by a CanvasRenderer it will call this callback\n *\n * @method renderCanvas\n * @param renderer {CanvasRenderer} The renderer instance\n */\nPIXI.CustomRenderable.prototype.renderCanvas = function(renderer)\n{\n\t// override!\n}\n\n/**\n * If this object is being rendered by a WebGLRenderer it will call this callback to initialize\n *\n * @method initWebGL\n * @param renderer {WebGLRenderer} The renderer instance\n */\nPIXI.CustomRenderable.prototype.initWebGL = function(renderer)\n{\n\t// override!\n}\n\n/**\n * If this object is being rendered by a WebGLRenderer it will call this callback\n *\n * @method renderWebGL\n * @param renderer {WebGLRenderer} The renderer instance\n */\nPIXI.CustomRenderable.prototype.renderWebGL = function(renderGroup, projectionMatrix)\n{\n\t// not sure if both needed? but ya have for now!\n\t// override!\n}\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.BaseTextureCache = {};\nPIXI.texturesToUpdate = [];\nPIXI.texturesToDestroy = [];\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture\n *\n * @class BaseTexture\n * @uses EventTarget\n * @constructor\n * @param source {String} the source object (image or canvas)\n */\nPIXI.BaseTexture = function(source)\n{\n\tPIXI.EventTarget.call( this );\n\n\t/**\n\t * [read-only] The width of the base texture set when the image has loaded\n\t *\n\t * @property width\n\t * @type Number\n\t * @readOnly\n\t */\n\tthis.width = 100;\n\n\t/**\n\t * [read-only] The height of the base texture set when the image has loaded\n\t *\n\t * @property height\n\t * @type Number\n\t * @readOnly\n\t */\n\tthis.height = 100;\n\n\t/**\n\t * [read-only] Describes if the base texture has loaded or not\n\t *\n\t * @property hasLoaded\n\t * @type Boolean\n\t * @readOnly\n\t */\n\tthis.hasLoaded = false;\n\n\t/**\n\t * The source that is loaded to create the texture\n\t *\n\t * @property source\n\t * @type Image\n\t */\n\tthis.source = source;\n\n\tif(!source)return;\n\n\tif(this.source instanceof Image || this.source instanceof HTMLImageElement)\n\t{\n\t\tif(this.source.complete)\n\t\t{\n\t\t\tthis.hasLoaded = true;\n\t\t\tthis.width = this.source.width;\n\t\t\tthis.height = this.source.height;\n\t\t\t\n\t\t\tPIXI.texturesToUpdate.push(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tvar scope = this;\n\t\t\tthis.source.onload = function(){\n\t\t\t\t\n\t\t\t\tscope.hasLoaded = true;\n\t\t\t\tscope.width = scope.source.width;\n\t\t\t\tscope.height = scope.source.height;\n\t\t\t\n\t\t\t\t// add it to somewhere...\n\t\t\t\tPIXI.texturesToUpdate.push(scope);\n\t\t\t\tscope.dispatchEvent( { type: 'loaded', content: scope } );\n\t\t\t}\n\t\t\t//\tthis.image.src = imageUrl;\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.hasLoaded = true;\n\t\tthis.width = this.source.width;\n\t\tthis.height = this.source.height;\n\t\t\t\n\t\tPIXI.texturesToUpdate.push(this);\n\t}\n\n\tthis._powerOf2 = false;\n}\n\nPIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;\n\n/**\n * Destroys this base texture\n *\n * @method destroy\n */\nPIXI.BaseTexture.prototype.destroy = function()\n{\n\tif(this.source instanceof Image)\n\t{\n\t\tthis.source.src = null;\n\t}\n\tthis.source = null;\n\tPIXI.texturesToDestroy.push(this);\n}\n\n/**\n * Helper function that returns a base texture based on an image url\n * If the image is not in the base texture cache it will be  created and loaded\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @return BaseTexture\n */\nPIXI.BaseTexture.fromImage = function(imageUrl, crossorigin)\n{\n\tvar baseTexture = PIXI.BaseTextureCache[imageUrl];\n\tif(!baseTexture)\n\t{\n\t\t// new Image() breaks tex loading in some versions of Chrome.\n\t\t// See https://code.google.com/p/chromium/issues/detail?id=238071\n\t\tvar image = new Image();//document.createElement('img'); \n\t\tif (crossorigin)\n\t\t{\n\t\t\timage.crossOrigin = '';\n\t\t}\n\t\timage.src = imageUrl;\n\t\tbaseTexture = new PIXI.BaseTexture(image);\n\t\tPIXI.BaseTextureCache[imageUrl] = baseTexture;\n\t}\n\n\treturn baseTexture;\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.TextureCache = {};\nPIXI.FrameCache = {};\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. To do this use PIXI.Sprite. If no frame is provided then the whole image is used\n *\n * @class Texture\n * @uses EventTarget\n * @constructor\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param frmae {Rectangle} The rectangle frame of the texture to show\n */\nPIXI.Texture = function(baseTexture, frame)\n{\n\tPIXI.EventTarget.call( this );\n\n\tif(!frame)\n\t{\n\t\tthis.noFrame = true;\n\t\tframe = new PIXI.Rectangle(0,0,1,1);\n\t}\n\n\tif(baseTexture instanceof PIXI.Texture)\n\t\tbaseTexture = baseTexture.baseTexture;\n\n\t/**\n\t * The base texture of this texture\n\t *\n\t * @property baseTexture\n\t * @type BaseTexture\n\t */\n\tthis.baseTexture = baseTexture;\n\n\t/**\n\t * The frame specifies the region of the base texture that this texture uses\n\t *\n\t * @property frame\n\t * @type Rectangle\n\t */\n\tthis.frame = frame;\n\n\t/**\n\t * The trim point\n\t *\n\t * @property trim\n\t * @type Point\n\t */\n\tthis.trim = new PIXI.Point();\n\n\tthis.scope = this;\n\n\tif(baseTexture.hasLoaded)\n\t{\n\t\tif(this.noFrame)frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);\n\t\t//console.log(frame)\n\t\t\n\t\tthis.setFrame(frame);\n\t}\n\telse\n\t{\n\t\tvar scope = this;\n\t\tbaseTexture.addEventListener( 'loaded', function(){ scope.onBaseTextureLoaded()} );\n\t}\n}\n\nPIXI.Texture.prototype.constructor = PIXI.Texture;\n\n/**\n * Called when the base texture is loaded\n *\n * @method onBaseTextureLoaded\n * @param event\n * @private\n */\nPIXI.Texture.prototype.onBaseTextureLoaded = function(event)\n{\n\tvar baseTexture = this.baseTexture;\n\tbaseTexture.removeEventListener( 'loaded', this.onLoaded );\n\n\tif(this.noFrame)this.frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);\n\tthis.noFrame = false;\n\tthis.width = this.frame.width;\n\tthis.height = this.frame.height;\n\n\tthis.scope.dispatchEvent( { type: 'update', content: this } );\n}\n\n/**\n * Destroys this texture\n *\n * @method destroy\n * @param destroyBase {Boolean} Whether to destroy the base texture as well\n */\nPIXI.Texture.prototype.destroy = function(destroyBase)\n{\n\tif(destroyBase)this.baseTexture.destroy();\n}\n\n/**\n * Specifies the rectangle region of the baseTexture\n *\n * @method setFrame\n * @param frame {Rectangle} The frame of the texture to set it to\n */\nPIXI.Texture.prototype.setFrame = function(frame)\n{\n\tthis.frame = frame;\n\tthis.width = frame.width;\n\tthis.height = frame.height;\n\n\tif(frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)\n\t{\n\t\tthrow new Error(\"Texture Error: frame does not fit inside the base Texture dimensions \" + this);\n\t}\n\n\tthis.updateFrame = true;\n\n\tPIXI.Texture.frameUpdates.push(this);\n\t//this.dispatchEvent( { type: 'update', content: this } );\n}\n\n/**\n * Helper function that returns a texture based on an image url\n * If the image is not in the texture cache it will be  created and loaded\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n * @return Texture\n */\nPIXI.Texture.fromImage = function(imageUrl, crossorigin)\n{\n\tvar texture = PIXI.TextureCache[imageUrl];\n\t\n\tif(!texture)\n\t{\n\t\ttexture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin));\n\t\tPIXI.TextureCache[imageUrl] = texture;\n\t}\n\t\n\treturn texture;\n}\n\n/**\n * Helper function that returns a texture based on a frame id\n * If the frame id is not in the texture cache an error will be thrown\n *\n * @static\n * @method fromFrame\n * @param frameId {String} The frame id of the texture\n * @return Texture\n */\nPIXI.Texture.fromFrame = function(frameId)\n{\n\tvar texture = PIXI.TextureCache[frameId];\n\tif(!texture)throw new Error(\"The frameId '\"+ frameId +\"' does not exist in the texture cache \" + this);\n\treturn texture;\n}\n\n/**\n * Helper function that returns a texture based on a canvas element\n * If the canvas is not in the texture cache it will be  created and loaded\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @return Texture\n */\nPIXI.Texture.fromCanvas = function(canvas)\n{\n\tvar\tbaseTexture = new PIXI.BaseTexture(canvas);\n\treturn new PIXI.Texture(baseTexture);\n}\n\n\n/**\n * Adds a texture to the textureCache.\n *\n * @static\n * @method addTextureToCache\n * @param texture {Texture}\n * @param id {String} the id that the texture will be stored against.\n */\nPIXI.Texture.addTextureToCache = function(texture, id)\n{\n\tPIXI.TextureCache[id] = texture;\n}\n\n/**\n * Remove a texture from the textureCache. \n *\n * @static\n * @method removeTextureFromCache\n * @param id {String} the id of the texture to be removed\n * @return {Texture} the texture that was removed\n */\nPIXI.Texture.removeTextureFromCache = function(id)\n{\n\tvar texture = PIXI.TextureCache[id]\n\tPIXI.TextureCache[id] = null;\n\treturn texture;\n}\n\n// this is more for webGL.. it contains updated frames..\nPIXI.Texture.frameUpdates = [];\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n A RenderTexture is a special texture that allows any pixi displayObject to be rendered to it.\n\n __Hint__: All DisplayObjects (exmpl. Sprites) that renders on RenderTexture should be preloaded. \n Otherwise black rectangles will be drawn instead.  \n \n RenderTexture takes snapshot of DisplayObject passed to render method. If DisplayObject is passed to render method, position and rotation of it will be ignored. For example:\n \n\tvar renderTexture = new PIXI.RenderTexture(800, 600);\n\tvar sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n\tsprite.position.x = 800/2;\n\tsprite.position.y = 600/2;\n\tsprite.anchor.x = 0.5;\n\tsprite.anchor.y = 0.5;\n\trenderTexture.render(sprite);\n\n Sprite in this case will be rendered to 0,0 position. To render this sprite at center DisplayObjectContainer should be used:\n\n\tvar doc = new PIXI.DisplayObjectContainer();\n\tdoc.addChild(sprite);\n\trenderTexture.render(doc);  // Renders to center of renderTexture\n\n @class RenderTexture\n @extends Texture\n @constructor\n @param width {Number} The width of the render texture\n @param height {Number} The height of the render texture\n */\nPIXI.RenderTexture = function(width, height)\n{\n\tPIXI.EventTarget.call( this );\n\n\tthis.width = width || 100;\n\tthis.height = height || 100;\n\n\tthis.indetityMatrix = PIXI.mat3.create();\n\n\tthis.frame = new PIXI.Rectangle(0, 0, this.width, this.height);\t\n\n\tif(PIXI.gl)\n\t{\n\t\tthis.initWebGL();\n\t}\n\telse\n\t{\n\t\tthis.initCanvas();\n\t}\n}\n\nPIXI.RenderTexture.prototype = Object.create( PIXI.Texture.prototype );\nPIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;\n\n/**\n * Initializes the webgl data for this texture\n *\n * @method initWebGL\n * @private\n */\nPIXI.RenderTexture.prototype.initWebGL = function()\n{\n\tvar gl = PIXI.gl;\n\tthis.glFramebuffer = gl.createFramebuffer();\n\n   \tgl.bindFramebuffer(gl.FRAMEBUFFER, this.glFramebuffer );\n\n    this.glFramebuffer.width = this.width;\n    this.glFramebuffer.height = this.height;\t\n\n\tthis.baseTexture = new PIXI.BaseTexture();\n\n\tthis.baseTexture.width = this.width;\n\tthis.baseTexture.height = this.height;\n\n    this.baseTexture._glTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTexture);\n\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width,  this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n\tthis.baseTexture.isRender = true;\n\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.glFramebuffer );\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.baseTexture._glTexture, 0);\n\n\t// create a projection matrix..\n\tthis.projection = new PIXI.Point(this.width/2 , this.height/2);\n\n\t// set the correct render function..\n\tthis.render = this.renderWebGL;\n\n\t\n}\n\n\nPIXI.RenderTexture.prototype.resize = function(width, height)\n{\n\n\tthis.width = width;\n\tthis.height = height;\n\t\n\tif(PIXI.gl)\n\t{\n\t\tthis.projection.x = this.width/2\n\t\tthis.projection.y = this.height/2;\n\t\n\t\tvar gl = PIXI.gl;\n\t\tgl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTexture);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width,  this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\t}\n\telse\n\t{\n\t\t\n\t\tthis.frame.width = this.width\n\t\tthis.frame.height = this.height;\n\t\tthis.renderer.resize(this.width, this.height);\n\t}\n}\n\n/**\n * Initializes the canvas data for this texture\n *\n * @method initCanvas\n * @private\n */\nPIXI.RenderTexture.prototype.initCanvas = function()\n{\n\tthis.renderer = new PIXI.CanvasRenderer(this.width, this.height, null, 0);\n\n\tthis.baseTexture = new PIXI.BaseTexture(this.renderer.view);\n\tthis.frame = new PIXI.Rectangle(0, 0, this.width, this.height);\n\n\tthis.render = this.renderCanvas;\n}\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderWebGL\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear)\n{\n\tvar gl = PIXI.gl;\n\n\t// enable the alpha color mask..\n\tgl.colorMask(true, true, true, true); \n\n\tgl.viewport(0, 0, this.width, this.height);\t\n\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.glFramebuffer );\n\n\tif(clear)\n\t{\n\t\tgl.clearColor(0,0,0, 0);     \n\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t}\n\n\t// THIS WILL MESS WITH HIT TESTING!\n\tvar children = displayObject.children;\n\n\t//TODO -? create a new one??? dont think so!\n\tvar originalWorldTransform = displayObject.worldTransform;\n\tdisplayObject.worldTransform = PIXI.mat3.create();//sthis.indetityMatrix;\n\t// modify to flip...\n\tdisplayObject.worldTransform[4] = -1;\n\tdisplayObject.worldTransform[5] = this.projection.y * 2;\n\n\t\n\tif(position)\n\t{\n\t\tdisplayObject.worldTransform[2] = position.x;\n\t\tdisplayObject.worldTransform[5] -= position.y;\n\t}\n\t\n\tPIXI.visibleCount++;\n\tdisplayObject.vcount = PIXI.visibleCount;\n\t\n\tfor(var i=0,j=children.length; i<j; i++)\n\t{\n\t\tchildren[i].updateTransform();\t\n\t}\n\n\tvar renderGroup = displayObject.__renderGroup;\n\n\tif(renderGroup)\n\t{\n\t\tif(displayObject == renderGroup.root)\n\t\t{\n\t\t\trenderGroup.render(this.projection);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trenderGroup.renderSpecific(displayObject, this.projection);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!this.renderGroup)this.renderGroup = new PIXI.WebGLRenderGroup(gl);\n\t\tthis.renderGroup.setRenderable(displayObject);\n\t\tthis.renderGroup.render(this.projection);\n\t}\n\n\tdisplayObject.worldTransform = originalWorldTransform;\n}\n\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderCanvas\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear)\n{\n\tvar children = displayObject.children;\n\n\tdisplayObject.worldTransform = PIXI.mat3.create();\n\t\n\tif(position)\n\t{\n\t\tdisplayObject.worldTransform[2] = position.x;\n\t\tdisplayObject.worldTransform[5] = position.y;\n\t}\n\t\n\n\tfor(var i=0,j=children.length; i<j; i++)\n\t{\n\t\tchildren[i].updateTransform();\t\n\t}\n\n\tif(clear)this.renderer.context.clearRect(0,0, this.width, this.height);\n\t\n    this.renderer.renderDisplayObject(displayObject);\n    \n    this.renderer.context.setTransform(1,0,0,1,0,0); \n    \n\n  //  PIXI.texturesToUpdate.push(this.baseTexture);\n}\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Class that loads a bunch of images / sprite sheet / bitmap font files. Once the\n * assets have been loaded they are added to the PIXI Texture cache and can be accessed\n * easily through PIXI.Texture.fromImage() and PIXI.Sprite.fromImage()\n * When all items have been loaded this class will dispatch a \"onLoaded\" event\n * As each individual item is loaded this class will dispatch a \"onProgress\" event\n *\n * @class AssetLoader\n * @constructor\n * @uses EventTarget\n * @param {Array<String>} assetURLs an array of image/sprite sheet urls that you would like loaded\n *      supported. Supported image formats include \"jpeg\", \"jpg\", \"png\", \"gif\". Supported\n *      sprite sheet data formats only include \"JSON\" at this time. Supported bitmap font\n *      data formats include \"xml\" and \"fnt\".\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.AssetLoader = function(assetURLs, crossorigin)\n{\n\tPIXI.EventTarget.call(this);\n\n\t/**\n\t * The array of asset URLs that are going to be loaded\n     *\n\t * @property assetURLs\n\t * @type Array<String>\n\t */\n\tthis.assetURLs = assetURLs;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n\tthis.crossorigin = crossorigin;\n\n    /**\n     * Maps file extension to loader types\n     *\n     * @property loadersByType\n     * @type Object\n     */\n    this.loadersByType = {\n        \"jpg\":  PIXI.ImageLoader,\n        \"jpeg\": PIXI.ImageLoader,\n        \"png\":  PIXI.ImageLoader,\n        \"gif\":  PIXI.ImageLoader,\n        \"json\": PIXI.JsonLoader,\n        \"anim\": PIXI.SpineLoader,\n        \"xml\":  PIXI.BitmapFontLoader,\n        \"fnt\":  PIXI.BitmapFontLoader\n    };\n    \n    \n};\n\n/**\n * Fired when an item has loaded\n * @event onProgress\n */\n\n/**\n * Fired when all the assets have loaded\n * @event onComplete \n */\n\n// constructor\nPIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;\n\n/**\n * Starts loading the assets sequentially\n *\n * @method load\n */\nPIXI.AssetLoader.prototype.load = function()\n{\n    var scope = this;\n\n\tthis.loadCount = this.assetURLs.length;\n\n    for (var i=0; i < this.assetURLs.length; i++)\n\t{\n\t\tvar fileName = this.assetURLs[i];\n\t\tvar fileType = fileName.split(\".\").pop().toLowerCase();\n\n        var loaderClass = this.loadersByType[fileType];\n        if(!loaderClass)\n            throw new Error(fileType + \" is an unsupported file type\");\n\n        var loader = new loaderClass(fileName, this.crossorigin);\n\n        loader.addEventListener(\"loaded\", function()\n        {\n            scope.onAssetLoaded();\n        });\n        loader.load();\n\t}\n};\n\n/**\n * Invoked after each file is loaded\n *\n * @method onAssetLoaded\n * @private\n */\nPIXI.AssetLoader.prototype.onAssetLoaded = function()\n{\n    this.loadCount--;\n\tthis.dispatchEvent({type: \"onProgress\", content: this});\n\tif(this.onProgress) this.onProgress();\n\t\n\tif(this.loadCount == 0)\n\t{\n\t\tthis.dispatchEvent({type: \"onComplete\", content: this});\n\t\tif(this.onComplete) this.onComplete();\n\t}\n};\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The json file loader is used to load in JSON data and parsing it\n * When loaded this class will dispatch a \"loaded\" event\n * If load failed this class will dispatch a \"error\" event\n *\n * @class JsonLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.JsonLoader = function (url, crossorigin) {\n\tPIXI.EventTarget.call(this);\n\n\t/**\n\t * The url of the bitmap font data\n\t *\n\t * @property url\n\t * @type String\n\t */\n\tthis.url = url;\n\n\t/**\n\t * Whether the requests should be treated as cross origin\n\t *\n\t * @property crossorigin\n\t * @type Boolean\n\t */\n\tthis.crossorigin = crossorigin;\n\n\t/**\n\t * [read-only] The base url of the bitmap font data\n\t *\n\t * @property baseUrl\n\t * @type String\n\t * @readOnly\n\t */\n\tthis.baseUrl = url.replace(/[^\\/]*$/, \"\");\n\n\t/**\n\t * [read-only] Whether the data has loaded yet\n\t *\n\t * @property loaded\n\t * @type Boolean\n\t * @readOnly\n\t */\n\tthis.loaded = false;\n\t\n};\n\n// constructor\nPIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;\n\n/**\n * Loads the JSON data\n *\n * @method load\n */\nPIXI.JsonLoader.prototype.load = function () {\n\tthis.ajaxRequest = new AjaxRequest();\n\tvar scope = this;\n\tthis.ajaxRequest.onreadystatechange = function () {\n\t\tscope.onJSONLoaded();\n\t};\n\n\tthis.ajaxRequest.open(\"GET\", this.url, true);\n\tif (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType(\"application/json\");\n\tthis.ajaxRequest.send(null);\n};\n\n/**\n * Invoke when JSON file is loaded\n *\n * @method onJSONLoaded\n * @private\n */\nPIXI.JsonLoader.prototype.onJSONLoaded = function () {\n\tif (this.ajaxRequest.readyState == 4) {\n\t\tif (this.ajaxRequest.status == 200 || window.location.href.indexOf(\"http\") == -1) {\n\t\t\tthis.json = JSON.parse(this.ajaxRequest.responseText);\n\t\t\t\n\t\t\tif(this.json.frames)\n\t\t\t{\n\t\t\t\t// sprite sheet\n\t\t\t\tvar scope = this;\n\t\t\t\tvar textureUrl = this.baseUrl + this.json.meta.image;\n\t\t\t\tvar image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n\t\t\t\tvar frameData = this.json.frames;\n\t\t\t\n\t\t\t\tthis.texture = image.texture.baseTexture;\n\t\t\t\timage.addEventListener(\"loaded\", function (event) {\n\t\t\t\t\tscope.onLoaded();\n\t\t\t\t});\n\t\t\t\n\t\t\t\tfor (var i in frameData) {\n\t\t\t\t\tvar rect = frameData[i].frame;\n\t\t\t\t\tif (rect) {\n\t\t\t\t\t\tPIXI.TextureCache[i] = new PIXI.Texture(this.texture, {\n\t\t\t\t\t\t\tx: rect.x,\n\t\t\t\t\t\t\ty: rect.y,\n\t\t\t\t\t\t\twidth: rect.w,\n\t\t\t\t\t\t\theight: rect.h\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (frameData[i].trimmed) {\n\t\t\t\t\t\t\t//var realSize = frameData[i].spriteSourceSize;\n\t\t\t\t\t\t\tPIXI.TextureCache[i].realSize = frameData[i].spriteSourceSize;\n\t\t\t\t\t\t\tPIXI.TextureCache[i].trim.x = 0; // (realSize.x / rect.w)\n\t\t\t\t\t\t\t// calculate the offset!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\timage.load();\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(this.json.bones)\n\t\t\t{\n\t\t\t\t// spine animation\n\t\t\t\tvar spineJsonParser = new spine.SkeletonJson();\n\t\t\t\tvar skeletonData = spineJsonParser.readSkeletonData(this.json);\n\t\t\t\tPIXI.AnimCache[this.url] = skeletonData;\n\t\t\t\tthis.onLoaded();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.onLoaded();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.onError();\n\t\t}\n\t}\n};\n\n/**\n * Invoke when json file loaded\n *\n * @method onLoaded\n * @private\n */\nPIXI.JsonLoader.prototype.onLoaded = function () {\n\tthis.loaded = true;\n\tthis.dispatchEvent({\n\t\ttype: \"loaded\",\n\t\tcontent: this\n\t});\n};\n\n/**\n * Invoke when error occured\n *\n * @method onError\n * @private\n */\nPIXI.JsonLoader.prototype.onError = function () {\n\tthis.dispatchEvent({\n\t\ttype: \"error\",\n\t\tcontent: this\n\t});\n};\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The sprite sheet loader is used to load in JSON sprite sheet data\n * To generate the data you can use http://www.codeandweb.com/texturepacker and publish the \"JSON\" format\n * There is a free version so thats nice, although the paid version is great value for money.\n * It is highly recommended to use Sprite sheets (also know as texture atlas\") as it means sprite\"s can be batched and drawn together for highly increased rendering speed.\n * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFromeId()\n * This loader will also load the image file that the Spritesheet points to as well as the data.\n * When loaded this class will dispatch a \"loaded\" event\n *\n * @class SpriteSheetLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the sprite sheet JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\n\nPIXI.SpriteSheetLoader = function (url, crossorigin) {\n\t/*\n\t * i use texture packer to load the assets..\n\t * http://www.codeandweb.com/texturepacker\n\t * make sure to set the format as \"JSON\"\n\t */\n\tPIXI.EventTarget.call(this);\n\n\t/**\n\t * The url of the bitmap font data\n\t *\n\t * @property url\n\t * @type String\n\t */\n\tthis.url = url;\n\n\t/**\n\t * Whether the requests should be treated as cross origin\n\t *\n\t * @property crossorigin\n\t * @type Boolean\n\t */\n\tthis.crossorigin = crossorigin;\n\n\t/**\n\t * [read-only] The base url of the bitmap font data\n\t *\n\t * @property baseUrl\n\t * @type String\n\t * @readOnly\n\t */\n\tthis.baseUrl = url.replace(/[^\\/]*$/, \"\");\n\n    /**\n     * The texture being loaded\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = null;\n\n    /**\n     * The frames of the sprite sheet\n     *\n     * @property frames\n     * @type Object\n     */\n\tthis.frames = {};\n};\n\n// constructor\nPIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;\n\n/**\n * This will begin loading the JSON file\n *\n * @method load\n */\nPIXI.SpriteSheetLoader.prototype.load = function () {\n\tvar scope = this;\n\tvar jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);\n\tjsonLoader.addEventListener(\"loaded\", function (event) {\n\t\tscope.json = event.content.json;\n\t\tscope.onJSONLoaded();\n\t});\n\tjsonLoader.load();\n};\n\n/**\n * Invoke when JSON file is loaded\n *\n * @method onJSONLoaded\n * @private\n */\nPIXI.SpriteSheetLoader.prototype.onJSONLoaded = function () {\n\tvar scope = this;\n\tvar textureUrl = this.baseUrl + this.json.meta.image;\n\tvar image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n\tvar frameData = this.json.frames;\n\n\tthis.texture = image.texture.baseTexture;\n\timage.addEventListener(\"loaded\", function (event) {\n\t\tscope.onLoaded();\n\t});\n\n\tfor (var i in frameData) {\n\t\tvar rect = frameData[i].frame;\n\t\tif (rect) {\n\t\t\tPIXI.TextureCache[i] = new PIXI.Texture(this.texture, {\n\t\t\t\tx: rect.x,\n\t\t\t\ty: rect.y,\n\t\t\t\twidth: rect.w,\n\t\t\t\theight: rect.h\n\t\t\t});\n\t\t\tif (frameData[i].trimmed) {\n\t\t\t\t//var realSize = frameData[i].spriteSourceSize;\n\t\t\t\tPIXI.TextureCache[i].realSize = frameData[i].spriteSourceSize;\n\t\t\t\tPIXI.TextureCache[i].trim.x = 0; // (realSize.x / rect.w)\n\t\t\t\t// calculate the offset!\n\t\t\t}\n\t\t}\n\t}\n\n\timage.load();\n};\n/**\n * Invoke when all files are loaded (json and texture)\n *\n * @method onLoaded\n * @private\n */\nPIXI.SpriteSheetLoader.prototype.onLoaded = function () {\n\tthis.dispatchEvent({\n\t\ttype: \"loaded\",\n\t\tcontent: this\n\t});\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The image loader class is responsible for loading images file formats (\"jpeg\", \"jpg\", \"png\" and \"gif\")\n * Once the image has been loaded it is stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFromeId()\n * When loaded this class will dispatch a 'loaded' event\n *\n * @class ImageLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the image\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.ImageLoader = function(url, crossorigin)\n{\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The texture being loaded\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = PIXI.Texture.fromImage(url, crossorigin);\n};\n\n// constructor\nPIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;\n\n/**\n * Loads image or takes it from cache\n *\n * @method load\n */\nPIXI.ImageLoader.prototype.load = function()\n{\n    if(!this.texture.baseTexture.hasLoaded)\n    {\n        var scope = this;\n        this.texture.baseTexture.addEventListener(\"loaded\", function()\n        {\n            scope.onLoaded();\n        });\n    }\n    else\n    {\n        this.onLoaded();\n    }\n};\n\n/**\n * Invoked when image file is loaded or it is already cached and ready to use\n *\n * @method onLoaded\n * @private\n */\nPIXI.ImageLoader.prototype.onLoaded = function()\n{\n    this.dispatchEvent({type: \"loaded\", content: this});\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The xml loader is used to load in XML bitmap font data (\"xml\" or \"fnt\")\n * To generate the data you can use http://www.angelcode.com/products/bmfont/\n * This loader will also load the image file as the data.\n * When loaded this class will dispatch a \"loaded\" event\n *\n * @class BitmapFontLoader\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the sprite sheet JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.BitmapFontLoader = function(url, crossorigin)\n{\n    /*\n     * i use texture packer to load the assets..\n     * http://www.codeandweb.com/texturepacker\n     * make sure to set the format as \"JSON\"\n     */\n    PIXI.EventTarget.call(this);\n\n    /**\n     * The url of the bitmap font data\n     *\n     * @property url\n     * @type String\n     */\n    this.url = url;\n\n    /**\n     * Whether the requests should be treated as cross origin\n     *\n     * @property crossorigin\n     * @type Boolean\n     */\n    this.crossorigin = crossorigin;\n\n    /**\n     * [read-only] The base url of the bitmap font data\n     *\n     * @property baseUrl\n     * @type String\n     * @readOnly\n     */\n    this.baseUrl = url.replace(/[^\\/]*$/, \"\");\n\n    /**\n     * [read-only] The texture of the bitmap font\n     *\n     * @property baseUrl\n     * @type String\n     */\n    this.texture = null;\n};\n\n// constructor\nPIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;\n\n/**\n * Loads the XML font data\n *\n * @method load\n */\nPIXI.BitmapFontLoader.prototype.load = function()\n{\n    this.ajaxRequest = new XMLHttpRequest();\n    var scope = this;\n    this.ajaxRequest.onreadystatechange = function()\n    {\n        scope.onXMLLoaded();\n    };\n\n    this.ajaxRequest.open(\"GET\", this.url, true);\n    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType(\"application/xml\");\n    this.ajaxRequest.send(null)\n};\n\n/**\n * Invoked when XML file is loaded, parses the data\n *\n * @method onXMLLoaded\n * @private\n */\nPIXI.BitmapFontLoader.prototype.onXMLLoaded = function()\n{\n    if (this.ajaxRequest.readyState == 4)\n    {\n        if (this.ajaxRequest.status == 200 || window.location.href.indexOf(\"http\") == -1)\n        {\n            var textureUrl = this.baseUrl + this.ajaxRequest.responseXML.getElementsByTagName(\"page\")[0].attributes.getNamedItem(\"file\").nodeValue;\n            var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);\n            this.texture = image.texture.baseTexture;\n\n            var data = {};\n            var info = this.ajaxRequest.responseXML.getElementsByTagName(\"info\")[0];\n            var common = this.ajaxRequest.responseXML.getElementsByTagName(\"common\")[0];\n            data.font = info.attributes.getNamedItem(\"face\").nodeValue;\n            data.size = parseInt(info.attributes.getNamedItem(\"size\").nodeValue, 10);\n            data.lineHeight = parseInt(common.attributes.getNamedItem(\"lineHeight\").nodeValue, 10);\n            data.chars = {};\n\n            //parse letters\n            var letters = this.ajaxRequest.responseXML.getElementsByTagName(\"char\");\n\n            for (var i = 0; i < letters.length; i++)\n            {\n                var charCode = parseInt(letters[i].attributes.getNamedItem(\"id\").nodeValue, 10);\n\n                var textureRect = {\n                    x: parseInt(letters[i].attributes.getNamedItem(\"x\").nodeValue, 10),\n                    y: parseInt(letters[i].attributes.getNamedItem(\"y\").nodeValue, 10),\n                    width: parseInt(letters[i].attributes.getNamedItem(\"width\").nodeValue, 10),\n                    height: parseInt(letters[i].attributes.getNamedItem(\"height\").nodeValue, 10)\n                };\n                PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect);\n\n                data.chars[charCode] = {\n                    xOffset: parseInt(letters[i].attributes.getNamedItem(\"xoffset\").nodeValue, 10),\n                    yOffset: parseInt(letters[i].attributes.getNamedItem(\"yoffset\").nodeValue, 10),\n                    xAdvance: parseInt(letters[i].attributes.getNamedItem(\"xadvance\").nodeValue, 10),\n                    kerning: {},\n                    texture:new PIXI.Texture(this.texture, textureRect)\n\n                };\n            }\n\n            //parse kernings\n            var kernings = this.ajaxRequest.responseXML.getElementsByTagName(\"kerning\");\n            for (i = 0; i < kernings.length; i++)\n            {\n               var first = parseInt(kernings[i].attributes.getNamedItem(\"first\").nodeValue, 10);\n               var second = parseInt(kernings[i].attributes.getNamedItem(\"second\").nodeValue, 10);\n               var amount = parseInt(kernings[i].attributes.getNamedItem(\"amount\").nodeValue, 10);\n\n                data.chars[second].kerning[first] = amount;\n\n            }\n\n            PIXI.BitmapText.fonts[data.font] = data;\n\n            var scope = this;\n            image.addEventListener(\"loaded\", function() {\n                scope.onLoaded();\n            });\n            image.load();\n        }\n    }\n};\n\n/**\n * Invoked when all files are loaded (xml/fnt and texture)\n *\n * @method onLoaded\n * @private\n */\nPIXI.BitmapFontLoader.prototype.onLoaded = function()\n{\n    this.dispatchEvent({type: \"loaded\", content: this});\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi\n * \n * Awesome JS run time provided by EsotericSoftware\n * https://github.com/EsotericSoftware/spine-runtimes\n * \n */\n\n/**\n * The Spine loader is used to load in JSON spine data\n * To generate the data you need to use http://esotericsoftware.com/ and export the \"JSON\" format\n * Due to a clash of names  You will need to change the extension of the spine file from *.json to *.anim for it to load\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n * You will need to generate a sprite sheet to accompany the spine data \n * When loaded this class will dispatch a \"loaded\" event\n *\n * @class Spine\n * @uses EventTarget\n * @constructor\n * @param url {String} The url of the JSON file\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n */\nPIXI.SpineLoader = function(url, crossorigin) \n{\n\tPIXI.EventTarget.call(this);\n\n\t/**\n\t * The url of the bitmap font data\n\t *\n\t * @property url\n\t * @type String\n\t */\n\tthis.url = url;\n\n\t/**\n\t * Whether the requests should be treated as cross origin\n\t *\n\t * @property crossorigin\n\t * @type Boolean\n\t */\n\tthis.crossorigin = crossorigin;\n\n\t/**\n\t * [read-only] Whether the data has loaded yet\n\t *\n\t * @property loaded\n\t * @type Boolean\n\t * @readOnly\n\t */\n\tthis.loaded = false;\n}\n\nPIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;\n\n/**\n * Loads the JSON data\n *\n * @method load\n */\nPIXI.SpineLoader.prototype.load = function () {\n\t\n\tvar scope = this;\n\tvar jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);\n\tjsonLoader.addEventListener(\"loaded\", function (event) {\n\t\tscope.json = event.content.json;\n\t\tscope.onJSONLoaded();\n\t});\n\tjsonLoader.load();\n};\n\n/**\n * Invoke when JSON file is loaded\n *\n * @method onJSONLoaded\n * @private\n */\nPIXI.SpineLoader.prototype.onJSONLoaded = function (event) {\n\tvar spineJsonParser = new spine.SkeletonJson();\n\tvar skeletonData = spineJsonParser.readSkeletonData(this.json);\n\t\n\tPIXI.AnimCache[this.url] = skeletonData;\n\n\tthis.onLoaded();\n};\n\n/**\n * Invoke when JSON file is loaded\n *\n * @method onLoaded\n * @private\n */\nPIXI.SpineLoader.prototype.onLoaded = function () {\n\tthis.loaded = true;\n    this.dispatchEvent({type: \"loaded\", content: this});\n};\n\n\n/**\r\n * @author Mat Groves http://matgroves.com/ @Doormat23\r\n */\r\n\r\n if (typeof exports !== 'undefined') {\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n      exports = module.exports = PIXI;\r\n    }\r\n    exports.PIXI = PIXI;\r\n  } else {\r\n    root.PIXI = PIXI;\r\n  }\r\n\r\n\r\n}).call(this);\ndefine(\"PIXI\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.PIXI;\n    };\n}(this)));\n","\ndefine ('GameModel',['require'],function (require) {\n\tfunction GameModel ()\n\t{\n\t\t\n\t}\n\n\treturn GameModel;\n});","\ndefine ('Hero',['require','PIXI'],function (require) {\n\t\n\treturn function Hero (id, textureImage, PeripheralControllerClass, gameWidth, gameHeight)\n\t{\n\t\tvar _self = this,\n\n\t\t\tPIXI = require (\"PIXI\"),\n\n\t\t\tVELOCITY_INCREMENTOR = 0.4,\n\t\t\tMAX_SPEED_X = 20,\n\t\t\tMAX_SPEED_Y = 20,\n\n\t\t\t_gameWidth = gameWidth,\n\t\t\t_gameHeight = gameHeight,\n\t\t\t_minPosX,\n\t\t\t_minPosY,\n\t\t\t_maxPosX,\n\t\t\t_maxPosY,\n\t\t\t_textureImage = PIXI.Texture.fromImage (textureImage),\n\t\t\t_vx = 0,\n\t\t\t_vy = 0,\n\t\t\t_dx = 0,\n\t\t\t_dy = 0,\n\t\t\t_controlSystem = new PeripheralControllerClass ();\n\n\t\tinit ();\n\n\t\tfunction init ()\n\t\t{\n\t\t\t_self.sprite = new PIXI.Sprite (_textureImage);\n\n\t\t\t_minPosX = _self.sprite.width * 0.5;\n\t\t\t_minPosY = _self.sprite.height * 0.5;\n\t\t\t_maxPosX = _gameWidth - (_self.sprite.width * 0.5);\n\t\t\t_maxPosY = _gameHeight - (_self.sprite.height * 0.5);\n\n\t\t\t_self.sprite.anchor.x = _self.sprite.anchor.y = 0.5; // centre the sprite's anchor point.\n\t\t\t_self.sprite.position.x = _gameWidth * 0.5;\n\t\t\t_self.sprite.position.y = _maxPosY;\n\t\t}\n\n\t\t_self.update = function ()\n\t\t{\n\t\t\tif (_controlSystem.movingLeft)\n\t\t\t{\n\t\t\t\t_dx = -1;\n\t\t\t\tupdateVelocityX ();\n\t\t\t}\n\t\t\telse if (_controlSystem.movingRight)\n\t\t\t{\n\t\t\t\t_dx = 1;\n\t\t\t\tupdateVelocityX ();\n\t\t\t}\n\t\t\telse if (_vx !== 0)\n\t\t\t{\n\t\t\t\tdecreaseVelocityX ();\n\t\t\t}\n\n\n\t\t\tif (_controlSystem.movingUp)\n\t\t\t{\n\t\t\t\t_dy = -1;\n\t\t\t\tupdateVelocityY ();\n\t\t\t}\n\t\t\telse if (_controlSystem.movingDown)\n\t\t\t{\n\t\t\t\t_dy = 1;\n\t\t\t\tupdateVelocityY ();\n\t\t\t}\n\t\t\telse if (_vy !== 0)\n\t\t\t{\n\t\t\t\tdecreaseVelocityY ();\n\t\t\t}\n\t\t\t\n\t\t\t_self.sprite.position.x += _vx;\n\t\t\t_self.sprite.position.y += _vy;\n\n\t\t\tif (_self.sprite.position.x < _minPosX)\n\t\t\t{\n\t\t\t\t_self.sprite.position.x = _minPosX;\n\t\t\t\t_vx = 0;\n\t\t\t}\n\t\t\telse if (_self.sprite.position.x > _maxPosX)\n\t\t\t{\n\t\t\t\t_self.sprite.position.x = _maxPosX;\n\t\t\t\t_vx = 0;\n\t\t\t}\n\n\t\t\tif (_self.sprite.position.y < _minPosY)\n\t\t\t{\n\t\t\t\t_self.sprite.position.y = _minPosY;\n\t\t\t\t_vy = 0;\n\t\t\t}\n\t\t\telse if (_self.sprite.position.y > _maxPosY)\n\t\t\t{\n\t\t\t\t_self.sprite.position.y = _maxPosY;\n\t\t\t\t_vy = 0;\n\t\t\t}\n\t\t};\n\n\t\tfunction updateVelocityX ()\n\t\t{\n\t\t\t_vx += (_dx === 1 ? VELOCITY_INCREMENTOR : -VELOCITY_INCREMENTOR);\n\n\t\t\tif (_vx > MAX_SPEED_X)\n\t\t\t{\n\t\t\t\t_vx = MAX_SPEED_X;\n\t\t\t}\n\t\t\telse if (_vx < -MAX_SPEED_X)\n\t\t\t{\n\t\t\t\t_vx = -MAX_SPEED_X;\n\t\t\t}\n\t\t}\n\n\t\tfunction decreaseVelocityX ()\n\t\t{\n\t\t\t// gradually reduce velocity in either positive or negative direction based on whether\n\t\t\t// we were previously moving right or left.\n\t\t\tif (_dx === 1)\n\t\t\t{\n\t\t\t\t_vx -= VELOCITY_INCREMENTOR;\n\t\t\t\tif (_vx < 0) _vx = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_vx += VELOCITY_INCREMENTOR;\n\t\t\t\tif (_vx > 0) _vx = 0;\n\t\t\t}\n\t\t}\n\n\t\tfunction updateVelocityY ()\n\t\t{\n\t\t\t_vy += (_dy === 1 ? VELOCITY_INCREMENTOR : -VELOCITY_INCREMENTOR);\n\n\t\t\tif (_vy > MAX_SPEED_Y)\n\t\t\t{\n\t\t\t\t_vy = MAX_SPEED_Y;\n\t\t\t}\n\t\t\telse if (_vy < -MAX_SPEED_Y)\n\t\t\t{\n\t\t\t\t_vy = -MAX_SPEED_Y;\n\t\t\t}\n\t\t}\n\n\t\tfunction decreaseVelocityY ()\n\t\t{\n\t\t\t// gradually reduce velocity in either positive or negative direction based on whether\n\t\t\t// we were previously moving dowm or up.\n\t\t\tif (_dy === 1)\n\t\t\t{\n\t\t\t\t_vy -= VELOCITY_INCREMENTOR;\n\t\t\t\tif (_vy < 0) _vy = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_vy += VELOCITY_INCREMENTOR;\n\t\t\t\tif (_vy > 0) _vy = 0;\n\t\t\t}\n\t\t}\n\t};\n});","\ndefine ('KeyboardController',['require'],function (require) {\n\t\n\treturn function KeyboardController () // Extend PeripheralController?\n\t{\n\t\tvar _self = this,\n\n\t\t\t_keys =\n\t\t\t{\n\t\t\t\tleft\t:\t37,\n\t\t\t\tup\t\t:\t38,\n\t\t\t\tright\t:\t39,\n\t\t\t\tdown\t:\t40\n\t\t\t};\n\n\t\t_self.movingLeft = false;\n\t\t_self.movingUp = false;\n\t\t_self.movingRight = false;\n\t\t_self.movingDown = false;\n\n\t\tdocument.addEventListener(\"keydown\", keydownHandler, false);\n\t\tdocument.addEventListener(\"keyup\", keyupHandler, false);\n\n\t\tfunction keydownHandler (event)\n\t\t{\n\t\t\tswitch (event.keyCode)\n\t\t\t{\n\t\t\t\tcase _keys.left :\n\n\t\t\t\t\t_self.movingLeft = true;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _keys.up :\n\n\t\t\t\t\t_self.movingUp = true;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _keys.right :\n\n\t\t\t\t\t_self.movingRight = true;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _keys.down :\n\n\t\t\t\t\t_self.movingDown = true;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction keyupHandler (event)\n\t\t{\n\t\t\tswitch (event.keyCode)\n\t\t\t{\n\t\t\t\tcase _keys.left :\n\t\t\t\t\t\n\t\t\t\t\t_self.movingLeft = false;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _keys.up :\n\n\t\t\t\t\t_self.movingUp = false;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _keys.right :\n\n\t\t\t\t\t_self.movingRight = false;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _keys.down :\n\n\t\t\t\t\t_self.movingDown = false;\n\t\t\t\t\tevent.preventDefault ();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n});","\ndefine ('BattleWing',['require','ImagePreloader','PIXI','GameModel','Hero','KeyboardController'],function (require) {\n\t\n\treturn function BattleWing ()\n\t{\n\t\tvar ImagePreloaderClass = require (\"ImagePreloader\"),\n\t\t\tPIXI = require (\"PIXI\"),\n\t\t\tGameModel = require (\"GameModel\"),\n\t\t\tHero = require (\"Hero\"),\n\n\t\t\tGAME_WIDTH_DESKTOP = 1024,\n\t\t\tGAME_HEIGHT_DESKTOP = 768,\n\n\t\t\t_imagePreloader,\n\t\t\t_canvas = document.getElementById (\"game-canvas\"),\n\t\t\t_stage = new PIXI.Stage (0xfff),\n\t\t\t_renderer = new PIXI.autoDetectRenderer (GAME_WIDTH_DESKTOP, GAME_HEIGHT_DESKTOP, _canvas),\n\t\t\t_heroesServerDataArray,\n\t\t\t_heroesArray = [],\n\t\t\t_peripheralControllers =\n\t\t\t{\n\t\t\t\tKeyboardController : require (\"KeyboardController\"),\n\t\t\t\t//MouseController : require (\"MouseController\"),\n\t\t\t};\n\n\t\tinit ();\n\n\t\tfunction init ()\n\t\t{\n\t\t\tdocument.body.appendChild (_renderer.view);\n\n\t\t\t// TODO : get hero data array from the Node server.\n\t\t\t_heroesServerDataArray = [{id:\"someNodeID\", graphic:\"img/ship_body.png\", peripheralType:\"KeyboardController\"}];\n\n\t\t\t// TODO : only run this method once we receive the heroes data from the server.\n\t\t\tpreloadHeroImages ();\n\t\t}\n\n\t\tfunction preloadHeroImages ()\n\t\t{\n\t\t\t_imagePreloader = new ImagePreloaderClass ();\n\n\t\t\tvar i = 0,\n\t\t\t\tlength = _heroesServerDataArray.length,\n\t\t\t\tcurrentHeroData,\n\t\t\t\timagesToPreload = [];\n\n\t\t\tfor (i; i < length; ++i)\n\t\t\t{\n\t\t\t\tcurrentHeroData = _heroesServerDataArray[i];\n\t\t\t\timagesToPreload.push (currentHeroData.graphic);\n\t\t\t}\n\n\t\t\t_imagePreloader.loadMultiple (imagesToPreload, allImagesLoaded);\n\t\t}\n\n\t\tfunction allImagesLoaded ()\n\t\t{\n\t\t\tsetupHeroes ();\n\t\t\tstartGame ();\n\t\t}\n\n\t\tfunction setupHeroes ()\n\t\t{\n\t\t\tvar i = 0,\n\t\t\t\tlength = _heroesServerDataArray.length,\n\t\t\t\tcurrentHeroData;\n\n\t\t\tfor (i; i < length; ++i)\n\t\t\t{\n\t\t\t\tcurrentHeroData = _heroesServerDataArray[i];\n\n\t\t\t\t// number of heros and their respective peripheral controller string should come from the Node server.\n\t\t\t\tvar hero = new Hero (currentHeroData.id, currentHeroData.graphic, _peripheralControllers[currentHeroData.peripheralType], GAME_WIDTH_DESKTOP, GAME_HEIGHT_DESKTOP);\n\t\t\t\t_heroesArray.push (hero);\n\n\t\t\t\t_stage.addChild (hero.sprite);\n\t\t\t}\n\t\t}\n\n\t\tfunction gameLoop ()\n\t\t{\n\t\t\trequestAnimationFrame (gameLoop);\n\n\t\t\tvar i = 0,\n\t\t\t\tlength = _heroesArray.length,\n\t\t\t\tcurrentHero;\n\n\t\t\tfor (i; i < length; i++)\n\t\t\t{\n\t\t\t\tcurrentHero = _heroesArray[i];\n\t\t\t\tcurrentHero.update ();\n\t\t\t}\n\n\t\t\t_renderer.render (_stage);\n\t\t}\n\n\t\tfunction startGame ()\n\t\t{\n\t\t\t_animationFrame = requestAnimationFrame (gameLoop);\n\t\t}\n\n\t\tfunction stopGame ()\n\t\t{\n\t\t\tcancelAnimationFrame (_animationFrame);\n\t\t}\n\t};\n});"]}